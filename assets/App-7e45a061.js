import{r as C,M as de,j as V,F as K,a as z,c as fs,C as pe,S as ve,U as ds,b as Yn,B as Le,V as q,d as Ue,e as se,D as hs,f as ps,g as ms,h as vs,W as ce,E as yt,L as _i,N as Ei,i as Re,k as H,R as gs,l as Qe,m as ys,n as xs,o as Ht,p as Yt,q as Vt,s as ft,t as wn,u as Kt,T as Zt,v as Je,w as Tn,P as Ci,x as Ss,y as Mi,z as Pi,A as Gt,G as me,H as Kn,I as fe,J as Ln,K as Bi,O as bs,Q as ws,X as Ts,Y as As,Z as N,_ as we,$ as Ri,a0 as Se,a1 as dt,a2 as _s,a3 as ge,a4 as Es,a5 as ht,a6 as kt,a7 as zi,a8 as Ye,a9 as De,aa as Cs,ab as Ms,ac as Ps,ad as jt,ae as Ni,af as Un,ag as Bs,ah as Rs,ai as Zn,aj as Ke,ak as zs,al as Ns,am as Ds,an as Ls}from"./index-211af6b4.js";import{Vector3 as Us,Vector2 as Is,UniformsUtils as Di,UniformsLib as Qn,ShaderMaterial as Os}from"//cdn.skypack.dev/three@0.130.1/build/three.module.js";import"//cdn.skypack.dev/three@0.130.1/examples/jsm/lines/LineSegmentsGeometry.js";let st;function ks(){var e;if(st!==void 0)return st;try{let t;const n=document.createElement("canvas");return st=!!(window.WebGL2RenderingContext&&(t=n.getContext("webgl2"))),t&&((e=t.getExtension("WEBGL_lose_context"))==null||e.loseContext()),st}catch{return st=!1}}function Fs(){let{setStepPosition:e,stepCount:t}=C.useContext(de);const n=()=>{t++,e(t)},i=()=>{t--,e(t)};return V(K,{children:[t>=1?z("button",{onClick:i,className:"btn",id:"nextStep",children:" ❮ Previous Step  "}):null,z("button",{onClick:n,className:"btn",id:"nextStep",children:"Next Step ❯ "})]})}const Hs=e=>(t,n,i)=>{const s=i.subscribe;return i.subscribe=(r,o,l)=>{let u=r;if(o){const c=(l==null?void 0:l.equalityFn)||Object.is;let d=r(i.getState());u=f=>{const p=r(f);if(!c(d,p)){const x=d;o(d=p,x)}},l!=null&&l.fireImmediately&&o(d,d)}return s(u)},e(t,n,i)},Vs=Hs,te=fs(Vs(e=>({blocksCount:3,cameraPositionTag:"zero",isVisible:"visible",wiringStep:!1,resetCamera:()=>{e(()=>({cameraPositionTag:"initial"}))},freeControls:()=>{e(()=>({cameraPositionTag:"zero"}))},topCamera:()=>{e(t=>({cameraPosition:"top"}))},isNotVisibleToggle:()=>{e(()=>({isVisible:"hidden"}))},isVisibleToggle:()=>{e(()=>({isVisible:"visible"}))},isWiringStep:()=>{e(()=>({wiringStep:!0}))},isNotWiringStep:()=>{e(()=>({wiringStep:!1}))}})));function Gs(){const{setModelInOut:e,selectedParts:t}=C.useContext(de),[n,i]=C.useState(!1),s=te(r=>r.wiringStep);return z(K,{children:s?null:z("button",{onClick:()=>{n==!1?(document.getElementById("partsOut").innerHTML="Assemble",i(!0),e(n)):n==!0&&(document.getElementById("partsOut").innerHTML="Explode",i(!1),e(n))},className:"btn",id:"partsOut",children:"Explode"})})}let js=class{constructor(t,n={}){this.enabled=!0;const i=n.defaultThickness!==void 0?n.defaultThickness:.003,s=new pe().fromArray(n.defaultColor!==void 0?n.defaultColor:[0,0,0]),a=n.defaultAlpha!==void 0?n.defaultAlpha:1,r=n.defaultKeepAlive!==void 0?n.defaultKeepAlive:!1,o={},l=60,u={},c={},d={outlineThickness:{value:i},outlineColor:{value:s},outlineAlpha:{value:a}},f=["#include <common>","#include <uv_pars_vertex>","#include <displacementmap_pars_vertex>","#include <fog_pars_vertex>","#include <morphtarget_pars_vertex>","#include <skinning_pars_vertex>","#include <logdepthbuf_pars_vertex>","#include <clipping_planes_pars_vertex>","uniform float outlineThickness;","vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {","	float thickness = outlineThickness;","	const float ratio = 1.0;","	vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );","	vec4 norm = normalize( pos - pos2 );","	return pos + norm * thickness * pos.w * ratio;","}","void main() {","	#include <uv_vertex>","	#include <beginnormal_vertex>","	#include <morphnormal_vertex>","	#include <skinbase_vertex>","	#include <skinnormal_vertex>","	#include <begin_vertex>","	#include <morphtarget_vertex>","	#include <skinning_vertex>","	#include <displacementmap_vertex>","	#include <project_vertex>","	vec3 outlineNormal = - objectNormal;","	gl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );","	#include <logdepthbuf_vertex>","	#include <clipping_planes_vertex>","	#include <fog_vertex>","}"].join(`
`),p=["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","#include <clipping_planes_pars_fragment>","uniform vec3 outlineColor;","uniform float outlineAlpha;","void main() {","	#include <clipping_planes_fragment>","	#include <logdepthbuf_fragment>","	gl_FragColor = vec4( outlineColor, outlineAlpha );","	#include <tonemapping_fragment>","	#include <encodings_fragment>","	#include <fog_fragment>","	#include <premultiplied_alpha_fragment>","}"].join(`
`);function x(){return new ve({type:"OutlineEffect",uniforms:ds.merge([Yn.fog,Yn.displacementmap,d]),vertexShader:f,fragmentShader:p,side:Le})}function w(v){let y=o[v.uuid];return y===void 0&&(y={material:x(),used:!0,keepAlive:r,count:0},o[v.uuid]=y),y.used=!0,y.material}function S(v){const y=w(v);return u[y.uuid]=v,M(y,v),y}function g(v){const y=v.geometry,b=y!==void 0&&y.attributes.normal!==void 0;return v.isMesh===!0&&v.material!==void 0&&b===!0}function m(v){if(g(v)!==!1){if(Array.isArray(v.material))for(let y=0,b=v.material.length;y<b;y++)v.material[y]=S(v.material[y]);else v.material=S(v.material);c[v.uuid]=v.onBeforeRender,v.onBeforeRender=A}}function h(v){if(g(v)!==!1){if(Array.isArray(v.material))for(let y=0,b=v.material.length;y<b;y++)v.material[y]=u[v.material[y].uuid];else v.material=u[v.material.uuid];v.onBeforeRender=c[v.uuid]}}function A(v,y,b,P,E){const R=u[E.uuid];R!==void 0&&T(E,R)}function T(v,y){const b=y.userData.outlineParameters;v.uniforms.outlineAlpha.value=y.opacity,b!==void 0&&(b.thickness!==void 0&&(v.uniforms.outlineThickness.value=b.thickness),b.color!==void 0&&v.uniforms.outlineColor.value.fromArray(b.color),b.alpha!==void 0&&(v.uniforms.outlineAlpha.value=b.alpha)),y.displacementMap&&(v.uniforms.displacementMap.value=y.displacementMap,v.uniforms.displacementScale.value=y.displacementScale,v.uniforms.displacementBias.value=y.displacementBias)}function M(v,y){if(v.name==="invisible")return;const b=y.userData.outlineParameters;v.fog=y.fog,v.toneMapped=y.toneMapped,v.premultipliedAlpha=y.premultipliedAlpha,v.displacementMap=y.displacementMap,b!==void 0?(y.visible===!1?v.visible=!1:v.visible=b.visible!==void 0?b.visible:!0,v.transparent=b.alpha!==void 0&&b.alpha<1?!0:y.transparent,b.keepAlive!==void 0&&(o[y.uuid].keepAlive=b.keepAlive)):(v.transparent=y.transparent,v.visible=y.visible),(y.wireframe===!0||y.depthTest===!1)&&(v.visible=!1),y.clippingPlanes&&(v.clipping=!0,v.clippingPlanes=y.clippingPlanes,v.clipIntersection=y.clipIntersection,v.clipShadows=y.clipShadows),v.version=y.version}function _(){let v;v=Object.keys(u);for(let y=0,b=v.length;y<b;y++)u[v[y]]=void 0;v=Object.keys(c);for(let y=0,b=v.length;y<b;y++)c[v[y]]=void 0;v=Object.keys(o);for(let y=0,b=v.length;y<b;y++){const P=v[y];o[P].used===!1?(o[P].count++,o[P].keepAlive===!1&&o[P].count>l&&delete o[P]):(o[P].used=!1,o[P].count=0)}}this.render=function(v,y){if(this.enabled===!1){t.render(v,y);return}const b=t.autoClear;t.autoClear=this.autoClear,t.render(v,y),t.autoClear=b,this.renderOutline(v,y)},this.renderOutline=function(v,y){const b=t.autoClear,P=v.matrixWorldAutoUpdate,E=v.background,R=t.shadowMap.enabled;v.matrixWorldAutoUpdate=!1,v.background=null,t.autoClear=!1,t.shadowMap.enabled=!1,v.traverse(m),t.render(v,y),v.traverse(h),_(),v.matrixWorldAutoUpdate=P,v.background=E,t.autoClear=b,t.shadowMap.enabled=R},this.autoClear=t.autoClear,this.domElement=t.domElement,this.shadowMap=t.shadowMap,this.clear=function(v,y,b){t.clear(v,y,b)},this.getPixelRatio=function(){return t.getPixelRatio()},this.setPixelRatio=function(v){t.setPixelRatio(v)},this.getSize=function(v){return t.getSize(v)},this.setSize=function(v,y,b){t.setSize(v,y,b)},this.setViewport=function(v,y,b,P){t.setViewport(v,y,b,P)},this.setScissor=function(v,y,b,P){t.setScissor(v,y,b,P)},this.setScissorTest=function(v){t.setScissorTest(v)},this.setRenderTarget=function(v){t.setRenderTarget(v)}}};const Li=C.createContext(null);function $s({children:e,enabled:t=!0}){const[n,i]=C.useState([]),s=C.useMemo(()=>({selected:n,select:i,enabled:t}),[n,i,t]);return z(Li.Provider,{value:s,children:e})}/**
 * postprocessing v6.35.3 build Sat Mar 30 2024
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2024 Raoul van Rüschen
 * @license Zlib
 */var tn=1/1e3,Ws=1e3,Xs=class{constructor(){this.startTime=performance.now(),this.previousTime=0,this.currentTime=0,this._delta=0,this._elapsed=0,this._fixedDelta=1e3/60,this.timescale=1,this.useFixedDelta=!1,this._autoReset=!1}get autoReset(){return this._autoReset}set autoReset(e){typeof document<"u"&&document.hidden!==void 0&&(e?document.addEventListener("visibilitychange",this):document.removeEventListener("visibilitychange",this),this._autoReset=e)}get delta(){return this._delta*tn}get fixedDelta(){return this._fixedDelta*tn}set fixedDelta(e){this._fixedDelta=e*Ws}get elapsed(){return this._elapsed*tn}update(e){this.useFixedDelta?this._delta=this.fixedDelta:(this.previousTime=this.currentTime,this.currentTime=(e!==void 0?e:performance.now())-this.startTime,this._delta=this.currentTime-this.previousTime),this._delta*=this.timescale,this._elapsed+=this._delta}reset(){this._delta=0,this._elapsed=0,this.currentTime=performance.now()-this.startTime}getDelta(){return this.delta}getElapsed(){return this.elapsed}handleEvent(e){document.hidden||(this.currentTime=performance.now()-this.startTime)}dispose(){this.autoReset=!1}},qs=new Pi,Ae=null;function Ys(){if(Ae===null){const e=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),t=new Float32Array([0,0,2,0,0,2]);Ae=new Gt,Ae.setAttribute!==void 0?(Ae.setAttribute("position",new me(e,3)),Ae.setAttribute("uv",new me(t,2))):(Ae.addAttribute("position",new me(e,3)),Ae.addAttribute("uv",new me(t,2)))}return Ae}var ne=class Ui{constructor(t="Pass",n=new Ht,i=qs){this.name=t,this.renderer=null,this.scene=n,this.camera=i,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}get renderToScreen(){return!this.rtt}set renderToScreen(t){if(this.rtt===t){const n=this.fullscreenMaterial;n!==null&&(n.needsUpdate=!0),this.rtt=!t}}set mainScene(t){}set mainCamera(t){}setRenderer(t){this.renderer=t}isEnabled(){return this.enabled}setEnabled(t){this.enabled=t}get fullscreenMaterial(){return this.screen!==null?this.screen.material:null}set fullscreenMaterial(t){let n=this.screen;n!==null?n.material=t:(n=new Yt(Ys(),t),n.frustumCulled=!1,this.scene===null&&(this.scene=new Ht),this.scene.add(n),this.screen=n)}getFullscreenMaterial(){return this.fullscreenMaterial}setFullscreenMaterial(t){this.fullscreenMaterial=t}getDepthTexture(){return null}setDepthTexture(t,n=Re){}render(t,n,i,s,a){throw new Error("Render method not implemented!")}setSize(t,n){}initialize(t,n,i){}dispose(){for(const t of Object.keys(this)){const n=this[t];(n instanceof ce||n instanceof Kt||n instanceof Zt||n instanceof Ui)&&this[t].dispose()}}},Ks=class extends ne{constructor(){super("ClearMaskPass",null,null),this.needsSwap=!1}render(e,t,n,i,s){const a=e.state.buffers.stencil;a.setLocked(!1),a.setTest(!1)}},Zs=Number(Mi.replace(/\D+/g,""));function In(e){return Zs<154?e.replace("colorspace_fragment","encodings_fragment"):e}var Qs=`#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <colorspace_fragment>
#include <dithering_fragment>
}`,Js="varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",Ii=class extends ve{constructor(){super({name:"CopyMaterial",uniforms:{inputBuffer:new H(null),opacity:new H(1)},blending:Je,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Qs,vertexShader:Js}),this.fragmentShader=In(this.fragmentShader)}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}getOpacity(e){return this.uniforms.opacity.value}setOpacity(e){this.uniforms.opacity.value=e}},er=class extends ne{constructor(e,t=!0){super("CopyPass"),this.fullscreenMaterial=new Ii,this.needsSwap=!1,this.renderTarget=e,e===void 0&&(this.renderTarget=new ce(1,1,{minFilter:Vt,magFilter:Vt,stencilBuffer:!1,depthBuffer:!1}),this.renderTarget.texture.name="CopyPass.Target"),this.autoResize=t}get resize(){return this.autoResize}set resize(e){this.autoResize=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}setAutoResizeEnabled(e){this.autoResize=e}render(e,t,n,i,s){this.fullscreenMaterial.inputBuffer=t.texture,e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){this.autoResize&&this.renderTarget.setSize(e,t)}initialize(e,t,n){n!==void 0&&(this.renderTarget.texture.type=n,n!==Ue?this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1":e!==null&&e.outputColorSpace===se&&(this.renderTarget.texture.colorSpace=se))}},Jn=new pe,On=class extends ne{constructor(e=!0,t=!0,n=!1){super("ClearPass",null,null),this.needsSwap=!1,this.color=e,this.depth=t,this.stencil=n,this.overrideClearColor=null,this.overrideClearAlpha=-1}setClearFlags(e,t,n){this.color=e,this.depth=t,this.stencil=n}getOverrideClearColor(){return this.overrideClearColor}setOverrideClearColor(e){this.overrideClearColor=e}getOverrideClearAlpha(){return this.overrideClearAlpha}setOverrideClearAlpha(e){this.overrideClearAlpha=e}render(e,t,n,i,s){const a=this.overrideClearColor,r=this.overrideClearAlpha,o=e.getClearAlpha(),l=a!==null,u=r>=0;l?(e.getClearColor(Jn),e.setClearColor(a,u?r:o)):u&&e.setClearAlpha(r),e.setRenderTarget(this.renderToScreen?null:t),e.clear(this.color,this.depth,this.stencil),l?e.setClearColor(Jn,o):u&&e.setClearAlpha(o)}},tr=class extends ne{constructor(e,t){super("MaskPass",e,t),this.needsSwap=!1,this.clearPass=new On(!1,!1,!0),this.inverse=!1}set mainScene(e){this.scene=e}set mainCamera(e){this.camera=e}get inverted(){return this.inverse}set inverted(e){this.inverse=e}get clear(){return this.clearPass.enabled}set clear(e){this.clearPass.enabled=e}getClearPass(){return this.clearPass}isInverted(){return this.inverted}setInverted(e){this.inverted=e}render(e,t,n,i,s){const a=e.getContext(),r=e.state.buffers,o=this.scene,l=this.camera,u=this.clearPass,c=this.inverted?0:1,d=1-c;r.color.setMask(!1),r.depth.setMask(!1),r.color.setLocked(!0),r.depth.setLocked(!0),r.stencil.setTest(!0),r.stencil.setOp(a.REPLACE,a.REPLACE,a.REPLACE),r.stencil.setFunc(a.ALWAYS,c,4294967295),r.stencil.setClear(d),r.stencil.setLocked(!0),this.clearPass.enabled&&(this.renderToScreen?u.render(e,null):(u.render(e,t),u.render(e,n))),this.renderToScreen?(e.setRenderTarget(null),e.render(o,l)):(e.setRenderTarget(t),e.render(o,l),e.setRenderTarget(n),e.render(o,l)),r.color.setLocked(!1),r.depth.setLocked(!1),r.stencil.setLocked(!1),r.stencil.setFunc(a.EQUAL,1,4294967295),r.stencil.setOp(a.KEEP,a.KEEP,a.KEEP),r.stencil.setLocked(!0)}},nr=class{constructor(t=null,{depthBuffer:n=!0,stencilBuffer:i=!1,multisampling:s=0,frameBufferType:a}={}){this.renderer=null,this.inputBuffer=this.createBuffer(n,i,a,s),this.outputBuffer=this.inputBuffer.clone(),this.copyPass=new er,this.depthTexture=null,this.passes=[],this.timer=new Xs,this.autoRenderToScreen=!0,this.setRenderer(t)}get multisampling(){return this.inputBuffer.samples||0}set multisampling(t){const n=this.inputBuffer,i=this.multisampling;i>0&&t>0?(this.inputBuffer.samples=t,this.outputBuffer.samples=t,this.inputBuffer.dispose(),this.outputBuffer.dispose()):i!==t&&(this.inputBuffer.dispose(),this.outputBuffer.dispose(),this.inputBuffer=this.createBuffer(n.depthBuffer,n.stencilBuffer,n.texture.type,t),this.inputBuffer.depthTexture=this.depthTexture,this.outputBuffer=this.inputBuffer.clone())}getTimer(){return this.timer}getRenderer(){return this.renderer}setRenderer(t){if(this.renderer=t,t!==null){const n=t.getSize(new q),i=t.getContext().getContextAttributes().alpha,s=this.inputBuffer.texture.type;s===Ue&&t.outputColorSpace===se&&(this.inputBuffer.texture.colorSpace=se,this.outputBuffer.texture.colorSpace=se,this.inputBuffer.dispose(),this.outputBuffer.dispose()),t.autoClear=!1,this.setSize(n.width,n.height);for(const a of this.passes)a.initialize(t,i,s)}}replaceRenderer(t,n=!0){const i=this.renderer,s=i.domElement.parentNode;return this.setRenderer(t),n&&s!==null&&(s.removeChild(i.domElement),s.appendChild(t.domElement)),i}createDepthTexture(){const t=this.depthTexture=new hs;return this.inputBuffer.depthTexture=t,this.inputBuffer.dispose(),this.inputBuffer.stencilBuffer?(t.format=ps,t.type=ms):t.type=vs,t}deleteDepthTexture(){if(this.depthTexture!==null){this.depthTexture.dispose(),this.depthTexture=null,this.inputBuffer.depthTexture=null,this.inputBuffer.dispose();for(const t of this.passes)t.setDepthTexture(null)}}createBuffer(t,n,i,s){const a=this.renderer,r=a===null?new q:a.getDrawingBufferSize(new q),o={minFilter:Vt,magFilter:Vt,stencilBuffer:n,depthBuffer:t,type:i},l=new ce(r.width,r.height,o);return s>0&&(l.ignoreDepthForMultisampleCopy=!1,l.samples=s),i===Ue&&a!==null&&a.outputColorSpace===se&&(l.texture.colorSpace=se),l.texture.name="EffectComposer.Buffer",l.texture.generateMipmaps=!1,l}setMainScene(t){for(const n of this.passes)n.mainScene=t}setMainCamera(t){for(const n of this.passes)n.mainCamera=t}addPass(t,n){const i=this.passes,s=this.renderer,a=s.getDrawingBufferSize(new q),r=s.getContext().getContextAttributes().alpha,o=this.inputBuffer.texture.type;if(t.setRenderer(s),t.setSize(a.width,a.height),t.initialize(s,r,o),this.autoRenderToScreen&&(i.length>0&&(i[i.length-1].renderToScreen=!1),t.renderToScreen&&(this.autoRenderToScreen=!1)),n!==void 0?i.splice(n,0,t):i.push(t),this.autoRenderToScreen&&(i[i.length-1].renderToScreen=!0),t.needsDepthTexture||this.depthTexture!==null)if(this.depthTexture===null){const l=this.createDepthTexture();for(t of i)t.setDepthTexture(l)}else t.setDepthTexture(this.depthTexture)}removePass(t){const n=this.passes,i=n.indexOf(t);if(i!==-1&&n.splice(i,1).length>0){if(this.depthTexture!==null){const r=(l,u)=>l||u.needsDepthTexture;n.reduce(r,!1)||(t.getDepthTexture()===this.depthTexture&&t.setDepthTexture(null),this.deleteDepthTexture())}this.autoRenderToScreen&&i===n.length&&(t.renderToScreen=!1,n.length>0&&(n[n.length-1].renderToScreen=!0))}}removeAllPasses(){const t=this.passes;this.deleteDepthTexture(),t.length>0&&(this.autoRenderToScreen&&(t[t.length-1].renderToScreen=!1),this.passes=[])}render(t){const n=this.renderer,i=this.copyPass;let s=this.inputBuffer,a=this.outputBuffer,r=!1,o,l,u;t===void 0&&(this.timer.update(),t=this.timer.getDelta());for(const c of this.passes)c.enabled&&(c.render(n,s,a,t,r),c.needsSwap&&(r&&(i.renderToScreen=c.renderToScreen,o=n.getContext(),l=n.state.buffers.stencil,l.setFunc(o.NOTEQUAL,1,4294967295),i.render(n,s,a,t,r),l.setFunc(o.EQUAL,1,4294967295)),u=s,s=a,a=u),c instanceof tr?r=!0:c instanceof Ks&&(r=!1))}setSize(t,n,i){const s=this.renderer,a=s.getSize(new q);(t===void 0||n===void 0)&&(t=a.width,n=a.height),(a.width!==t||a.height!==n)&&s.setSize(t,n,i);const r=s.getDrawingBufferSize(new q);this.inputBuffer.setSize(r.width,r.height),this.outputBuffer.setSize(r.width,r.height);for(const o of this.passes)o.setSize(r.width,r.height)}reset(){this.dispose(),this.autoRenderToScreen=!0}dispose(){for(const t of this.passes)t.dispose();this.passes=[],this.inputBuffer!==null&&this.inputBuffer.dispose(),this.outputBuffer!==null&&this.outputBuffer.dispose(),this.deleteDepthTexture(),this.copyPass.dispose(),this.timer.dispose()}},be={NONE:0,DEPTH:1,CONVOLUTION:2},F={FRAGMENT_HEAD:"FRAGMENT_HEAD",FRAGMENT_MAIN_UV:"FRAGMENT_MAIN_UV",FRAGMENT_MAIN_IMAGE:"FRAGMENT_MAIN_IMAGE",VERTEX_HEAD:"VERTEX_HEAD",VERTEX_MAIN_SUPPORT:"VERTEX_MAIN_SUPPORT"},ir=class{constructor(){this.shaderParts=new Map([[F.FRAGMENT_HEAD,null],[F.FRAGMENT_MAIN_UV,null],[F.FRAGMENT_MAIN_IMAGE,null],[F.VERTEX_HEAD,null],[F.VERTEX_MAIN_SUPPORT,null]]),this.defines=new Map,this.uniforms=new Map,this.blendModes=new Map,this.extensions=new Set,this.attributes=be.NONE,this.varyings=new Set,this.uvTransformation=!1,this.readDepth=!1,this.colorSpace=_i}},nn=!1,ei=class{constructor(e=null){this.originalMaterials=new Map,this.material=null,this.materials=null,this.materialsBackSide=null,this.materialsDoubleSide=null,this.materialsFlatShaded=null,this.materialsFlatShadedBackSide=null,this.materialsFlatShadedDoubleSide=null,this.setMaterial(e),this.meshCount=0,this.replaceMaterial=t=>{if(t.isMesh){let n;if(t.material.flatShading)switch(t.material.side){case ft:n=this.materialsFlatShadedDoubleSide;break;case Le:n=this.materialsFlatShadedBackSide;break;default:n=this.materialsFlatShaded;break}else switch(t.material.side){case ft:n=this.materialsDoubleSide;break;case Le:n=this.materialsBackSide;break;default:n=this.materials;break}this.originalMaterials.set(t,t.material),t.isSkinnedMesh?t.material=n[2]:t.isInstancedMesh?t.material=n[1]:t.material=n[0],++this.meshCount}}}cloneMaterial(e){if(!(e instanceof ve))return e.clone();const t=e.uniforms,n=new Map;for(const s in t){const a=t[s].value;a.isRenderTargetTexture&&(t[s].value=null,n.set(s,a))}const i=e.clone();for(const s of n)t[s[0]].value=s[1],i.uniforms[s[0]].value=s[1];return i}setMaterial(e){if(this.disposeMaterials(),this.material=e,e!==null){const t=this.materials=[this.cloneMaterial(e),this.cloneMaterial(e),this.cloneMaterial(e)];for(const n of t)n.uniforms=Object.assign({},e.uniforms),n.side=wn;t[2].skinning=!0,this.materialsBackSide=t.map(n=>{const i=this.cloneMaterial(n);return i.uniforms=Object.assign({},e.uniforms),i.side=Le,i}),this.materialsDoubleSide=t.map(n=>{const i=this.cloneMaterial(n);return i.uniforms=Object.assign({},e.uniforms),i.side=ft,i}),this.materialsFlatShaded=t.map(n=>{const i=this.cloneMaterial(n);return i.uniforms=Object.assign({},e.uniforms),i.flatShading=!0,i}),this.materialsFlatShadedBackSide=t.map(n=>{const i=this.cloneMaterial(n);return i.uniforms=Object.assign({},e.uniforms),i.flatShading=!0,i.side=Le,i}),this.materialsFlatShadedDoubleSide=t.map(n=>{const i=this.cloneMaterial(n);return i.uniforms=Object.assign({},e.uniforms),i.flatShading=!0,i.side=ft,i})}}render(e,t,n){const i=e.shadowMap.enabled;if(e.shadowMap.enabled=!1,nn){const s=this.originalMaterials;this.meshCount=0,t.traverse(this.replaceMaterial),e.render(t,n);for(const a of s)a[0].material=a[1];this.meshCount!==s.size&&s.clear()}else{const s=t.overrideMaterial;t.overrideMaterial=this.material,e.render(t,n),t.overrideMaterial=s}e.shadowMap.enabled=i}disposeMaterials(){if(this.material!==null){const e=this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);for(const t of e)t.dispose()}}dispose(){this.originalMaterials.clear(),this.disposeMaterials()}static get workaroundEnabled(){return nn}static set workaroundEnabled(e){nn=e}},_e=-1,Z=class extends yt{constructor(e,t=_e,n=_e,i=1){super(),this.resizable=e,this.baseSize=new q(1,1),this.preferredSize=new q(t,n),this.target=this.preferredSize,this.s=i,this.effectiveSize=new q,this.addEventListener("change",()=>this.updateEffectiveSize()),this.updateEffectiveSize()}updateEffectiveSize(){const e=this.baseSize,t=this.preferredSize,n=this.effectiveSize,i=this.scale;t.width!==_e?n.width=t.width:t.height!==_e?n.width=Math.round(t.height*(e.width/Math.max(e.height,1))):n.width=Math.round(e.width*i),t.height!==_e?n.height=t.height:t.width!==_e?n.height=Math.round(t.width/Math.max(e.width/Math.max(e.height,1),1)):n.height=Math.round(e.height*i)}get width(){return this.effectiveSize.width}set width(e){this.preferredWidth=e}get height(){return this.effectiveSize.height}set height(e){this.preferredHeight=e}getWidth(){return this.width}getHeight(){return this.height}get scale(){return this.s}set scale(e){this.s!==e&&(this.s=e,this.preferredSize.setScalar(_e),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getScale(){return this.scale}setScale(e){this.scale=e}get baseWidth(){return this.baseSize.width}set baseWidth(e){this.baseSize.width!==e&&(this.baseSize.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseWidth(){return this.baseWidth}setBaseWidth(e){this.baseWidth=e}get baseHeight(){return this.baseSize.height}set baseHeight(e){this.baseSize.height!==e&&(this.baseSize.height=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseHeight(){return this.baseHeight}setBaseHeight(e){this.baseHeight=e}setBaseSize(e,t){(this.baseSize.width!==e||this.baseSize.height!==t)&&(this.baseSize.set(e,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}get preferredWidth(){return this.preferredSize.width}set preferredWidth(e){this.preferredSize.width!==e&&(this.preferredSize.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredWidth(){return this.preferredWidth}setPreferredWidth(e){this.preferredWidth=e}get preferredHeight(){return this.preferredSize.height}set preferredHeight(e){this.preferredSize.height!==e&&(this.preferredSize.height=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredHeight(){return this.preferredHeight}setPreferredHeight(e){this.preferredHeight=e}setPreferredSize(e,t){(this.preferredSize.width!==e||this.preferredSize.height!==t)&&(this.preferredSize.set(e,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}copy(e){this.s=e.scale,this.baseSize.set(e.baseWidth,e.baseHeight),this.preferredSize.set(e.preferredWidth,e.preferredHeight),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height)}static get AUTO_SIZE(){return _e}},sr=class extends Set{constructor(e,t=10){super(),this.l=t,this.exclusive=!1,e!==void 0&&this.set(e)}get layer(){return this.l}set layer(e){const t=this.l;for(const n of this)n.layers.disable(t),n.layers.enable(e);this.l=e}getLayer(){return this.layer}setLayer(e){this.layer=e}isExclusive(){return this.exclusive}setExclusive(e){this.exclusive=e}clear(){const e=this.layer;for(const t of this)t.layers.disable(e);return super.clear()}set(e){this.clear();for(const t of e)this.add(t);return this}indexOf(e){return this.has(e)?0:-1}add(e){return this.exclusive?e.layers.set(this.layer):e.layers.enable(this.layer),super.add(e)}delete(e){return this.has(e)&&e.layers.disable(this.layer),super.delete(e)}toggle(e){let t;return this.has(e)?(this.delete(e),t=!1):(this.add(e),t=!0),t}setVisible(e){for(const t of this)e?t.layers.enable(0):t.layers.disable(0);return this}},O={SKIP:9,SET:30,ADD:0,ALPHA:1,AVERAGE:2,COLOR:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,DIVIDE:8,DST:9,EXCLUSION:10,HARD_LIGHT:11,HARD_MIX:12,HUE:13,INVERT:14,INVERT_RGB:15,LIGHTEN:16,LINEAR_BURN:17,LINEAR_DODGE:18,LINEAR_LIGHT:19,LUMINOSITY:20,MULTIPLY:21,NEGATION:22,NORMAL:23,OVERLAY:24,PIN_LIGHT:25,REFLECT:26,SATURATION:27,SCREEN:28,SOFT_LIGHT:29,SRC:30,SUBTRACT:31,VIVID_LIGHT:32},rr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}",ar="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}",or="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}",lr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",cr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}",ur="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}",fr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}",dr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}",hr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}",pr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}",mr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}",vr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}",gr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}",yr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}",xr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}",Sr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}",br="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}",wr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}",Tr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}",Ar="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",_r="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}",Er="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}",Cr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}",Mr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}",Pr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}",Br="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}",Rr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",zr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}",Nr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}",Dr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",Lr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}",Ur="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}",Ir=new Map([[O.ADD,rr],[O.ALPHA,ar],[O.AVERAGE,or],[O.COLOR,lr],[O.COLOR_BURN,cr],[O.COLOR_DODGE,ur],[O.DARKEN,fr],[O.DIFFERENCE,dr],[O.DIVIDE,hr],[O.DST,null],[O.EXCLUSION,pr],[O.HARD_LIGHT,mr],[O.HARD_MIX,vr],[O.HUE,gr],[O.INVERT,yr],[O.INVERT_RGB,xr],[O.LIGHTEN,Sr],[O.LINEAR_BURN,br],[O.LINEAR_DODGE,wr],[O.LINEAR_LIGHT,Tr],[O.LUMINOSITY,Ar],[O.MULTIPLY,_r],[O.NEGATION,Er],[O.NORMAL,Cr],[O.OVERLAY,Mr],[O.PIN_LIGHT,Pr],[O.REFLECT,Br],[O.SATURATION,Rr],[O.SCREEN,zr],[O.SOFT_LIGHT,Nr],[O.SRC,Dr],[O.SUBTRACT,Lr],[O.VIVID_LIGHT,Ur]]),Or=class extends yt{constructor(t,n=1){super(),this._blendFunction=t,this.opacity=new H(n)}getOpacity(){return this.opacity.value}setOpacity(t){this.opacity.value=t}get blendFunction(){return this._blendFunction}set blendFunction(t){this._blendFunction=t,this.dispatchEvent({type:"change"})}getBlendFunction(){return this.blendFunction}setBlendFunction(t){this.blendFunction=t}getShaderCode(){return Ir.get(this.blendFunction)}},kn={VERY_SMALL:0,SMALL:1,MEDIUM:2,LARGE:3,VERY_LARGE:4,HUGE:5},kr=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <colorspace_fragment>
}`,Fr="uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",Hr=[new Float32Array([0,0]),new Float32Array([0,1,1]),new Float32Array([0,1,1,2]),new Float32Array([0,1,2,2,3]),new Float32Array([0,1,2,3,4,4,5]),new Float32Array([0,1,2,3,4,5,7,8,9,10])],Vr=class extends ve{constructor(e=new Kn){super({name:"KawaseBlurMaterial",uniforms:{inputBuffer:new H(null),texelSize:new H(new Kn),scale:new H(1),kernel:new H(0)},blending:Je,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:kr,vertexShader:Fr}),this.fragmentShader=In(this.fragmentShader),this.setTexelSize(e.x,e.y),this.kernelSize=kn.MEDIUM}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.inputBuffer=e}get kernelSequence(){return Hr[this.kernelSize]}get scale(){return this.uniforms.scale.value}set scale(e){this.uniforms.scale.value=e}getScale(){return this.uniforms.scale.value}setScale(e){this.uniforms.scale.value=e}getKernel(){return null}get kernel(){return this.uniforms.kernel.value}set kernel(e){this.uniforms.kernel.value=e}setKernel(e){this.kernel=e}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t,e*.5,t*.5)}setSize(e,t){const n=1/e,i=1/t;this.uniforms.texelSize.value.set(n,i,n*.5,i*.5)}},Gr=class extends ne{constructor({kernelSize:e=kn.MEDIUM,resolutionScale:t=.5,width:n=Z.AUTO_SIZE,height:i=Z.AUTO_SIZE,resolutionX:s=n,resolutionY:a=i}={}){super("KawaseBlurPass"),this.renderTargetA=new ce(1,1,{depthBuffer:!1}),this.renderTargetA.texture.name="Blur.Target.A",this.renderTargetB=this.renderTargetA.clone(),this.renderTargetB.texture.name="Blur.Target.B";const r=this.resolution=new Z(this,s,a,t);r.addEventListener("change",o=>this.setSize(r.baseWidth,r.baseHeight)),this._blurMaterial=new Vr,this._blurMaterial.kernelSize=e,this.copyMaterial=new Ii}getResolution(){return this.resolution}get blurMaterial(){return this._blurMaterial}set blurMaterial(e){this._blurMaterial=e}get dithering(){return this.copyMaterial.dithering}set dithering(e){this.copyMaterial.dithering=e}get kernelSize(){return this.blurMaterial.kernelSize}set kernelSize(e){this.blurMaterial.kernelSize=e}get width(){return this.resolution.width}set width(e){this.resolution.preferredWidth=e}get height(){return this.resolution.height}set height(e){this.resolution.preferredHeight=e}get scale(){return this.blurMaterial.scale}set scale(e){this.blurMaterial.scale=e}getScale(){return this.blurMaterial.scale}setScale(e){this.blurMaterial.scale=e}getKernelSize(){return this.kernelSize}setKernelSize(e){this.kernelSize=e}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}render(e,t,n,i,s){const a=this.scene,r=this.camera,o=this.renderTargetA,l=this.renderTargetB,u=this.blurMaterial,c=u.kernelSequence;let d=t;this.fullscreenMaterial=u;for(let f=0,p=c.length;f<p;++f){const x=f&1?l:o;u.kernel=c[f],u.inputBuffer=d.texture,e.setRenderTarget(x),e.render(a,r),d=x}this.fullscreenMaterial=this.copyMaterial,this.copyMaterial.inputBuffer=d.texture,e.setRenderTarget(this.renderToScreen?null:n),e.render(a,r)}setSize(e,t){const n=this.resolution;n.setBaseSize(e,t);const i=n.width,s=n.height;this.renderTargetA.setSize(i,s),this.renderTargetB.setSize(i,s),this.blurMaterial.setSize(e,t)}initialize(e,t,n){n!==void 0&&(this.renderTargetA.texture.type=n,this.renderTargetB.texture.type=n,n!==Ue?(this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1"):e!==null&&e.outputColorSpace===se&&(this.renderTargetA.texture.colorSpace=se,this.renderTargetB.texture.colorSpace=se))}static get AUTO_SIZE(){return Z.AUTO_SIZE}},An=class extends yt{constructor(t,n,{attributes:i=be.NONE,blendFunction:s=O.NORMAL,defines:a=new Map,uniforms:r=new Map,extensions:o=null,vertexShader:l=null}={}){super(),this.name=t,this.renderer=null,this.attributes=i,this.fragmentShader=n,this.vertexShader=l,this.defines=a,this.uniforms=r,this.extensions=o,this.blendMode=new Or(s),this.blendMode.addEventListener("change",u=>this.setChanged()),this._inputColorSpace=_i,this._outputColorSpace=Ei}get inputColorSpace(){return this._inputColorSpace}set inputColorSpace(t){this._inputColorSpace=t,this.setChanged()}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(t){this._outputColorSpace=t,this.setChanged()}set mainScene(t){}set mainCamera(t){}getName(){return this.name}setRenderer(t){this.renderer=t}getDefines(){return this.defines}getUniforms(){return this.uniforms}getExtensions(){return this.extensions}getBlendMode(){return this.blendMode}getAttributes(){return this.attributes}setAttributes(t){this.attributes=t,this.setChanged()}getFragmentShader(){return this.fragmentShader}setFragmentShader(t){this.fragmentShader=t,this.setChanged()}getVertexShader(){return this.vertexShader}setVertexShader(t){this.vertexShader=t,this.setChanged()}setChanged(){this.dispatchEvent({type:"change"})}setDepthTexture(t,n=Re){}update(t,n,i){}setSize(t,n){}initialize(t,n,i){}dispose(){for(const t of Object.keys(this)){const n=this[t];(n instanceof ce||n instanceof Kt||n instanceof Zt||n instanceof ne)&&this[t].dispose()}}},jr=class extends ne{constructor(e,t="inputBuffer"){super("ShaderPass"),this.fullscreenMaterial=e,this.input=t}setInput(e){this.input=e}render(e,t,n,i,s){const a=this.fullscreenMaterial.uniforms;t!==null&&a!==void 0&&a[this.input]!==void 0&&(a[this.input].value=t.texture),e.setRenderTarget(this.renderToScreen?null:n),e.render(this.scene,this.camera)}initialize(e,t,n){n!==void 0&&n!==Ue&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},Qt=class extends ne{constructor(e,t,n=null){super("RenderPass",e,t),this.needsSwap=!1,this.clearPass=new On,this.overrideMaterialManager=n===null?null:new ei(n),this.ignoreBackground=!1,this.skipShadowMapUpdate=!1,this.selection=null}set mainScene(e){this.scene=e}set mainCamera(e){this.camera=e}get renderToScreen(){return super.renderToScreen}set renderToScreen(e){super.renderToScreen=e,this.clearPass.renderToScreen=e}get overrideMaterial(){const e=this.overrideMaterialManager;return e!==null?e.material:null}set overrideMaterial(e){const t=this.overrideMaterialManager;e!==null?t!==null?t.setMaterial(e):this.overrideMaterialManager=new ei(e):t!==null&&(t.dispose(),this.overrideMaterialManager=null)}getOverrideMaterial(){return this.overrideMaterial}setOverrideMaterial(e){this.overrideMaterial=e}get clear(){return this.clearPass.enabled}set clear(e){this.clearPass.enabled=e}getSelection(){return this.selection}setSelection(e){this.selection=e}isBackgroundDisabled(){return this.ignoreBackground}setBackgroundDisabled(e){this.ignoreBackground=e}isShadowMapDisabled(){return this.skipShadowMapUpdate}setShadowMapDisabled(e){this.skipShadowMapUpdate=e}getClearPass(){return this.clearPass}render(e,t,n,i,s){const a=this.scene,r=this.camera,o=this.selection,l=r.layers.mask,u=a.background,c=e.shadowMap.autoUpdate,d=this.renderToScreen?null:t;o!==null&&r.layers.set(o.getLayer()),this.skipShadowMapUpdate&&(e.shadowMap.autoUpdate=!1),(this.ignoreBackground||this.clearPass.overrideClearColor!==null)&&(a.background=null),this.clearPass.enabled&&this.clearPass.render(e,t),e.setRenderTarget(d),this.overrideMaterialManager!==null?this.overrideMaterialManager.render(e,a,r):e.render(a,r),r.layers.mask=l,a.background=u,e.shadowMap.autoUpdate=c}},$r=`#include <packing>
#include <clipping_planes_pars_fragment>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float cameraNear;uniform float cameraFar;centroid varying float vViewZ;centroid varying vec4 vProjTexCoord;void main(){
#include <clipping_planes_fragment>
vec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);
#if DEPTH_PACKING == 3201
float fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));
#else
float fragCoordZ=texture2D(depthBuffer,projTexCoord).r;
#endif
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);
#else
float viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);
#endif
float depthTest=(-vViewZ>-viewZ)?1.0:0.0;gl_FragColor.rg=vec2(0.0,depthTest);}`,Wr=`#include <common>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
varying float vViewZ;varying vec4 vProjTexCoord;void main(){
#include <skinbase_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <project_vertex>
vViewZ=mvPosition.z;vProjTexCoord=gl_Position;
#include <clipping_planes_vertex>
}`,Xr=class extends ve{constructor(e=null,t){super({name:"DepthComparisonMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new H(null),cameraNear:new H(.3),cameraFar:new H(1e3)},blending:Je,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:$r,vertexShader:Wr}),this.depthBuffer=e,this.depthPacking=Tn,this.copyCameraSettings(t)}set depthBuffer(e){this.uniforms.depthBuffer.value=e}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=Tn){this.depthBuffer=e,this.depthPacking=t}adoptCameraSettings(e){this.copyCameraSettings(e)}copyCameraSettings(e){e&&(this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far,e instanceof Ci?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}},qr="uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)?vec2(d,0.0):vec2(0.0,d);}",Yr="uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}",Kr=class extends ve{constructor(e=new q){super({name:"OutlineMaterial",uniforms:{inputBuffer:new H(null),texelSize:new H(new q)},blending:Je,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:qr,vertexShader:Yr}),this.uniforms.texelSize.value.set(e.x,e.y),this.uniforms.maskTexture=this.uniforms.inputBuffer}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t)}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}},Zr=class extends ne{constructor(e,t,{renderTarget:n,resolutionScale:i=1,width:s=Z.AUTO_SIZE,height:a=Z.AUTO_SIZE,resolutionX:r=s,resolutionY:o=a}={}){super("DepthPass"),this.needsSwap=!1,this.renderPass=new Qt(e,t,new Ss({depthPacking:Tn}));const l=this.renderPass;l.skipShadowMapUpdate=!0,l.ignoreBackground=!0;const u=l.clearPass;u.overrideClearColor=new pe(16777215),u.overrideClearAlpha=1,this.renderTarget=n,this.renderTarget===void 0&&(this.renderTarget=new ce(1,1,{minFilter:Qe,magFilter:Qe}),this.renderTarget.texture.name="DepthPass.Target");const c=this.resolution=new Z(this,r,o,i);c.addEventListener("change",d=>this.setSize(c.baseWidth,c.baseHeight))}set mainScene(e){this.renderPass.mainScene=e}set mainCamera(e){this.renderPass.mainCamera=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}render(e,t,n,i,s){const a=this.renderToScreen?null:this.renderTarget;this.renderPass.render(e,a)}setSize(e,t){const n=this.resolution;n.setBaseSize(e,t),this.renderTarget.setSize(n.width,n.height)}},Qr=`uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;
#ifdef USE_PATTERN
uniform lowp sampler2D patternTexture;varying vec2 vUvPattern;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;
#ifndef X_RAY
edge.y=0.0;
#endif
edge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;
#ifdef USE_PATTERN
vec4 patternColor=texture2D(patternTexture,vUvPattern);
#ifdef X_RAY
float hiddenFactor=0.5;
#else
float hiddenFactor=0.0;
#endif
visibilityFactor=(1.0-mask.y>0.0)?1.0:hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;
#endif
float alpha=max(max(edge.x,edge.y),visibilityFactor);
#ifdef ALPHA
outputColor=vec4(color,alpha);
#else
outputColor=vec4(color,max(alpha,inputColor.a));
#endif
}`,Jr="uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}",ea=class extends An{constructor(e,t,{blendFunction:n=O.SCREEN,patternTexture:i=null,patternScale:s=1,edgeStrength:a=1,pulseSpeed:r=0,visibleEdgeColor:o=16777215,hiddenEdgeColor:l=2230538,kernelSize:u=kn.VERY_SMALL,blur:c=!1,xRay:d=!0,multisampling:f=0,resolutionScale:p=.5,width:x=Z.AUTO_SIZE,height:w=Z.AUTO_SIZE,resolutionX:S=x,resolutionY:g=w}={}){super("OutlineEffect",Qr,{uniforms:new Map([["maskTexture",new H(null)],["edgeTexture",new H(null)],["edgeStrength",new H(a)],["visibleEdgeColor",new H(new pe(o))],["hiddenEdgeColor",new H(new pe(l))],["pulse",new H(1)],["patternScale",new H(s)],["patternTexture",new H(null)]])}),this.blendMode.addEventListener("change",T=>{this.blendMode.blendFunction===O.ALPHA?this.defines.set("ALPHA","1"):this.defines.delete("ALPHA"),this.setChanged()}),this.blendMode.blendFunction=n,this.patternTexture=i,this.xRay=d,this.scene=e,this.camera=t,this.renderTargetMask=new ce(1,1),this.renderTargetMask.samples=f,this.renderTargetMask.texture.name="Outline.Mask",this.uniforms.get("maskTexture").value=this.renderTargetMask.texture,this.renderTargetOutline=new ce(1,1,{depthBuffer:!1}),this.renderTargetOutline.texture.name="Outline.Edges",this.uniforms.get("edgeTexture").value=this.renderTargetOutline.texture,this.clearPass=new On,this.clearPass.overrideClearColor=new pe(0),this.clearPass.overrideClearAlpha=1,this.depthPass=new Zr(e,t),this.maskPass=new Qt(e,t,new Xr(this.depthPass.texture,t));const m=this.maskPass.clearPass;m.overrideClearColor=new pe(16777215),m.overrideClearAlpha=1,this.blurPass=new Gr({resolutionScale:p,resolutionX:S,resolutionY:g,kernelSize:u}),this.blurPass.enabled=c;const h=this.blurPass.resolution;h.addEventListener("change",T=>this.setSize(h.baseWidth,h.baseHeight)),this.outlinePass=new jr(new Kr);const A=this.outlinePass.fullscreenMaterial;A.inputBuffer=this.renderTargetMask.texture,this.time=0,this.forceUpdate=!0,this.selection=new sr,this.selection.layer=10,this.pulseSpeed=r}set mainScene(e){this.scene=e,this.depthPass.mainScene=e,this.maskPass.mainScene=e}set mainCamera(e){this.camera=e,this.depthPass.mainCamera=e,this.maskPass.mainCamera=e,this.maskPass.overrideMaterial.copyCameraSettings(e)}get resolution(){return this.blurPass.resolution}getResolution(){return this.blurPass.getResolution()}get multisampling(){return this.renderTargetMask.samples}set multisampling(e){this.renderTargetMask.samples=e,this.renderTargetMask.dispose()}get patternScale(){return this.uniforms.get("patternScale").value}set patternScale(e){this.uniforms.get("patternScale").value=e}get edgeStrength(){return this.uniforms.get("edgeStrength").value}set edgeStrength(e){this.uniforms.get("edgeStrength").value=e}get visibleEdgeColor(){return this.uniforms.get("visibleEdgeColor").value}set visibleEdgeColor(e){this.uniforms.get("visibleEdgeColor").value=e}get hiddenEdgeColor(){return this.uniforms.get("hiddenEdgeColor").value}set hiddenEdgeColor(e){this.uniforms.get("hiddenEdgeColor").value=e}getBlurPass(){return this.blurPass}getSelection(){return this.selection}getPulseSpeed(){return this.pulseSpeed}setPulseSpeed(e){this.pulseSpeed=e}get width(){return this.resolution.width}set width(e){this.resolution.preferredWidth=e}get height(){return this.resolution.height}set height(e){this.resolution.preferredHeight=e}get selectionLayer(){return this.selection.layer}set selectionLayer(e){this.selection.layer=e}get dithering(){return this.blurPass.dithering}set dithering(e){this.blurPass.dithering=e}get kernelSize(){return this.blurPass.kernelSize}set kernelSize(e){this.blurPass.kernelSize=e}get blur(){return this.blurPass.enabled}set blur(e){this.blurPass.enabled=e}get xRay(){return this.defines.has("X_RAY")}set xRay(e){this.xRay!==e&&(e?this.defines.set("X_RAY","1"):this.defines.delete("X_RAY"),this.setChanged())}isXRayEnabled(){return this.xRay}setXRayEnabled(e){this.xRay=e}get patternTexture(){return this.uniforms.get("patternTexture").value}set patternTexture(e){e!==null?(e.wrapS=e.wrapT=gs,this.defines.set("USE_PATTERN","1"),this.setVertexShader(Jr)):(this.defines.delete("USE_PATTERN"),this.setVertexShader(null)),this.uniforms.get("patternTexture").value=e,this.setChanged()}setPatternTexture(e){this.patternTexture=e}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}setSelection(e){return this.selection.set(e),this}clearSelection(){return this.selection.clear(),this}selectObject(e){return this.selection.add(e),this}deselectObject(e){return this.selection.delete(e),this}update(e,t,n){const i=this.scene,s=this.camera,a=this.selection,o=this.uniforms.get("pulse"),l=i.background,u=s.layers.mask;(this.forceUpdate||a.size>0)&&(i.background=null,o.value=1,this.pulseSpeed>0&&(o.value=Math.cos(this.time*this.pulseSpeed*10)*.375+.625),this.time+=n,a.setVisible(!1),this.depthPass.render(e),a.setVisible(!0),s.layers.set(a.layer),this.maskPass.render(e,this.renderTargetMask),s.layers.mask=u,i.background=l,this.outlinePass.render(e,null,this.renderTargetOutline),this.blurPass.enabled&&this.blurPass.render(e,this.renderTargetOutline,this.renderTargetOutline)),this.forceUpdate=a.size>0}setSize(e,t){this.blurPass.setSize(e,t),this.renderTargetMask.setSize(e,t);const n=this.resolution;n.setBaseSize(e,t);const i=n.width,s=n.height;this.depthPass.setSize(i,s),this.renderTargetOutline.setSize(i,s),this.outlinePass.fullscreenMaterial.setSize(i,s)}initialize(e,t,n){this.blurPass.initialize(e,t,Ue),n!==void 0&&(this.depthPass.initialize(e,t,n),this.maskPass.initialize(e,t,n),this.outlinePass.initialize(e,t,n))}},ta=`#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;
#else
vec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);
#endif
gl_FragColor=vec4(n[index],d[index]);}`,na="uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}",ia=class extends ve{constructor(){super({name:"DepthDownsamplingMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new H(null),normalBuffer:new H(null),texelSize:new H(new q)},blending:Je,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:ta,vertexShader:na})}set depthBuffer(e){this.uniforms.depthBuffer.value=e}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=Re){this.depthBuffer=e,this.depthPacking=t}set normalBuffer(e){this.uniforms.normalBuffer.value=e,e!==null?this.defines.DOWNSAMPLE_NORMALS="1":delete this.defines.DOWNSAMPLE_NORMALS,this.needsUpdate=!0}setNormalBuffer(e){this.normalBuffer=e}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t)}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}},sa=class extends ne{constructor({normalBuffer:e=null,resolutionScale:t=.5,width:n=Z.AUTO_SIZE,height:i=Z.AUTO_SIZE,resolutionX:s=n,resolutionY:a=i}={}){super("DepthDownsamplingPass");const r=new ia;r.normalBuffer=e,this.fullscreenMaterial=r,this.needsDepthTexture=!0,this.needsSwap=!1,this.renderTarget=new ce(1,1,{minFilter:Qe,magFilter:Qe,depthBuffer:!1,type:ys}),this.renderTarget.texture.name="DepthDownsamplingPass.Target",this.renderTarget.texture.generateMipmaps=!1;const o=this.resolution=new Z(this,s,a,t);o.addEventListener("change",l=>this.setSize(o.baseWidth,o.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}setDepthTexture(e,t=Re){this.fullscreenMaterial.depthBuffer=e,this.fullscreenMaterial.depthPacking=t}render(e,t,n,i,s){e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){const n=this.resolution;n.setBaseSize(e,t),this.renderTarget.setSize(n.width,n.height),this.fullscreenMaterial.setSize(e,t)}initialize(e,t,n){const i=e.getContext();if(!(i.getExtension("EXT_color_buffer_float")||i.getExtension("EXT_color_buffer_half_float")))throw new Error("Rendering to float texture is not supported.")}},ra=`#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`,aa="uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}",oa=class extends ve{constructor(e,t,n,i,s=!1){super({name:"EffectMaterial",defines:{THREE_REVISION:Mi.replace(/\D+/g,""),DEPTH_PACKING:"0",ENCODE_OUTPUT:"1"},uniforms:{inputBuffer:new H(null),depthBuffer:new H(null),resolution:new H(new q),texelSize:new H(new q),cameraNear:new H(.3),cameraFar:new H(1e3),aspect:new H(1),time:new H(0)},blending:Je,toneMapped:!1,depthWrite:!1,depthTest:!1,dithering:s}),e&&this.setShaderParts(e),t&&this.setDefines(t),n&&this.setUniforms(n),this.copyCameraSettings(i)}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(e){this.uniforms.depthBuffer.value=e}get depthPacking(){return Number(this.defines.DEPTH_PACKING)}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=Re){this.depthBuffer=e,this.depthPacking=t}setShaderData(e){this.setShaderParts(e.shaderParts),this.setDefines(e.defines),this.setUniforms(e.uniforms),this.setExtensions(e.extensions)}setShaderParts(e){return this.fragmentShader=ra.replace(F.FRAGMENT_HEAD,e.get(F.FRAGMENT_HEAD)||"").replace(F.FRAGMENT_MAIN_UV,e.get(F.FRAGMENT_MAIN_UV)||"").replace(F.FRAGMENT_MAIN_IMAGE,e.get(F.FRAGMENT_MAIN_IMAGE)||""),this.vertexShader=aa.replace(F.VERTEX_HEAD,e.get(F.VERTEX_HEAD)||"").replace(F.VERTEX_MAIN_SUPPORT,e.get(F.VERTEX_MAIN_SUPPORT)||""),this.fragmentShader=In(this.fragmentShader),this.needsUpdate=!0,this}setDefines(e){for(const t of e.entries())this.defines[t[0]]=t[1];return this.needsUpdate=!0,this}setUniforms(e){for(const t of e.entries())this.uniforms[t[0]]=t[1];return this}setExtensions(e){this.extensions={};for(const t of e)this.extensions[t]=!0;return this}get encodeOutput(){return this.defines.ENCODE_OUTPUT!==void 0}set encodeOutput(e){this.encodeOutput!==e&&(e?this.defines.ENCODE_OUTPUT="1":delete this.defines.ENCODE_OUTPUT,this.needsUpdate=!0)}isOutputEncodingEnabled(e){return this.encodeOutput}setOutputEncodingEnabled(e){this.encodeOutput=e}get time(){return this.uniforms.time.value}set time(e){this.uniforms.time.value=e}setDeltaTime(e){this.uniforms.time.value+=e}adoptCameraSettings(e){this.copyCameraSettings(e)}copyCameraSettings(e){e&&(this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far,e instanceof Ci?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}setSize(e,t){const n=this.uniforms;n.resolution.value.set(e,t),n.texelSize.value.set(1/e,1/t),n.aspect.value=e/t}static get Section(){return F}};function ti(e,t,n){for(const i of t){const s="$1"+e+i.charAt(0).toUpperCase()+i.slice(1),a=new RegExp("([^\\.])(\\b"+i+"\\b)","g");for(const r of n.entries())r[1]!==null&&n.set(r[0],r[1].replace(a,s))}}function la(e,t,n){let i=t.getFragmentShader(),s=t.getVertexShader();const a=i!==void 0&&/mainImage/.test(i),r=i!==void 0&&/mainUv/.test(i);if(n.attributes|=t.getAttributes(),i===void 0)throw new Error(`Missing fragment shader (${t.name})`);if(r&&n.attributes&be.CONVOLUTION)throw new Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`);if(!a&&!r)throw new Error(`Could not find mainImage or mainUv function (${t.name})`);{const o=/\w+\s+(\w+)\([\w\s,]*\)\s*{/g,l=n.shaderParts;let u=l.get(F.FRAGMENT_HEAD)||"",c=l.get(F.FRAGMENT_MAIN_UV)||"",d=l.get(F.FRAGMENT_MAIN_IMAGE)||"",f=l.get(F.VERTEX_HEAD)||"",p=l.get(F.VERTEX_MAIN_SUPPORT)||"";const x=new Set,w=new Set;if(r&&(c+=`	${e}MainUv(UV);
`,n.uvTransformation=!0),s!==null&&/mainSupport/.test(s)){const m=/mainSupport *\([\w\s]*?uv\s*?\)/.test(s);p+=`	${e}MainSupport(`,p+=m?`vUv);
`:`);
`;for(const h of s.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))for(const A of h[1].split(/\s*,\s*/))n.varyings.add(A),x.add(A),w.add(A);for(const h of s.matchAll(o))w.add(h[1])}for(const m of i.matchAll(o))w.add(m[1]);for(const m of t.defines.keys())w.add(m.replace(/\([\w\s,]*\)/g,""));for(const m of t.uniforms.keys())w.add(m);w.delete("while"),w.delete("for"),w.delete("if"),t.uniforms.forEach((m,h)=>n.uniforms.set(e+h.charAt(0).toUpperCase()+h.slice(1),m)),t.defines.forEach((m,h)=>n.defines.set(e+h.charAt(0).toUpperCase()+h.slice(1),m));const S=new Map([["fragment",i],["vertex",s]]);ti(e,w,n.defines),ti(e,w,S),i=S.get("fragment"),s=S.get("vertex");const g=t.blendMode;if(n.blendModes.set(g.blendFunction,g),a){t.inputColorSpace!==null&&t.inputColorSpace!==n.colorSpace&&(d+=t.inputColorSpace===se?`color0 = LinearTosRGB(color0);
	`:`color0 = sRGBToLinear(color0);
	`),t.outputColorSpace!==Ei?n.colorSpace=t.outputColorSpace:t.inputColorSpace!==null&&(n.colorSpace=t.inputColorSpace);const m=/MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;d+=`${e}MainImage(color0, UV, `,n.attributes&be.DEPTH&&m.test(i)&&(d+="depth, ",n.readDepth=!0),d+=`color1);
	`;const h=e+"BlendOpacity";n.uniforms.set(h,g.opacity),d+=`color0 = blend${g.blendFunction}(color0, color1, ${h});

	`,u+=`uniform float ${h};

`}if(u+=i+`
`,s!==null&&(f+=s+`
`),l.set(F.FRAGMENT_HEAD,u),l.set(F.FRAGMENT_MAIN_UV,c),l.set(F.FRAGMENT_MAIN_IMAGE,d),l.set(F.VERTEX_HEAD,f),l.set(F.VERTEX_MAIN_SUPPORT,p),t.extensions!==null)for(const m of t.extensions)n.extensions.add(m)}}var ca=class extends ne{constructor(e,...t){super("EffectPass"),this.fullscreenMaterial=new oa(null,null,null,e),this.listener=n=>this.handleEvent(n),this.effects=[],this.setEffects(t),this.skipRendering=!1,this.minTime=1,this.maxTime=Number.POSITIVE_INFINITY,this.timeScale=1}set mainScene(e){for(const t of this.effects)t.mainScene=e}set mainCamera(e){this.fullscreenMaterial.copyCameraSettings(e);for(const t of this.effects)t.mainCamera=e}get encodeOutput(){return this.fullscreenMaterial.encodeOutput}set encodeOutput(e){this.fullscreenMaterial.encodeOutput=e}get dithering(){return this.fullscreenMaterial.dithering}set dithering(e){const t=this.fullscreenMaterial;t.dithering=e,t.needsUpdate=!0}setEffects(e){for(const t of this.effects)t.removeEventListener("change",this.listener);this.effects=e.sort((t,n)=>n.attributes-t.attributes);for(const t of this.effects)t.addEventListener("change",this.listener)}updateMaterial(){const e=new ir;let t=0;for(const r of this.effects)if(r.blendMode.blendFunction===O.DST)e.attributes|=r.getAttributes()&be.DEPTH;else{if(e.attributes&r.getAttributes()&be.CONVOLUTION)throw new Error(`Convolution effects cannot be merged (${r.name})`);la("e"+t++,r,e)}let n=e.shaderParts.get(F.FRAGMENT_HEAD),i=e.shaderParts.get(F.FRAGMENT_MAIN_IMAGE),s=e.shaderParts.get(F.FRAGMENT_MAIN_UV);const a=/\bblend\b/g;for(const r of e.blendModes.values())n+=r.getShaderCode().replace(a,`blend${r.blendFunction}`)+`
`;e.attributes&be.DEPTH?(e.readDepth&&(i=`float depth = readDepth(UV);

	`+i),this.needsDepthTexture=this.getDepthTexture()===null):this.needsDepthTexture=!1,e.colorSpace===se&&(i+=`color0 = sRGBToLinear(color0);
	`),e.uvTransformation?(s=`vec2 transformedUv = vUv;
`+s,e.defines.set("UV","transformedUv")):e.defines.set("UV","vUv"),e.shaderParts.set(F.FRAGMENT_HEAD,n),e.shaderParts.set(F.FRAGMENT_MAIN_IMAGE,i),e.shaderParts.set(F.FRAGMENT_MAIN_UV,s);for(const[r,o]of e.shaderParts)o!==null&&e.shaderParts.set(r,o.trim().replace(/^#/,`
#`));this.skipRendering=t===0,this.needsSwap=!this.skipRendering,this.fullscreenMaterial.setShaderData(e)}recompile(){this.updateMaterial()}getDepthTexture(){return this.fullscreenMaterial.depthBuffer}setDepthTexture(e,t=Re){this.fullscreenMaterial.depthBuffer=e,this.fullscreenMaterial.depthPacking=t;for(const n of this.effects)n.setDepthTexture(e,t)}render(e,t,n,i,s){for(const a of this.effects)a.update(e,t,i);if(!this.skipRendering||this.renderToScreen){const a=this.fullscreenMaterial;a.inputBuffer=t.texture,a.time+=i*this.timeScale,e.setRenderTarget(this.renderToScreen?null:n),e.render(this.scene,this.camera)}}setSize(e,t){this.fullscreenMaterial.setSize(e,t);for(const n of this.effects)n.setSize(e,t)}initialize(e,t,n){this.renderer=e;for(const i of this.effects)i.initialize(e,t,n);this.updateMaterial(),n!==void 0&&n!==Ue&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}dispose(){super.dispose();for(const e of this.effects)e.removeEventListener("change",this.listener),e.dispose()}handleEvent(e){switch(e.type){case"change":this.recompile();break}}},ua=class extends ne{constructor(e,t,{renderTarget:n,resolutionScale:i=1,width:s=Z.AUTO_SIZE,height:a=Z.AUTO_SIZE,resolutionX:r=s,resolutionY:o=a}={}){super("NormalPass"),this.needsSwap=!1,this.renderPass=new Qt(e,t,new xs);const l=this.renderPass;l.ignoreBackground=!0,l.skipShadowMapUpdate=!0;const u=l.getClearPass();u.overrideClearColor=new pe(7829503),u.overrideClearAlpha=1,this.renderTarget=n,this.renderTarget===void 0&&(this.renderTarget=new ce(1,1,{minFilter:Qe,magFilter:Qe}),this.renderTarget.texture.name="NormalPass.Target");const c=this.resolution=new Z(this,r,o,i);c.addEventListener("change",d=>this.setSize(c.baseWidth,c.baseHeight))}set mainScene(e){this.renderPass.mainScene=e}set mainCamera(e){this.renderPass.mainCamera=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}render(e,t,n,i,s){const a=this.renderToScreen?null:this.renderTarget;this.renderPass.render(e,a,a)}setSize(e,t){const n=this.resolution;n.setBaseSize(e,t),this.renderTarget.setSize(n.width,n.height)}};const Oi=C.createContext(null),ni=e=>(e.getAttributes()&be.CONVOLUTION)===be.CONVOLUTION,fa=fe.memo(C.forwardRef(({children:e,camera:t,scene:n,resolutionScale:i,enabled:s=!0,renderPriority:a=1,autoClear:r=!0,depthBuffer:o,enableNormalPass:l,stencilBuffer:u,multisampling:c=8,frameBufferType:d=Ts},f)=>{const{gl:p,scene:x,camera:w,size:S}=Ln(),g=n||x,m=t||w,[h,A,T]=C.useMemo(()=>{const y=ks(),b=new nr(p,{depthBuffer:o,stencilBuffer:u,multisampling:c>0&&y?c:0,frameBufferType:d});b.addPass(new Qt(g,m));let P=null,E=null;return l&&(E=new ua(g,m),E.enabled=!1,b.addPass(E),i!==void 0&&y&&(P=new sa({normalBuffer:E.texture,resolutionScale:i}),P.enabled=!1,b.addPass(P))),[b,E,P]},[m,p,o,u,c,d,g,l,i]);C.useEffect(()=>h==null?void 0:h.setSize(S.width,S.height),[h,S]),Bi((y,b)=>{if(s){const P=p.autoClear;p.autoClear=r,u&&!r&&p.clearStencil(),h.render(b),p.autoClear=P}},s?a:0);const M=C.useRef(null),_=bs(M);C.useLayoutEffect(()=>{const y=[];if(M.current&&_.current&&h){const b=_.current.objects;for(let P=0;P<b.length;P++){const E=b[P];if(E instanceof An){const R=[E];if(!ni(E)){let L=null;for(;(L=b[P+1])instanceof An&&!ni(L);)R.push(L),P++}const D=new ca(m,...R);y.push(D)}else E instanceof ne&&y.push(E)}for(const P of y)h==null||h.addPass(P);A&&(A.enabled=!0),T&&(T.enabled=!0)}return()=>{for(const b of y)h==null||h.removePass(b);A&&(A.enabled=!1),T&&(T.enabled=!1)}},[h,e,m,A,T,_]),C.useEffect(()=>{const y=p.toneMapping;return p.toneMapping=ws,()=>{p.toneMapping=y}},[]);const v=C.useMemo(()=>({composer:h,normalPass:A,downSamplingPass:T,resolutionScale:i,camera:m,scene:g}),[h,A,T,i,m,g]);return C.useImperativeHandle(f,()=>h,[h]),z(Oi.Provider,{value:v,children:z("group",{ref:M,children:e})})})),ii=e=>typeof e=="object"&&e!=null&&"current"in e?e.current:e,da=C.forwardRef(function({selection:t=[],selectionLayer:n=10,blendFunction:i,patternTexture:s,edgeStrength:a,pulseSpeed:r,visibleEdgeColor:o,hiddenEdgeColor:l,width:u,height:c,kernelSize:d,blur:f,xRay:p,...x},w){const S=Ln(T=>T.invalidate),{scene:g,camera:m}=C.useContext(Oi),h=C.useMemo(()=>new ea(g,m,{blendFunction:i,patternTexture:s,edgeStrength:a,pulseSpeed:r,visibleEdgeColor:o,hiddenEdgeColor:l,width:u,height:c,kernelSize:d,blur:f,xRay:p,...x}),[i,f,m,a,c,l,d,s,r,g,o,u,p]),A=C.useContext(Li);return C.useEffect(()=>{if(!A&&t)return h.selection.set(Array.isArray(t)?t.map(ii):[ii(t)]),S(),()=>{h.selection.clear(),S()}},[h,t,A,S]),C.useEffect(()=>{h.selectionLayer=n,S()},[h,S,n]),C.useRef(),C.useEffect(()=>{var T;if(A&&A.enabled&&(T=A.selected)!=null&&T.length)return h.selection.set(A.selected),S(),()=>{h.selection.clear(),S()}},[A,h.selection,S]),C.useEffect(()=>()=>{h.dispose()},[h]),z("primitive",{ref:w,object:h})});/**
 * postprocessing v6.30.2 build Fri Mar 31 2023
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2023 Raoul van Rüschen
 * @license Zlib
 */var k={SKIP:9,SET:30,ADD:0,ALPHA:1,AVERAGE:2,COLOR:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,DIVIDE:8,DST:9,EXCLUSION:10,HARD_LIGHT:11,HARD_MIX:12,HUE:13,INVERT:14,INVERT_RGB:15,LIGHTEN:16,LINEAR_BURN:17,LINEAR_DODGE:18,LINEAR_LIGHT:19,LUMINOSITY:20,MULTIPLY:21,NEGATION:22,NORMAL:23,OVERLAY:24,PIN_LIGHT:25,REFLECT:26,SATURATION:27,SCREEN:28,SOFT_LIGHT:29,SRC:30,SUBTRACT:31,VIVID_LIGHT:32},ha={NONE:0,DEPTH:1,CONVOLUTION:2},pa=new Pi,Ee=null;function ma(){if(Ee===null){const e=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),t=new Float32Array([0,0,2,0,0,2]);Ee=new Gt,Ee.setAttribute!==void 0?(Ee.setAttribute("position",new me(e,3)),Ee.setAttribute("uv",new me(t,2))):(Ee.addAttribute("position",new me(e,3)),Ee.addAttribute("uv",new me(t,2)))}return Ee}var ki=class{constructor(e="Pass",t=new Ht,n=pa){this.name=e,this.renderer=null,this.scene=t,this.camera=n,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}get renderToScreen(){return!this.rtt}set renderToScreen(e){if(this.rtt===e){const t=this.fullscreenMaterial;t!==null&&(t.needsUpdate=!0),this.rtt=!e}}set mainScene(e){}set mainCamera(e){}setRenderer(e){this.renderer=e}isEnabled(){return this.enabled}setEnabled(e){this.enabled=e}get fullscreenMaterial(){return this.screen!==null?this.screen.material:null}set fullscreenMaterial(e){let t=this.screen;t!==null?t.material=e:(t=new Yt(ma(),e),t.frustumCulled=!1,this.scene===null&&(this.scene=new Ht),this.scene.add(t),this.screen=t)}getFullscreenMaterial(){return this.fullscreenMaterial}setFullscreenMaterial(e){this.fullscreenMaterial=e}getDepthTexture(){return null}setDepthTexture(e,t=Re){}render(e,t,n,i,s){throw new Error("Render method not implemented!")}setSize(e,t){}initialize(e,t,n){}dispose(){for(const e of Object.keys(this)){const t=this[e];(t instanceof ce||t instanceof Kt||t instanceof Zt||t instanceof ki)&&this[e].dispose()}}};new pe;var va="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}",ga="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}",ya="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}",xa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",Sa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}",ba="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}",wa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}",Ta="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}",Aa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}",_a="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}",Ea="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}",Ca="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}",Ma="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}",Pa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}",Ba="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}",Ra="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}",za="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}",Na="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}",Da="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}",La="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",Ua="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}",Ia="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}",Oa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}",ka="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}",Fa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}",Ha="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}",Va="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",Ga="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}",ja="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}",$a="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",Wa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}",Xa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}",qa=new Map([[k.ADD,va],[k.ALPHA,ga],[k.AVERAGE,ya],[k.COLOR,xa],[k.COLOR_BURN,Sa],[k.COLOR_DODGE,ba],[k.DARKEN,wa],[k.DIFFERENCE,Ta],[k.DIVIDE,Aa],[k.DST,null],[k.EXCLUSION,_a],[k.HARD_LIGHT,Ea],[k.HARD_MIX,Ca],[k.HUE,Ma],[k.INVERT,Pa],[k.INVERT_RGB,Ba],[k.LIGHTEN,Ra],[k.LINEAR_BURN,za],[k.LINEAR_DODGE,Na],[k.LINEAR_LIGHT,Da],[k.LUMINOSITY,La],[k.MULTIPLY,Ua],[k.NEGATION,Ia],[k.NORMAL,Oa],[k.OVERLAY,ka],[k.PIN_LIGHT,Fa],[k.REFLECT,Ha],[k.SATURATION,Va],[k.SCREEN,Ga],[k.SOFT_LIGHT,ja],[k.SRC,$a],[k.SUBTRACT,Wa],[k.VIVID_LIGHT,Xa]]),Ya=class extends yt{constructor(e,t=1){super(),this._blendFunction=e,this.opacity=new H(t)}getOpacity(){return this.opacity.value}setOpacity(e){this.opacity.value=e}get blendFunction(){return this._blendFunction}set blendFunction(e){this._blendFunction=e,this.dispatchEvent({type:"change"})}getBlendFunction(){return this.blendFunction}setBlendFunction(e){this.blendFunction=e}getShaderCode(){return qa.get(this.blendFunction)}},Ka=class extends yt{constructor(e,t,{attributes:n=ha.NONE,blendFunction:i=k.NORMAL,defines:s=new Map,uniforms:a=new Map,extensions:r=null,vertexShader:o=null}={}){super(),this.name=e,this.renderer=null,this.attributes=n,this.fragmentShader=t,this.vertexShader=o,this.defines=s,this.uniforms=a,this.extensions=r,this.blendMode=new Ya(i),this.blendMode.addEventListener("change",l=>this.setChanged()),this._inputColorSpace=As,this._outputColorSpace=null}get inputColorSpace(){return this._inputColorSpace}set inputColorSpace(e){this._inputColorSpace=e,this.setChanged()}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e,this.setChanged()}set mainScene(e){}set mainCamera(e){}getName(){return this.name}setRenderer(e){this.renderer=e}getDefines(){return this.defines}getUniforms(){return this.uniforms}getExtensions(){return this.extensions}getBlendMode(){return this.blendMode}getAttributes(){return this.attributes}setAttributes(e){this.attributes=e,this.setChanged()}getFragmentShader(){return this.fragmentShader}setFragmentShader(e){this.fragmentShader=e,this.setChanged()}getVertexShader(){return this.vertexShader}setVertexShader(e){this.vertexShader=e,this.setChanged()}setChanged(){this.dispatchEvent({type:"change"})}setDepthTexture(e,t=Re){}update(e,t,n){}setSize(e,t){}initialize(e,t,n){}dispose(){for(const e of Object.keys(this)){const t=this[e];(t instanceof ce||t instanceof Kt||t instanceof Zt||t instanceof ki)&&this[e].dispose()}}};new N;new we;new pe;new N;new N;const Za=`
    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor)
    {
        outputColor = vec4(uv, 1.0, 1.0);
    }
`;class Qa extends Ka{constructor(){super("HighlightEffect",Za,{})}}function Ja(){return new Qa,z(K,{})}const Fi=0,eo=1,to=2,si=2,sn=1.25,ri=1,mt=6*4+4+4,Jt=65535,no=Math.pow(2,-24),rn=Symbol("SKIP_GENERATION");function io(e){return e.index?e.index.count:e.attributes.position.count}function et(e){return io(e)/3}function so(e,t=ArrayBuffer){return e>65535?new Uint32Array(new t(4*e)):new Uint16Array(new t(2*e))}function ro(e,t){if(!e.index){const n=e.attributes.position.count,i=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=so(n,i);e.setIndex(new me(s,1));for(let a=0;a<n;a++)s[a]=a}}function Hi(e){const t=et(e),n=e.drawRange,i=n.start/3,s=(n.start+n.count)/3,a=Math.max(0,i),r=Math.min(t,s)-a;return[{offset:Math.floor(a),count:Math.floor(r)}]}function Vi(e){if(!e.groups||!e.groups.length)return Hi(e);const t=[],n=new Set,i=e.drawRange,s=i.start/3,a=(i.start+i.count)/3;for(const o of e.groups){const l=o.start/3,u=(o.start+o.count)/3;n.add(Math.max(s,l)),n.add(Math.min(a,u))}const r=Array.from(n.values()).sort((o,l)=>o-l);for(let o=0;o<r.length-1;o++){const l=r[o],u=r[o+1];t.push({offset:Math.floor(l),count:Math.floor(u-l)})}return t}function ao(e){if(e.groups.length===0)return!1;const t=et(e),n=Vi(e).sort((a,r)=>a.offset-r.offset),i=n[n.length-1];i.count=Math.min(t-i.offset,i.count);let s=0;return n.forEach(({count:a})=>s+=a),t!==s}function an(e,t,n,i,s){let a=1/0,r=1/0,o=1/0,l=-1/0,u=-1/0,c=-1/0,d=1/0,f=1/0,p=1/0,x=-1/0,w=-1/0,S=-1/0;for(let g=t*6,m=(t+n)*6;g<m;g+=6){const h=e[g+0],A=e[g+1],T=h-A,M=h+A;T<a&&(a=T),M>l&&(l=M),h<d&&(d=h),h>x&&(x=h);const _=e[g+2],v=e[g+3],y=_-v,b=_+v;y<r&&(r=y),b>u&&(u=b),_<f&&(f=_),_>w&&(w=_);const P=e[g+4],E=e[g+5],R=P-E,D=P+E;R<o&&(o=R),D>c&&(c=D),P<p&&(p=P),P>S&&(S=P)}i[0]=a,i[1]=r,i[2]=o,i[3]=l,i[4]=u,i[5]=c,s[0]=d,s[1]=f,s[2]=p,s[3]=x,s[4]=w,s[5]=S}function oo(e,t=null,n=null,i=null){const s=e.attributes.position,a=e.index?e.index.array:null,r=et(e),o=s.normalized;let l;t===null?(l=new Float32Array(r*6*4),n=0,i=r):(l=t,n=n||0,i=i||r);const u=s.array,c=s.offset||0;let d=3;s.isInterleavedBufferAttribute&&(d=s.data.stride);const f=["getX","getY","getZ"];for(let p=n;p<n+i;p++){const x=p*3,w=p*6;let S=x+0,g=x+1,m=x+2;a&&(S=a[S],g=a[g],m=a[m]),o||(S=S*d+c,g=g*d+c,m=m*d+c);for(let h=0;h<3;h++){let A,T,M;o?(A=s[f[h]](S),T=s[f[h]](g),M=s[f[h]](m)):(A=u[S+h],T=u[g+h],M=u[m+h]);let _=A;T<_&&(_=T),M<_&&(_=M);let v=A;T>v&&(v=T),M>v&&(v=M);const y=(v-_)/2,b=h*2;l[w+b+0]=_+y,l[w+b+1]=y+(Math.abs(_)+y)*no}}return l}function X(e,t,n){return n.min.x=t[e],n.min.y=t[e+1],n.min.z=t[e+2],n.max.x=t[e+3],n.max.y=t[e+4],n.max.z=t[e+5],n}function ai(e){let t=-1,n=-1/0;for(let i=0;i<3;i++){const s=e[i+3]-e[i];s>n&&(n=s,t=i)}return t}function oi(e,t){t.set(e)}function li(e,t,n){let i,s;for(let a=0;a<3;a++){const r=a+3;i=e[a],s=t[a],n[a]=i<s?i:s,i=e[r],s=t[r],n[r]=i>s?i:s}}function At(e,t,n){for(let i=0;i<3;i++){const s=t[e+2*i],a=t[e+2*i+1],r=s-a,o=s+a;r<n[i]&&(n[i]=r),o>n[i+3]&&(n[i+3]=o)}}function rt(e){const t=e[3]-e[0],n=e[4]-e[1],i=e[5]-e[2];return 2*(t*n+n*i+i*t)}const xe=32,lo=(e,t)=>e.candidate-t.candidate,Ce=new Array(xe).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),_t=new Float32Array(6);function co(e,t,n,i,s,a){let r=-1,o=0;if(a===Fi)r=ai(t),r!==-1&&(o=(t[r]+t[r+3])/2);else if(a===eo)r=ai(e),r!==-1&&(o=uo(n,i,s,r));else if(a===to){const l=rt(e);let u=sn*s;const c=i*6,d=(i+s)*6;for(let f=0;f<3;f++){const p=t[f],S=(t[f+3]-p)/xe;if(s<xe/4){const g=[...Ce];g.length=s;let m=0;for(let A=c;A<d;A+=6,m++){const T=g[m];T.candidate=n[A+2*f],T.count=0;const{bounds:M,leftCacheBounds:_,rightCacheBounds:v}=T;for(let y=0;y<3;y++)v[y]=1/0,v[y+3]=-1/0,_[y]=1/0,_[y+3]=-1/0,M[y]=1/0,M[y+3]=-1/0;At(A,n,M)}g.sort(lo);let h=s;for(let A=0;A<h;A++){const T=g[A];for(;A+1<h&&g[A+1].candidate===T.candidate;)g.splice(A+1,1),h--}for(let A=c;A<d;A+=6){const T=n[A+2*f];for(let M=0;M<h;M++){const _=g[M];T>=_.candidate?At(A,n,_.rightCacheBounds):(At(A,n,_.leftCacheBounds),_.count++)}}for(let A=0;A<h;A++){const T=g[A],M=T.count,_=s-T.count,v=T.leftCacheBounds,y=T.rightCacheBounds;let b=0;M!==0&&(b=rt(v)/l);let P=0;_!==0&&(P=rt(y)/l);const E=ri+sn*(b*M+P*_);E<u&&(r=f,u=E,o=T.candidate)}}else{for(let h=0;h<xe;h++){const A=Ce[h];A.count=0,A.candidate=p+S+h*S;const T=A.bounds;for(let M=0;M<3;M++)T[M]=1/0,T[M+3]=-1/0}for(let h=c;h<d;h+=6){let M=~~((n[h+2*f]-p)/S);M>=xe&&(M=xe-1);const _=Ce[M];_.count++,At(h,n,_.bounds)}const g=Ce[xe-1];oi(g.bounds,g.rightCacheBounds);for(let h=xe-2;h>=0;h--){const A=Ce[h],T=Ce[h+1];li(A.bounds,T.rightCacheBounds,A.rightCacheBounds)}let m=0;for(let h=0;h<xe-1;h++){const A=Ce[h],T=A.count,M=A.bounds,v=Ce[h+1].rightCacheBounds;T!==0&&(m===0?oi(M,_t):li(M,_t,_t)),m+=T;let y=0,b=0;m!==0&&(y=rt(_t)/l);const P=s-m;P!==0&&(b=rt(v)/l);const E=ri+sn*(y*m+b*P);E<u&&(r=f,u=E,o=A.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);return{axis:r,pos:o}}function uo(e,t,n,i){let s=0;for(let a=t,r=t+n;a<r;a++)s+=e[a*6+i*2];return s/n}class on{constructor(){this.boundingData=new Float32Array(6)}}function fo(e,t,n,i,s,a){let r=i,o=i+s-1;const l=a.pos,u=a.axis*2;for(;;){for(;r<=o&&n[r*6+u]<l;)r++;for(;r<=o&&n[o*6+u]>=l;)o--;if(r<o){for(let c=0;c<3;c++){let d=t[r*3+c];t[r*3+c]=t[o*3+c],t[o*3+c]=d}for(let c=0;c<6;c++){let d=n[r*6+c];n[r*6+c]=n[o*6+c],n[o*6+c]=d}r++,o--}else return r}}function ho(e,t,n,i,s,a){let r=i,o=i+s-1;const l=a.pos,u=a.axis*2;for(;;){for(;r<=o&&n[r*6+u]<l;)r++;for(;r<=o&&n[o*6+u]>=l;)o--;if(r<o){let c=e[r];e[r]=e[o],e[o]=c;for(let d=0;d<6;d++){let f=n[r*6+d];n[r*6+d]=n[o*6+d],n[o*6+d]=f}r++,o--}else return r}}function J(e,t){return t[e+15]===65535}function ee(e,t){return t[e+6]}function re(e,t){return t[e+14]}function ae(e){return e+8}function oe(e,t){return t[e+6]}function Gi(e,t){return t[e+7]}let ji,pt,Ft,$i;const po=Math.pow(2,32);function _n(e){return"count"in e?1:1+_n(e.left)+_n(e.right)}function mo(e,t,n){return ji=new Float32Array(n),pt=new Uint32Array(n),Ft=new Uint16Array(n),$i=new Uint8Array(n),En(e,t)}function En(e,t){const n=e/4,i=e/2,s="count"in t,a=t.boundingData;for(let r=0;r<6;r++)ji[n+r]=a[r];if(s)if(t.buffer){const r=t.buffer;$i.set(new Uint8Array(r),e);for(let o=e,l=e+r.byteLength;o<l;o+=mt){const u=o/2;J(u,Ft)||(pt[o/4+6]+=n)}return e+r.byteLength}else{const r=t.offset,o=t.count;return pt[n+6]=r,Ft[i+14]=o,Ft[i+15]=Jt,e+mt}else{const r=t.left,o=t.right,l=t.splitAxis;let u;if(u=En(e+mt,r),u/4>po)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return pt[n+6]=u/4,u=En(u,o),pt[n+7]=l,u}}function vo(e,t){const n=(e.index?e.index.count:e.attributes.position.count)/3,i=n>2**16,s=i?4:2,a=t?new SharedArrayBuffer(n*s):new ArrayBuffer(n*s),r=i?new Uint32Array(a):new Uint16Array(a);for(let o=0,l=r.length;o<l;o++)r[o]=o;return r}function go(e,t,n,i,s){const{maxDepth:a,verbose:r,maxLeafTris:o,strategy:l,onProgress:u,indirect:c}=s,d=e._indirectBuffer,f=e.geometry,p=f.index?f.index.array:null,x=c?ho:fo,w=et(f),S=new Float32Array(6);let g=!1;const m=new on;return an(t,n,i,m.boundingData,S),A(m,n,i,S),m;function h(T){u&&u(T/w)}function A(T,M,_,v=null,y=0){if(!g&&y>=a&&(g=!0,r&&(console.warn(`MeshBVH: Max depth of ${a} reached when generating BVH. Consider increasing maxDepth.`),console.warn(f))),_<=o||y>=a)return h(M+_),T.offset=M,T.count=_,T;const b=co(T.boundingData,v,t,M,_,l);if(b.axis===-1)return h(M+_),T.offset=M,T.count=_,T;const P=x(d,p,t,M,_,b);if(P===M||P===M+_)h(M+_),T.offset=M,T.count=_;else{T.splitAxis=b.axis;const E=new on,R=M,D=P-M;T.left=E,an(t,R,D,E.boundingData,S),A(E,R,D,S,y+1);const L=new on,j=P,ie=_-D;T.right=L,an(t,j,ie,L.boundingData,S),A(L,j,ie,S,y+1)}return T}}function yo(e,t){const n=e.geometry;t.indirect&&(e._indirectBuffer=vo(n,t.useSharedArrayBuffer),ao(n)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),e._indirectBuffer||ro(n,t);const i=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=oo(n),a=t.indirect?Hi(n):Vi(n);e._roots=a.map(r=>{const o=go(e,s,r.offset,r.count,t),l=_n(o),u=new i(mt*l);return mo(0,o,u),u})}class Te{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,n){let i=1/0,s=-1/0;for(let a=0,r=t.length;a<r;a++){const l=t[a][n];i=l<i?l:i,s=l>s?l:s}this.min=i,this.max=s}setFromPoints(t,n){let i=1/0,s=-1/0;for(let a=0,r=n.length;a<r;a++){const o=n[a],l=t.dot(o);i=l<i?l:i,s=l>s?l:s}this.min=i,this.max=s}isSeparated(t){return this.min>t.max||t.min>this.max}}Te.prototype.setFromBox=function(){const e=new N;return function(n,i){const s=i.min,a=i.max;let r=1/0,o=-1/0;for(let l=0;l<=1;l++)for(let u=0;u<=1;u++)for(let c=0;c<=1;c++){e.x=s.x*l+a.x*(1-l),e.y=s.y*u+a.y*(1-u),e.z=s.z*c+a.z*(1-c);const d=n.dot(e);r=Math.min(d,r),o=Math.max(d,o)}this.min=r,this.max=o}}();const xo=function(){const e=new N,t=new N,n=new N;return function(s,a,r){const o=s.start,l=e,u=a.start,c=t;n.subVectors(o,u),e.subVectors(s.end,s.start),t.subVectors(a.end,a.start);const d=n.dot(c),f=c.dot(l),p=c.dot(c),x=n.dot(l),S=l.dot(l)*p-f*f;let g,m;S!==0?g=(d*f-x*p)/S:g=0,m=(d+g*f)/p,r.x=g,r.y=m}}(),Fn=function(){const e=new q,t=new N,n=new N;return function(s,a,r,o){xo(s,a,e);let l=e.x,u=e.y;if(l>=0&&l<=1&&u>=0&&u<=1){s.at(l,r),a.at(u,o);return}else if(l>=0&&l<=1){u<0?a.at(0,o):a.at(1,o),s.closestPointToPoint(o,!0,r);return}else if(u>=0&&u<=1){l<0?s.at(0,r):s.at(1,r),a.closestPointToPoint(r,!0,o);return}else{let c;l<0?c=s.start:c=s.end;let d;u<0?d=a.start:d=a.end;const f=t,p=n;if(s.closestPointToPoint(d,!0,t),a.closestPointToPoint(c,!0,n),f.distanceToSquared(d)<=p.distanceToSquared(c)){r.copy(f),o.copy(d);return}else{r.copy(c),o.copy(p);return}}}}(),So=function(){const e=new N,t=new N,n=new Ri,i=new Se;return function(a,r){const{radius:o,center:l}=a,{a:u,b:c,c:d}=r;if(i.start=u,i.end=c,i.closestPointToPoint(l,!0,e).distanceTo(l)<=o||(i.start=u,i.end=d,i.closestPointToPoint(l,!0,e).distanceTo(l)<=o)||(i.start=c,i.end=d,i.closestPointToPoint(l,!0,e).distanceTo(l)<=o))return!0;const w=r.getPlane(n);if(Math.abs(w.distanceToPoint(l))<=o){const g=w.projectPoint(l,t);if(r.containsPoint(g))return!0}return!1}}(),bo=1e-15;function ln(e){return Math.abs(e)<bo}class he extends dt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new N),this.satBounds=new Array(4).fill().map(()=>new Te),this.points=[this.a,this.b,this.c],this.sphere=new _s,this.plane=new Ri,this.needsUpdate=!0}intersectsSphere(t){return So(t,this)}update(){const t=this.a,n=this.b,i=this.c,s=this.points,a=this.satAxes,r=this.satBounds,o=a[0],l=r[0];this.getNormal(o),l.setFromPoints(o,s);const u=a[1],c=r[1];u.subVectors(t,n),c.setFromPoints(u,s);const d=a[2],f=r[2];d.subVectors(n,i),f.setFromPoints(d,s);const p=a[3],x=r[3];p.subVectors(i,t),x.setFromPoints(p,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,t),this.needsUpdate=!1}}he.prototype.closestPointToSegment=function(){const e=new N,t=new N,n=new Se;return function(s,a=null,r=null){const{start:o,end:l}=s,u=this.points;let c,d=1/0;for(let f=0;f<3;f++){const p=(f+1)%3;n.start.copy(u[f]),n.end.copy(u[p]),Fn(n,s,e,t),c=e.distanceToSquared(t),c<d&&(d=c,a&&a.copy(e),r&&r.copy(t))}return this.closestPointToPoint(o,e),c=o.distanceToSquared(e),c<d&&(d=c,a&&a.copy(e),r&&r.copy(o)),this.closestPointToPoint(l,e),c=l.distanceToSquared(e),c<d&&(d=c,a&&a.copy(e),r&&r.copy(l)),Math.sqrt(d)}}();he.prototype.intersectsTriangle=function(){const e=new he,t=new Array(3),n=new Array(3),i=new Te,s=new Te,a=new N,r=new N,o=new N,l=new N,u=new N,c=new Se,d=new Se,f=new Se,p=new N;function x(w,S,g){const m=w.points;let h=0,A=-1;for(let T=0;T<3;T++){const{start:M,end:_}=c;M.copy(m[T]),_.copy(m[(T+1)%3]),c.delta(r);const v=ln(S.distanceToPoint(M));if(ln(S.normal.dot(r))&&v){g.copy(c),h=2;break}const y=S.intersectLine(c,p);if(!y&&v&&p.copy(M),(y||v)&&!ln(p.distanceTo(_))){if(h<=1)(h===1?g.start:g.end).copy(p),v&&(A=h);else if(h>=2){(A===1?g.start:g.end).copy(p),h=2;break}if(h++,h===2&&A===-1)break}}return h}return function(S,g=null,m=!1){this.needsUpdate&&this.update(),S.isExtendedTriangle?S.needsUpdate&&S.update():(e.copy(S),e.update(),S=e);const h=this.plane,A=S.plane;if(Math.abs(h.normal.dot(A.normal))>1-1e-10){const T=this.satBounds,M=this.satAxes;n[0]=S.a,n[1]=S.b,n[2]=S.c;for(let y=0;y<4;y++){const b=T[y],P=M[y];if(i.setFromPoints(P,n),b.isSeparated(i))return!1}const _=S.satBounds,v=S.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let y=0;y<4;y++){const b=_[y],P=v[y];if(i.setFromPoints(P,t),b.isSeparated(i))return!1}for(let y=0;y<4;y++){const b=M[y];for(let P=0;P<4;P++){const E=v[P];if(a.crossVectors(b,E),i.setFromPoints(a,t),s.setFromPoints(a,n),i.isSeparated(s))return!1}}return g&&(m||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),g.start.set(0,0,0),g.end.set(0,0,0)),!0}else{const T=x(this,A,d);if(T===1&&S.containsPoint(d.end))return g&&(g.start.copy(d.end),g.end.copy(d.end)),!0;if(T!==2)return!1;const M=x(S,h,f);if(M===1&&this.containsPoint(f.end))return g&&(g.start.copy(f.end),g.end.copy(f.end)),!0;if(M!==2)return!1;if(d.delta(o),f.delta(l),o.dot(l)<0){let R=f.start;f.start=f.end,f.end=R}const _=d.start.dot(o),v=d.end.dot(o),y=f.start.dot(o),b=f.end.dot(o),P=v<y,E=_<b;return _!==b&&y!==v&&P===E?!1:(g&&(u.subVectors(d.start,f.start),u.dot(o)>0?g.start.copy(d.start):g.start.copy(f.start),u.subVectors(d.end,f.end),u.dot(o)<0?g.end.copy(d.end):g.end.copy(f.end)),!0)}}}();he.prototype.distanceToPoint=function(){const e=new N;return function(n){return this.closestPointToPoint(n,e),n.distanceTo(e)}}();he.prototype.distanceToTriangle=function(){const e=new N,t=new N,n=["a","b","c"],i=new Se,s=new Se;return function(r,o=null,l=null){const u=o||l?i:null;if(this.intersectsTriangle(r,u))return(o||l)&&(o&&u.getCenter(o),l&&u.getCenter(l)),0;let c=1/0;for(let d=0;d<3;d++){let f;const p=n[d],x=r[p];this.closestPointToPoint(x,e),f=x.distanceToSquared(e),f<c&&(c=f,o&&o.copy(e),l&&l.copy(x));const w=this[p];r.closestPointToPoint(w,e),f=w.distanceToSquared(e),f<c&&(c=f,o&&o.copy(w),l&&l.copy(e))}for(let d=0;d<3;d++){const f=n[d],p=n[(d+1)%3];i.set(this[f],this[p]);for(let x=0;x<3;x++){const w=n[x],S=n[(x+1)%3];s.set(r[w],r[S]),Fn(i,s,e,t);const g=e.distanceToSquared(t);g<c&&(c=g,o&&o.copy(e),l&&l.copy(t))}}return Math.sqrt(c)}}();class Q{constructor(t,n,i){this.isOrientedBox=!0,this.min=new N,this.max=new N,this.matrix=new we,this.invMatrix=new we,this.points=new Array(8).fill().map(()=>new N),this.satAxes=new Array(3).fill().map(()=>new N),this.satBounds=new Array(3).fill().map(()=>new Te),this.alignedSatBounds=new Array(3).fill().map(()=>new Te),this.needsUpdate=!1,t&&this.min.copy(t),n&&this.max.copy(n),i&&this.matrix.copy(i)}set(t,n,i){this.min.copy(t),this.max.copy(n),this.matrix.copy(i),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}Q.prototype.update=function(){return function(){const t=this.matrix,n=this.min,i=this.max,s=this.points;for(let u=0;u<=1;u++)for(let c=0;c<=1;c++)for(let d=0;d<=1;d++){const f=1*u|2*c|4*d,p=s[f];p.x=u?i.x:n.x,p.y=c?i.y:n.y,p.z=d?i.z:n.z,p.applyMatrix4(t)}const a=this.satBounds,r=this.satAxes,o=s[0];for(let u=0;u<3;u++){const c=r[u],d=a[u],f=1<<u,p=s[f];c.subVectors(o,p),d.setFromPoints(c,s)}const l=this.alignedSatBounds;l[0].setFromPointsField(s,"x"),l[1].setFromPointsField(s,"y"),l[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();Q.prototype.intersectsBox=function(){const e=new Te;return function(n){this.needsUpdate&&this.update();const i=n.min,s=n.max,a=this.satBounds,r=this.satAxes,o=this.alignedSatBounds;if(e.min=i.x,e.max=s.x,o[0].isSeparated(e)||(e.min=i.y,e.max=s.y,o[1].isSeparated(e))||(e.min=i.z,e.max=s.z,o[2].isSeparated(e)))return!1;for(let l=0;l<3;l++){const u=r[l],c=a[l];if(e.setFromBox(u,n),c.isSeparated(e))return!1}return!0}}();Q.prototype.intersectsTriangle=function(){const e=new he,t=new Array(3),n=new Te,i=new Te,s=new N;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(e.copy(r),e.update(),r=e);const o=this.satBounds,l=this.satAxes;t[0]=r.a,t[1]=r.b,t[2]=r.c;for(let f=0;f<3;f++){const p=o[f],x=l[f];if(n.setFromPoints(x,t),p.isSeparated(n))return!1}const u=r.satBounds,c=r.satAxes,d=this.points;for(let f=0;f<3;f++){const p=u[f],x=c[f];if(n.setFromPoints(x,d),p.isSeparated(n))return!1}for(let f=0;f<3;f++){const p=l[f];for(let x=0;x<4;x++){const w=c[x];if(s.crossVectors(p,w),n.setFromPoints(s,t),i.setFromPoints(s,d),n.isSeparated(i))return!1}}return!0}}();Q.prototype.closestPointToPoint=function(){return function(t,n){return this.needsUpdate&&this.update(),n.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),n}}();Q.prototype.distanceToPoint=function(){const e=new N;return function(n){return this.closestPointToPoint(n,e),n.distanceTo(e)}}();Q.prototype.distanceToBox=function(){const e=["x","y","z"],t=new Array(12).fill().map(()=>new Se),n=new Array(12).fill().map(()=>new Se),i=new N,s=new N;return function(r,o=0,l=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(l||u)&&(r.getCenter(s),this.closestPointToPoint(s,i),r.closestPointToPoint(i,s),l&&l.copy(i),u&&u.copy(s)),0;const c=o*o,d=r.min,f=r.max,p=this.points;let x=1/0;for(let S=0;S<8;S++){const g=p[S];s.copy(g).clamp(d,f);const m=g.distanceToSquared(s);if(m<x&&(x=m,l&&l.copy(g),u&&u.copy(s),m<c))return Math.sqrt(m)}let w=0;for(let S=0;S<3;S++)for(let g=0;g<=1;g++)for(let m=0;m<=1;m++){const h=(S+1)%3,A=(S+2)%3,T=g<<h|m<<A,M=1<<S|g<<h|m<<A,_=p[T],v=p[M];t[w].set(_,v);const b=e[S],P=e[h],E=e[A],R=n[w],D=R.start,L=R.end;D[b]=d[b],D[P]=g?d[P]:f[P],D[E]=m?d[E]:f[P],L[b]=f[b],L[P]=g?d[P]:f[P],L[E]=m?d[E]:f[P],w++}for(let S=0;S<=1;S++)for(let g=0;g<=1;g++)for(let m=0;m<=1;m++){s.x=S?f.x:d.x,s.y=g?f.y:d.y,s.z=m?f.z:d.z,this.closestPointToPoint(s,i);const h=s.distanceToSquared(i);if(h<x&&(x=h,l&&l.copy(i),u&&u.copy(s),h<c))return Math.sqrt(h)}for(let S=0;S<12;S++){const g=t[S];for(let m=0;m<12;m++){const h=n[m];Fn(g,h,i,s);const A=i.distanceToSquared(s);if(A<x&&(x=A,l&&l.copy(i),u&&u.copy(s),A<c))return Math.sqrt(A)}}return Math.sqrt(x)}}();class Hn{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class wo extends Hn{constructor(){super(()=>new he)}}const le=new wo;class To{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let n=null;this.setBuffer=i=>{n&&t.push(n),n=i,this.float32Array=new Float32Array(i),this.uint16Array=new Uint16Array(i),this.uint32Array=new Uint32Array(i)},this.clearBuffer=()=>{n=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const W=new To;let Pe,Ze;const Oe=[],Et=new Hn(()=>new ge);function Ao(e,t,n,i,s,a){Pe=Et.getPrimitive(),Ze=Et.getPrimitive(),Oe.push(Pe,Ze),W.setBuffer(e._roots[t]);const r=Cn(0,e.geometry,n,i,s,a);W.clearBuffer(),Et.releasePrimitive(Pe),Et.releasePrimitive(Ze),Oe.pop(),Oe.pop();const o=Oe.length;return o>0&&(Ze=Oe[o-1],Pe=Oe[o-2]),r}function Cn(e,t,n,i,s=null,a=0,r=0){const{float32Array:o,uint16Array:l,uint32Array:u}=W;let c=e*2;if(J(c,l)){const f=ee(e,u),p=re(c,l);return X(e,o,Pe),i(f,p,!1,r,a+e,Pe)}else{let b=function(E){const{uint16Array:R,uint32Array:D}=W;let L=E*2;for(;!J(L,R);)E=ae(E),L=E*2;return ee(E,D)},P=function(E){const{uint16Array:R,uint32Array:D}=W;let L=E*2;for(;!J(L,R);)E=oe(E,D),L=E*2;return ee(E,D)+re(L,R)};const f=ae(e),p=oe(e,u);let x=f,w=p,S,g,m,h;if(s&&(m=Pe,h=Ze,X(x,o,m),X(w,o,h),S=s(m),g=s(h),g<S)){x=p,w=f;const E=S;S=g,g=E,m=h}m||(m=Pe,X(x,o,m));const A=J(x*2,l),T=n(m,A,S,r+1,a+x);let M;if(T===si){const E=b(x),D=P(x)-E;M=i(E,D,!0,r+1,a+x,m)}else M=T&&Cn(x,t,n,i,s,a,r+1);if(M)return!0;h=Ze,X(w,o,h);const _=J(w*2,l),v=n(h,_,g,r+1,a+w);let y;if(v===si){const E=b(w),D=P(w)-E;y=i(E,D,!0,r+1,a+w,h)}else y=v&&Cn(w,t,n,i,s,a,r+1);return!!y}}const at=new N,cn=new N;function _o(e,t,n={},i=0,s=1/0){const a=i*i,r=s*s;let o=1/0,l=null;if(e.shapecast({boundsTraverseOrder:c=>(at.copy(t).clamp(c.min,c.max),at.distanceToSquared(t)),intersectsBounds:(c,d,f)=>f<o&&f<r,intersectsTriangle:(c,d)=>{c.closestPointToPoint(t,at);const f=t.distanceToSquared(at);return f<o&&(cn.copy(at),o=f,l=d),f<a}}),o===1/0)return null;const u=Math.sqrt(o);return n.point?n.point.copy(cn):n.point=cn.clone(),n.distance=u,n.faceIndex=l,n}const ke=new N,Fe=new N,He=new N,Ct=new q,Mt=new q,Pt=new q,ci=new N,ui=new N,fi=new N,Bt=new N;function Eo(e,t,n,i,s,a){let r;return a===Le?r=e.intersectTriangle(i,n,t,!0,s):r=e.intersectTriangle(t,n,i,a!==ft,s),r===null?null:{distance:e.origin.distanceTo(s),point:s.clone()}}function Co(e,t,n,i,s,a,r,o,l){ke.fromBufferAttribute(t,a),Fe.fromBufferAttribute(t,r),He.fromBufferAttribute(t,o);const u=Eo(e,ke,Fe,He,Bt,l);if(u){i&&(Ct.fromBufferAttribute(i,a),Mt.fromBufferAttribute(i,r),Pt.fromBufferAttribute(i,o),u.uv=dt.getInterpolation(Bt,ke,Fe,He,Ct,Mt,Pt,new q)),s&&(Ct.fromBufferAttribute(s,a),Mt.fromBufferAttribute(s,r),Pt.fromBufferAttribute(s,o),u.uv1=dt.getInterpolation(Bt,ke,Fe,He,Ct,Mt,Pt,new q)),n&&(ci.fromBufferAttribute(n,a),ui.fromBufferAttribute(n,r),fi.fromBufferAttribute(n,o),u.normal=dt.getInterpolation(Bt,ke,Fe,He,ci,ui,fi,new N),u.normal.dot(e.direction)>0&&u.normal.multiplyScalar(-1));const c={a,b:r,c:o,normal:new N,materialIndex:0};dt.getNormal(ke,Fe,He,c.normal),u.face=c,u.faceIndex=a}return u}function en(e,t,n,i,s){const a=i*3;let r=a+0,o=a+1,l=a+2;const u=e.index;e.index&&(r=u.getX(r),o=u.getX(o),l=u.getX(l));const{position:c,normal:d,uv:f,uv1:p}=e.attributes,x=Co(n,c,d,f,p,r,o,l,t);return x?(x.faceIndex=i,s&&s.push(x),x):null}function Y(e,t,n,i){const s=e.a,a=e.b,r=e.c;let o=t,l=t+1,u=t+2;n&&(o=n.getX(o),l=n.getX(l),u=n.getX(u)),s.x=i.getX(o),s.y=i.getY(o),s.z=i.getZ(o),a.x=i.getX(l),a.y=i.getY(l),a.z=i.getZ(l),r.x=i.getX(u),r.y=i.getY(u),r.z=i.getZ(u)}function Mo(e,t,n,i,s,a){const{geometry:r,_indirectBuffer:o}=e;for(let l=i,u=i+s;l<u;l++)en(r,t,n,l,a)}function Po(e,t,n,i,s){const{geometry:a,_indirectBuffer:r}=e;let o=1/0,l=null;for(let u=i,c=i+s;u<c;u++){let d;d=en(a,t,n,u),d&&d.distance<o&&(l=d,o=d.distance)}return l}function Bo(e,t,n,i,s,a,r){const{geometry:o}=n,{index:l}=o,u=o.attributes.position;for(let c=e,d=t+e;c<d;c++){let f;if(f=c,Y(r,f*3,l,u),r.needsUpdate=!0,i(r,f,s,a))return!0}return!1}function Ro(e,t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=e.geometry,i=n.index?n.index.array:null,s=n.attributes.position;let a,r,o,l,u=0;const c=e._roots;for(let f=0,p=c.length;f<p;f++)a=c[f],r=new Uint32Array(a),o=new Uint16Array(a),l=new Float32Array(a),d(0,u),u+=a.byteLength;function d(f,p,x=!1){const w=f*2;if(o[w+15]===Jt){const g=r[f+6],m=o[w+14];let h=1/0,A=1/0,T=1/0,M=-1/0,_=-1/0,v=-1/0;for(let y=3*g,b=3*(g+m);y<b;y++){let P=i[y];const E=s.getX(P),R=s.getY(P),D=s.getZ(P);E<h&&(h=E),E>M&&(M=E),R<A&&(A=R),R>_&&(_=R),D<T&&(T=D),D>v&&(v=D)}return l[f+0]!==h||l[f+1]!==A||l[f+2]!==T||l[f+3]!==M||l[f+4]!==_||l[f+5]!==v?(l[f+0]=h,l[f+1]=A,l[f+2]=T,l[f+3]=M,l[f+4]=_,l[f+5]=v,!0):!1}else{const g=f+8,m=r[f+6],h=g+p,A=m+p;let T=x,M=!1,_=!1;t?T||(M=t.has(h),_=t.has(A),T=!M&&!_):(M=!0,_=!0);const v=T||M,y=T||_;let b=!1;v&&(b=d(g,p,T));let P=!1;y&&(P=d(m,p,T));const E=b||P;if(E)for(let R=0;R<3;R++){const D=g+R,L=m+R,j=l[D],ie=l[D+3],ye=l[L],$=l[L+3];l[f+R]=j<ye?j:ye,l[f+R+3]=ie>$?ie:$}return E}}}function Be(e,t,n){let i,s,a,r,o,l;const u=1/n.direction.x,c=1/n.direction.y,d=1/n.direction.z,f=n.origin.x,p=n.origin.y,x=n.origin.z;let w=t[e],S=t[e+3],g=t[e+1],m=t[e+3+1],h=t[e+2],A=t[e+3+2];return u>=0?(i=(w-f)*u,s=(S-f)*u):(i=(S-f)*u,s=(w-f)*u),c>=0?(a=(g-p)*c,r=(m-p)*c):(a=(m-p)*c,r=(g-p)*c),!(i>r||a>s||((a>i||isNaN(i))&&(i=a),(r<s||isNaN(s))&&(s=r),d>=0?(o=(h-x)*d,l=(A-x)*d):(o=(A-x)*d,l=(h-x)*d),i>l||o>s)||((l<s||s!==s)&&(s=l),s<0))}function zo(e,t,n,i,s,a){const{geometry:r,_indirectBuffer:o}=e;for(let l=i,u=i+s;l<u;l++){let c=o?o[l]:l;en(r,t,n,c,a)}}function No(e,t,n,i,s){const{geometry:a,_indirectBuffer:r}=e;let o=1/0,l=null;for(let u=i,c=i+s;u<c;u++){let d;d=en(a,t,n,r?r[u]:u),d&&d.distance<o&&(l=d,o=d.distance)}return l}function Do(e,t,n,i,s,a,r){const{geometry:o}=n,{index:l}=o,u=o.attributes.position;for(let c=e,d=t+e;c<d;c++){let f;if(f=n.resolveTriangleIndex(c),Y(r,f*3,l,u),r.needsUpdate=!0,i(r,f,s,a))return!0}return!1}function Lo(e,t,n,i,s){W.setBuffer(e._roots[t]),Mn(0,e,n,i,s),W.clearBuffer()}function Mn(e,t,n,i,s){const{float32Array:a,uint16Array:r,uint32Array:o}=W,l=e*2;if(J(l,r)){const c=ee(e,o),d=re(l,r);Mo(t,n,i,c,d,s)}else{const c=ae(e);Be(c,a,i)&&Mn(c,t,n,i,s);const d=oe(e,o);Be(d,a,i)&&Mn(d,t,n,i,s)}}const Uo=["x","y","z"];function Io(e,t,n,i){W.setBuffer(e._roots[t]);const s=Pn(0,e,n,i);return W.clearBuffer(),s}function Pn(e,t,n,i){const{float32Array:s,uint16Array:a,uint32Array:r}=W;let o=e*2;if(J(o,a)){const u=ee(e,r),c=re(o,a);return Po(t,n,i,u,c)}else{const u=Gi(e,r),c=Uo[u],f=i.direction[c]>=0;let p,x;f?(p=ae(e),x=oe(e,r)):(p=oe(e,r),x=ae(e));const S=Be(p,s,i)?Pn(p,t,n,i):null;if(S){const h=S.point[c];if(f?h<=s[x+u]:h>=s[x+u+3])return S}const m=Be(x,s,i)?Pn(x,t,n,i):null;return S&&m?S.distance<=m.distance?S:m:S||m||null}}const Rt=new ge,Ve=new he,Ge=new he,ot=new we,di=new Q,zt=new Q;function Oo(e,t,n,i){W.setBuffer(e._roots[t]);const s=Bn(0,e,n,i);return W.clearBuffer(),s}function Bn(e,t,n,i,s=null){const{float32Array:a,uint16Array:r,uint32Array:o}=W;let l=e*2;if(s===null&&(n.boundingBox||n.computeBoundingBox(),di.set(n.boundingBox.min,n.boundingBox.max,i),s=di),J(l,r)){const c=t.geometry,d=c.index,f=c.attributes.position,p=n.index,x=n.attributes.position,w=ee(e,o),S=re(l,r);if(ot.copy(i).invert(),n.boundsTree)return X(e,a,zt),zt.matrix.copy(ot),zt.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:m=>zt.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(i),m.b.applyMatrix4(i),m.c.applyMatrix4(i),m.needsUpdate=!0;for(let h=w*3,A=(S+w)*3;h<A;h+=3)if(Y(Ge,h,d,f),Ge.needsUpdate=!0,m.intersectsTriangle(Ge))return!0;return!1}});for(let g=w*3,m=(S+w)*3;g<m;g+=3){Y(Ve,g,d,f),Ve.a.applyMatrix4(ot),Ve.b.applyMatrix4(ot),Ve.c.applyMatrix4(ot),Ve.needsUpdate=!0;for(let h=0,A=p.count;h<A;h+=3)if(Y(Ge,h,p,x),Ge.needsUpdate=!0,Ve.intersectsTriangle(Ge))return!0}}else{const c=e+8,d=o[e+6];return X(c,a,Rt),!!(s.intersectsBox(Rt)&&Bn(c,t,n,i,s)||(X(d,a,Rt),s.intersectsBox(Rt)&&Bn(d,t,n,i,s)))}}const Nt=new we,un=new Q,lt=new Q,ko=new N,Fo=new N,Ho=new N,Vo=new N;function Go(e,t,n,i={},s={},a=0,r=1/0){t.boundingBox||t.computeBoundingBox(),un.set(t.boundingBox.min,t.boundingBox.max,n),un.needsUpdate=!0;const o=e.geometry,l=o.attributes.position,u=o.index,c=t.attributes.position,d=t.index,f=le.getPrimitive(),p=le.getPrimitive();let x=ko,w=Fo,S=null,g=null;s&&(S=Ho,g=Vo);let m=1/0,h=null,A=null;return Nt.copy(n).invert(),lt.matrix.copy(Nt),e.shapecast({boundsTraverseOrder:T=>un.distanceToBox(T),intersectsBounds:(T,M,_)=>_<m&&_<r?(M&&(lt.min.copy(T.min),lt.max.copy(T.max),lt.needsUpdate=!0),!0):!1,intersectsRange:(T,M)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:v=>lt.distanceToBox(v),intersectsBounds:(v,y,b)=>b<m&&b<r,intersectsRange:(v,y)=>{for(let b=v,P=v+y;b<P;b++){Y(p,3*b,d,c),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let E=T,R=T+M;E<R;E++){Y(f,3*E,u,l),f.needsUpdate=!0;const D=f.distanceToTriangle(p,x,S);if(D<m&&(w.copy(x),g&&g.copy(S),m=D,h=E,A=b),D<a)return!0}}}});{const _=et(t);for(let v=0,y=_;v<y;v++){Y(p,3*v,d,c),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let b=T,P=T+M;b<P;b++){Y(f,3*b,u,l),f.needsUpdate=!0;const E=f.distanceToTriangle(p,x,S);if(E<m&&(w.copy(x),g&&g.copy(S),m=E,h=b,A=v),E<a)return!0}}}}}),le.releasePrimitive(f),le.releasePrimitive(p),m===1/0?null:(i.point?i.point.copy(w):i.point=w.clone(),i.distance=m,i.faceIndex=h,s&&(s.point?s.point.copy(g):s.point=g.clone(),s.point.applyMatrix4(Nt),w.applyMatrix4(Nt),s.distance=w.sub(s.point).length(),s.faceIndex=A),i)}function jo(e,t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=e.geometry,i=n.index?n.index.array:null,s=n.attributes.position;let a,r,o,l,u=0;const c=e._roots;for(let f=0,p=c.length;f<p;f++)a=c[f],r=new Uint32Array(a),o=new Uint16Array(a),l=new Float32Array(a),d(0,u),u+=a.byteLength;function d(f,p,x=!1){const w=f*2;if(o[w+15]===Jt){const g=r[f+6],m=o[w+14];let h=1/0,A=1/0,T=1/0,M=-1/0,_=-1/0,v=-1/0;for(let y=g,b=g+m;y<b;y++){const P=3*e.resolveTriangleIndex(y);for(let E=0;E<3;E++){let R=P+E;R=i?i[R]:R;const D=s.getX(R),L=s.getY(R),j=s.getZ(R);D<h&&(h=D),D>M&&(M=D),L<A&&(A=L),L>_&&(_=L),j<T&&(T=j),j>v&&(v=j)}}return l[f+0]!==h||l[f+1]!==A||l[f+2]!==T||l[f+3]!==M||l[f+4]!==_||l[f+5]!==v?(l[f+0]=h,l[f+1]=A,l[f+2]=T,l[f+3]=M,l[f+4]=_,l[f+5]=v,!0):!1}else{const g=f+8,m=r[f+6],h=g+p,A=m+p;let T=x,M=!1,_=!1;t?T||(M=t.has(h),_=t.has(A),T=!M&&!_):(M=!0,_=!0);const v=T||M,y=T||_;let b=!1;v&&(b=d(g,p,T));let P=!1;y&&(P=d(m,p,T));const E=b||P;if(E)for(let R=0;R<3;R++){const D=g+R,L=m+R,j=l[D],ie=l[D+3],ye=l[L],$=l[L+3];l[f+R]=j<ye?j:ye,l[f+R+3]=ie>$?ie:$}return E}}}function $o(e,t,n,i,s){W.setBuffer(e._roots[t]),Rn(0,e,n,i,s),W.clearBuffer()}function Rn(e,t,n,i,s){const{float32Array:a,uint16Array:r,uint32Array:o}=W,l=e*2;if(J(l,r)){const c=ee(e,o),d=re(l,r);zo(t,n,i,c,d,s)}else{const c=ae(e);Be(c,a,i)&&Rn(c,t,n,i,s);const d=oe(e,o);Be(d,a,i)&&Rn(d,t,n,i,s)}}const Wo=["x","y","z"];function Xo(e,t,n,i){W.setBuffer(e._roots[t]);const s=zn(0,e,n,i);return W.clearBuffer(),s}function zn(e,t,n,i){const{float32Array:s,uint16Array:a,uint32Array:r}=W;let o=e*2;if(J(o,a)){const u=ee(e,r),c=re(o,a);return No(t,n,i,u,c)}else{const u=Gi(e,r),c=Wo[u],f=i.direction[c]>=0;let p,x;f?(p=ae(e),x=oe(e,r)):(p=oe(e,r),x=ae(e));const S=Be(p,s,i)?zn(p,t,n,i):null;if(S){const h=S.point[c];if(f?h<=s[x+u]:h>=s[x+u+3])return S}const m=Be(x,s,i)?zn(x,t,n,i):null;return S&&m?S.distance<=m.distance?S:m:S||m||null}}const Dt=new ge,je=new he,$e=new he,ct=new we,hi=new Q,Lt=new Q;function qo(e,t,n,i){W.setBuffer(e._roots[t]);const s=Nn(0,e,n,i);return W.clearBuffer(),s}function Nn(e,t,n,i,s=null){const{float32Array:a,uint16Array:r,uint32Array:o}=W;let l=e*2;if(s===null&&(n.boundingBox||n.computeBoundingBox(),hi.set(n.boundingBox.min,n.boundingBox.max,i),s=hi),J(l,r)){const c=t.geometry,d=c.index,f=c.attributes.position,p=n.index,x=n.attributes.position,w=ee(e,o),S=re(l,r);if(ct.copy(i).invert(),n.boundsTree)return X(e,a,Lt),Lt.matrix.copy(ct),Lt.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:m=>Lt.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(i),m.b.applyMatrix4(i),m.c.applyMatrix4(i),m.needsUpdate=!0;for(let h=w,A=S+w;h<A;h++)if(Y($e,3*t.resolveTriangleIndex(h),d,f),$e.needsUpdate=!0,m.intersectsTriangle($e))return!0;return!1}});for(let g=w,m=S+w;g<m;g++){const h=t.resolveTriangleIndex(g);Y(je,3*h,d,f),je.a.applyMatrix4(ct),je.b.applyMatrix4(ct),je.c.applyMatrix4(ct),je.needsUpdate=!0;for(let A=0,T=p.count;A<T;A+=3)if(Y($e,A,p,x),$e.needsUpdate=!0,je.intersectsTriangle($e))return!0}}else{const c=e+8,d=o[e+6];return X(c,a,Dt),!!(s.intersectsBox(Dt)&&Nn(c,t,n,i,s)||(X(d,a,Dt),s.intersectsBox(Dt)&&Nn(d,t,n,i,s)))}}const Ut=new we,fn=new Q,ut=new Q,Yo=new N,Ko=new N,Zo=new N,Qo=new N;function Jo(e,t,n,i={},s={},a=0,r=1/0){t.boundingBox||t.computeBoundingBox(),fn.set(t.boundingBox.min,t.boundingBox.max,n),fn.needsUpdate=!0;const o=e.geometry,l=o.attributes.position,u=o.index,c=t.attributes.position,d=t.index,f=le.getPrimitive(),p=le.getPrimitive();let x=Yo,w=Ko,S=null,g=null;s&&(S=Zo,g=Qo);let m=1/0,h=null,A=null;return Ut.copy(n).invert(),ut.matrix.copy(Ut),e.shapecast({boundsTraverseOrder:T=>fn.distanceToBox(T),intersectsBounds:(T,M,_)=>_<m&&_<r?(M&&(ut.min.copy(T.min),ut.max.copy(T.max),ut.needsUpdate=!0),!0):!1,intersectsRange:(T,M)=>{if(t.boundsTree){const _=t.boundsTree;return _.shapecast({boundsTraverseOrder:v=>ut.distanceToBox(v),intersectsBounds:(v,y,b)=>b<m&&b<r,intersectsRange:(v,y)=>{for(let b=v,P=v+y;b<P;b++){const E=_.resolveTriangleIndex(b);Y(p,3*E,d,c),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let R=T,D=T+M;R<D;R++){const L=e.resolveTriangleIndex(R);Y(f,3*L,u,l),f.needsUpdate=!0;const j=f.distanceToTriangle(p,x,S);if(j<m&&(w.copy(x),g&&g.copy(S),m=j,h=R,A=b),j<a)return!0}}}})}else{const _=et(t);for(let v=0,y=_;v<y;v++){Y(p,3*v,d,c),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let b=T,P=T+M;b<P;b++){const E=e.resolveTriangleIndex(b);Y(f,3*E,u,l),f.needsUpdate=!0;const R=f.distanceToTriangle(p,x,S);if(R<m&&(w.copy(x),g&&g.copy(S),m=R,h=b,A=v),R<a)return!0}}}}}),le.releasePrimitive(f),le.releasePrimitive(p),m===1/0?null:(i.point?i.point.copy(w):i.point=w.clone(),i.distance=m,i.faceIndex=h,s&&(s.point?s.point.copy(g):s.point=g.clone(),s.point.applyMatrix4(Ut),w.applyMatrix4(Ut),s.distance=w.sub(s.point).length(),s.faceIndex=A),i)}function el(){return typeof SharedArrayBuffer<"u"}const vt=new W.constructor,$t=new W.constructor,Me=new Hn(()=>new ge),We=new ge,Xe=new ge,dn=new ge,hn=new ge;let pn=!1;function tl(e,t,n,i){if(pn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");pn=!0;const s=e._roots,a=t._roots;let r,o=0,l=0;const u=new we().copy(n).invert();for(let c=0,d=s.length;c<d;c++){vt.setBuffer(s[c]),l=0;const f=Me.getPrimitive();X(0,vt.float32Array,f),f.applyMatrix4(u);for(let p=0,x=a.length;p<x&&($t.setBuffer(a[c]),r=ue(0,0,n,u,i,o,l,0,0,f),$t.clearBuffer(),l+=a[p].length,!r);p++);if(Me.releasePrimitive(f),vt.clearBuffer(),o+=s[c].length,r)break}return pn=!1,r}function ue(e,t,n,i,s,a=0,r=0,o=0,l=0,u=null,c=!1){let d,f;c?(d=$t,f=vt):(d=vt,f=$t);const p=d.float32Array,x=d.uint32Array,w=d.uint16Array,S=f.float32Array,g=f.uint32Array,m=f.uint16Array,h=e*2,A=t*2,T=J(h,w),M=J(A,m);let _=!1;if(M&&T)c?_=s(ee(t,g),re(t*2,m),ee(e,x),re(e*2,w),l,r+t,o,a+e):_=s(ee(e,x),re(e*2,w),ee(t,g),re(t*2,m),o,a+e,l,r+t);else if(M){const v=Me.getPrimitive();X(t,S,v),v.applyMatrix4(n);const y=ae(e),b=oe(e,x);X(y,p,We),X(b,p,Xe);const P=v.intersectsBox(We),E=v.intersectsBox(Xe);_=P&&ue(t,y,i,n,s,r,a,l,o+1,v,!c)||E&&ue(t,b,i,n,s,r,a,l,o+1,v,!c),Me.releasePrimitive(v)}else{const v=ae(t),y=oe(t,g);X(v,S,dn),X(y,S,hn);const b=u.intersectsBox(dn),P=u.intersectsBox(hn);if(b&&P)_=ue(e,v,n,i,s,a,r,o,l+1,u,c)||ue(e,y,n,i,s,a,r,o,l+1,u,c);else if(b)if(T)_=ue(e,v,n,i,s,a,r,o,l+1,u,c);else{const E=Me.getPrimitive();E.copy(dn).applyMatrix4(n);const R=ae(e),D=oe(e,x);X(R,p,We),X(D,p,Xe);const L=E.intersectsBox(We),j=E.intersectsBox(Xe);_=L&&ue(v,R,i,n,s,r,a,l,o+1,E,!c)||j&&ue(v,D,i,n,s,r,a,l,o+1,E,!c),Me.releasePrimitive(E)}else if(P)if(T)_=ue(e,y,n,i,s,a,r,o,l+1,u,c);else{const E=Me.getPrimitive();E.copy(hn).applyMatrix4(n);const R=ae(e),D=oe(e,x);X(R,p,We),X(D,p,Xe);const L=E.intersectsBox(We),j=E.intersectsBox(Xe);_=L&&ue(y,R,i,n,s,r,a,l,o+1,E,!c)||j&&ue(y,D,i,n,s,r,a,l,o+1,E,!c),Me.releasePrimitive(E)}}return _}const It=new Q,pi=new ge,nl={strategy:Fi,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class Vn{static serialize(t,n={}){n={cloneBuffers:!0,...n};const i=t.geometry,s=t._roots,a=t._indirectBuffer,r=i.getIndex();let o;return n.cloneBuffers?o={roots:s.map(l=>l.slice()),index:r?r.array.slice():null,indirectBuffer:a?a.slice():null}:o={roots:s,index:r?r.array:null,indirectBuffer:a},o}static deserialize(t,n,i={}){i={setIndex:!0,indirect:!!t.indirectBuffer,...i};const{index:s,roots:a,indirectBuffer:r}=t,o=new Vn(n,{...i,[rn]:!0});if(o._roots=a,o._indirectBuffer=r||null,i.setIndex){const l=n.getIndex();if(l===null){const u=new me(t.index,1,!1);n.setIndex(u)}else l.array!==s&&(l.array.set(s),l.needsUpdate=!0)}return o}get indirect(){return!!this._indirectBuffer}constructor(t,n={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(n=Object.assign({...nl,[rn]:!1},n),n.useSharedArrayBuffer&&!el())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,n[rn]||(yo(this,n),!t.boundingBox&&n.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new ge)));const{_indirectBuffer:i}=this;this.resolveTriangleIndex=n.indirect?s=>i[s]:s=>s}refit(t=null){return(this.indirect?jo:Ro)(this,t)}traverse(t,n=0){const i=this._roots[n],s=new Uint32Array(i),a=new Uint16Array(i);r(0);function r(o,l=0){const u=o*2,c=a[u+15]===Jt;if(c){const d=s[o+6],f=a[u+14];t(l,c,new Float32Array(i,o*4,6),d,f)}else{const d=o+mt/4,f=s[o+6],p=s[o+7];t(l,c,new Float32Array(i,o*4,6),p)||(r(d,l+1),r(f,l+1))}}}raycast(t,n=wn){const i=this._roots,s=this.geometry,a=[],r=n.isMaterial,o=Array.isArray(n),l=s.groups,u=r?n.side:n,c=this.indirect?$o:Lo;for(let d=0,f=i.length;d<f;d++){const p=o?n[l[d].materialIndex].side:u,x=a.length;if(c(this,d,p,t,a),o){const w=l[d].materialIndex;for(let S=x,g=a.length;S<g;S++)a[S].face.materialIndex=w}}return a}raycastFirst(t,n=wn){const i=this._roots,s=this.geometry,a=n.isMaterial,r=Array.isArray(n);let o=null;const l=s.groups,u=a?n.side:n,c=this.indirect?Xo:Io;for(let d=0,f=i.length;d<f;d++){const p=r?n[l[d].materialIndex].side:u,x=c(this,d,p,t);x!=null&&(o==null||x.distance<o.distance)&&(o=x,r&&(x.face.materialIndex=l[d].materialIndex))}return o}intersectsGeometry(t,n){let i=!1;const s=this._roots,a=this.indirect?qo:Oo;for(let r=0,o=s.length;r<o&&(i=a(this,r,t,n),!i);r++);return i}shapecast(t){const n=le.getPrimitive(),i=this.indirect?Do:Bo;let{boundsTraverseOrder:s,intersectsBounds:a,intersectsRange:r,intersectsTriangle:o}=t;if(r&&o){const d=r;r=(f,p,x,w,S)=>d(f,p,x,w,S)?!0:i(f,p,this,o,x,w,n)}else r||(o?r=(d,f,p,x)=>i(d,f,this,o,p,x,n):r=(d,f,p)=>p);let l=!1,u=0;const c=this._roots;for(let d=0,f=c.length;d<f;d++){const p=c[d];if(l=Ao(this,d,a,r,s,u),l)break;u+=p.byteLength}return le.releasePrimitive(n),l}bvhcast(t,n,i){let{intersectsRanges:s,intersectsTriangles:a}=i;const r=le.getPrimitive(),o=this.geometry.index,l=this.geometry.attributes.position,u=this.indirect?x=>{const w=this.resolveTriangleIndex(x);Y(r,w*3,o,l)}:x=>{Y(r,x*3,o,l)},c=le.getPrimitive(),d=t.geometry.index,f=t.geometry.attributes.position,p=t.indirect?x=>{const w=t.resolveTriangleIndex(x);Y(c,w*3,d,f)}:x=>{Y(c,x*3,d,f)};if(a){const x=(w,S,g,m,h,A,T,M)=>{for(let _=g,v=g+m;_<v;_++){p(_),c.a.applyMatrix4(n),c.b.applyMatrix4(n),c.c.applyMatrix4(n),c.needsUpdate=!0;for(let y=w,b=w+S;y<b;y++)if(u(y),r.needsUpdate=!0,a(r,c,y,_,h,A,T,M))return!0}return!1};if(s){const w=s;s=function(S,g,m,h,A,T,M,_){return w(S,g,m,h,A,T,M,_)?!0:x(S,g,m,h,A,T,M,_)}}else s=x}return tl(this,t,n,s)}intersectsBox(t,n){return It.set(t.min,t.max,n),It.needsUpdate=!0,this.shapecast({intersectsBounds:i=>It.intersectsBox(i),intersectsTriangle:i=>It.intersectsTriangle(i)})}intersectsSphere(t){return this.shapecast({intersectsBounds:n=>t.intersectsBox(n),intersectsTriangle:n=>n.intersectsSphere(t)})}closestPointToGeometry(t,n,i={},s={},a=0,r=1/0){return(this.indirect?Jo:Go)(this,t,n,i,s,a,r)}closestPointToPoint(t,n={},i=0,s=1/0){return _o(this,t,n,i,s)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(i=>{X(0,new Float32Array(i),pi),t.union(pi)}),t}}function mi(e,t,n){return e===null||(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(n.ray.origin),e.object=t,e.distance<n.near||e.distance>n.far)?null:e}const mn=new Es,vi=new we,il=Yt.prototype.raycast;function sl(e,t){if(this.geometry.boundsTree){if(this.material===void 0)return;vi.copy(this.matrixWorld).invert(),mn.copy(e.ray).applyMatrix4(vi);const n=this.geometry.boundsTree;if(e.firstHitOnly===!0){const i=mi(n.raycastFirst(mn,this.material),this,e);i&&t.push(i)}else{const i=n.raycast(mn,this.material);for(let s=0,a=i.length;s<a;s++){const r=mi(i[s],this,e);r&&t.push(r)}}}else il.call(this,e,t)}function rl(e){return this.boundsTree=new Vn(this,e),this.boundsTree}function al(){this.boundsTree=null}function ol({modelInCopy:e}){const t=new ht({color:15461355});var n=new kt({color:10921638,linewidth:10});const i=new ve(zi);return i.uniforms.diffuse.value.set(0),C.useEffect(()=>{const s=[];e.traverse(a=>{if(a.frustumCulled=!0,a.isMesh){a.material=t,a.frustumCulled=!1;var r=new Ye(a.geometry,20),o=new De(r,n);s.push(a.geometry);const l=new Cs(Ms(a.geometry)),u=new De(l,i);a.add(o),a.add(u),r.dispose(),a.geometry.dispose(),t.dispose()}})},[]),z(K,{children:z("primitive",{object:e,scale:1})})}fe.memo(ol);new Us;const ll={linewidth:{value:1},resolution:{value:new Is(1,1)},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1},opacity:{value:1}},vn={uniforms:Di.merge([Qn.common,Qn.fog,ll]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 control0;
		attribute vec3 control1;
		attribute vec3 direction;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		varying vec2 vUv;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = resolution.x / resolution.y;

			vUv = uv;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec2 ndcStart = clipStart.xy / clipStart.w;
			vec2 ndcEnd = clipEnd.xy / clipEnd.w;

			// direction
			vec2 dir = ndcEnd - ndcStart;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			// perpendicular to dir
			vec2 offset = vec2( dir.y, - dir.x );

			// undo aspect ratio adjustment
			dir.x /= aspect;
			offset.x /= aspect;

			// sign flip
			if ( position.x < 0.0 ) offset *= - 1.0;

			// endcaps
			if ( position.y < 0.0 ) {

				offset += - dir;

			} else if ( position.y > 1.0 ) {

				offset += dir;

			}

			// adjust for linewidth
			offset *= linewidth;

			// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
			offset /= resolution.y;

			// select end
			vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

			// back to clip space
			offset *= clip.w;

			clip.xy += offset;

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

			// conditional logic
			// Transform the line segment ends and control points into camera clip space
			vec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );
			vec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );
			vec4 p0 = projectionMatrix * modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 p1 = projectionMatrix * modelViewMatrix * vec4( instanceStart + direction, 1.0 );

			c0 /= c0.w;
			c1 /= c1.w;
			p0 /= p0.w;
			p1 /= p1.w;

			// Get the direction of the segment and an orthogonal vector
			vec2 segDir = p1.xy - p0.xy;
			vec2 norm = vec2( - segDir.y, segDir.x );

			// Get control point directions from the line
			vec2 c0dir = c0.xy - p1.xy;
			vec2 c1dir = c1.xy - p1.xy;

			// If the vectors to the controls points are pointed in different directions away
			// from the line segment then the line should not be drawn.
			float d0 = dot( normalize( norm ), normalize( c0dir ) );
			float d1 = dot( normalize( norm ), normalize( c1dir ) );
			float discardFlag = float( sign( d0 ) != sign( d1 ) );
			gl_Position = discardFlag > 0.5 ? c0 : gl_Position;
			// end conditional line logic

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;

		#ifdef USE_DASH

			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		varying vec2 vUv;

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			if ( abs( vUv.y ) > 1.0 ) {

				float a = vUv.x;
				float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
				float len2 = a * a + b * b;

				if ( len2 > 1.0 ) discard;

			}

			vec4 diffuseColor = vec4( diffuse, opacity );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};class cl extends Os{constructor(t){super({type:"ConditionalLineMaterial",uniforms:Di.clone(vn.uniforms),vertexShader:vn.vertexShader,fragmentShader:vn.fragmentShader,clipping:!0}),this.dashed=!1,Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(n){this.uniforms.diffuse.value=n}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(n){this.uniforms.linewidth.value=n}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(n){this.uniforms.dashScale.value=n}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(n){this.uniforms.dashSize.value=n}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(n){this.uniforms.gapSize.value=n}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(n){this.uniforms.opacity.value=n}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(n){this.uniforms.resolution.value.copy(n)}}}),this.setValues(t)}}cl.prototype.isConditionalLineMaterial=!0;Ps({OutlineEffect:js});const gn=[],yn=[];function ul({modelIn:e,modelOut:t,modelInCopy:n,modelInCopy2:i,modelOutCopy:s}){Gt.prototype.computeBoundsTree=rl,Gt.prototype.disposeBoundsTree=al,Yt.prototype.raycast=sl,console.log("render count");const{gl:a,camera:r,scene:o}=Ln(),l=C.useRef(),u=C.useRef();C.useRef(),C.useRef(),C.useRef(),a.setPixelRatio(Math.min(window.devicePixelRatio,2));let{stepCount:c,modelProperties:d,partsInOut:f,setVisibleModel:p,setCurrentStepObj:x,currentStepObject:w,selectedParts:S,setProperties:g,cameraPosition:m}=C.useContext(de);const[h,A]=C.useState(!1),[T,M]=C.useState(!1),[_,v]=C.useState(i),[y,b]=C.useState(),[P,E]=C.useState(n),[R,D]=C.useState(i),[L,j]=C.useState();C.useState(),C.useState();const[ie,ye]=C.useState(),[$,St]=C.useState(),tt=new ht({color:15461355}),ze=new ht({color:16777215}),bt=new ht({color:16711680,wireframe:!0}),Gn=new ht({color:13754592});var wt=new kt({color:4210752,linewidth:10}),jn=new kt({color:6723993,linewidth:50}),Qi=new kt({color:10921638,linewidth:10});new ve(zi).uniforms.diffuse.value.set(0);const $n=["291_Prepare_the_Fillet_Profile"],nt=[["091_Bed_Frame","092_Bed_Legs","093_Bed_Lamella"],["141_Preparing_the_X-axis_1","142_Preparing_the_X-axis_2","143_Preparing_the_X-axis_3"],["301_Prepare_Window_1","302_Prepare_the_Window_2"]],Ji=["131_Wiring_DC","132_Wiring_AC","271_Wiring_DC_2"],Wn=[];let Xn=[],it=[];C.useEffect(()=>{f===!0?(v(i),St(i.getObjectByName(h[c]))):f===!1&&(v(s),St(s.getObjectByName(h[c])))},[f]),C.useEffect(()=>{_.traverse(B=>{B.isObject3D&&!B.isMesh&&!B.isGroup&&(gn.push(B.name),yn.push(B.userData.name))}),gn.sort(),A(gn),yn.sort(),M(yn),R.traverse(B=>{if(B.frustumCulled=!0,B.isMesh){B.frustumCulled=!1,B.material=ze,ze.dispose();var I=new Ye(B.geometry,20),U=new De(I,wt);B.add(U),I.dispose(),B.geometry.dispose(),ze.dispose(),B.userData.name==="Curves"&&(B.material=bt,bt.dispose()),B.geometry.dispose()}}),s.traverse(B=>{if(B.frustumCulled=!0,B.isMesh&&B.parent.userData.name!="Curves"){B.frustumCulled=!1,B.material=ze,ze.dispose();var I=new Ye(B.geometry,20),U=new De(I,wt);B.add(U),I.dispose(),B.geometry.dispose(),ze.dispose(),B.geometry.dispose()}if(B.userData.name==="Curves"&&(B.material=bt,B.isGroup))for(let G=0;G<B.children.length;G++)B.children[G].isMesh&&(B.children[G].material=bt)}),P.traverse(B=>{if(B.isMesh){B.material=tt,B.frustumCulled=!1;var I=new Ye(B.geometry,20),U=new De(I,Qi);B.add(U),I.dispose(),B.geometry.dispose(),tt.dispose()}}),x(n.getObjectByName(h[0])),St(_.getObjectByName(h[0])),qn()},[]);const es=$n.some(B=>B.includes(h[c])),ts=nt.some(B=>B.includes(h[c]));te(B=>B.wiringStep);const ns=te(B=>B.isWiringStep),is=te(B=>B.isNotWiringStep);Ji.some(B=>B.includes(h[c]))?ns():is(),C.useEffect(()=>{x(n.getObjectByName(h[c])),St(_.getObjectByName(h[c]))},[h,c]),C.useEffect(()=>{qn()},[h,c,w]),C.useEffect(()=>{$&&S!=[]&&os()},[S,$]);const qn=C.useCallback(()=>{let B=[],I=[];const U=[];if(w){for(let Ie=0;Ie<w.children.length;Ie++)w.children[Ie].traverse(Ne=>{Ne.isGroup&&Ne.userData.name!=null&&U.push(Ne.userData.name),B=[...new Set(U)],I=B.map(Tt=>[U.filter(us=>us===Tt).length,Tt])});const G=w.userData.name;g({partsNames:I,titleName:G})}}),ss=C.useCallback(()=>{for(let B=c-1;B>=0;B--)for(let I=it.length-1;I>=0;I--)if(h[B]===it[I]){let U=P.getObjectByName(`${h[B]}`,!0);Xn.push(U)}}),rs=C.useCallback(()=>{for(let U=0;U<nt.length;U++){it=nt[U];for(let G=0;G<it.length;G++)it.some(Ne=>Ne.includes(h[c]))&&ss()}let B=new jt,I=$.clone();B.add(I),Xn.filter(U=>nt.some(G=>G.includes(U.name))).forEach(U=>{U.visible=!0;let G=U.clone();B.add(G)}),p(B)}),as=C.useCallback(()=>{for(let U=c-1;U>=0;U--){let G=P.getObjectByName(`${h[U]}`,!0);Wn.push(G)}let B=new jt,I=$.clone();B.add(I),Wn.filter(U=>!$n.some(G=>G.includes(U.name))&&!nt.some(G=>G.includes(U.name))).forEach(U=>{U.visible=!0;let G=U.clone();B.add(G)}),p(B)}),os=C.useCallback(()=>{if($){const B=[];for(let I=0;I<$.children.length;I++)$.children[I].traverse(U=>{if(U.isMesh&&S.includes($.children[I].userData.name)){const Tt=U.geometry.clone();B.push(Tt),U.material=Gn;var G=new Ye(U.geometry,20),Ie=new De(G,jn);U.add(Ie),Gn.dispose(),G.dispose(),jn.dispose()}else if(U.isMesh&&$.children[I].userData.name!="Curves"){U.material=ze;var G=new Ye(U.geometry,20),Ne=new De(G,wt);U.add(Ne),G.dispose(),wt.dispose()}});ye(S)}});C.useCallback(()=>{L.traverse(B=>{B.name==="Botom_Panel"&&console.log(L.userData.name)})}),C.useCallback(B=>{B.stopPropagation(),console.log(B.object)});const ls=C.useCallback(()=>{if($){const B=$.clone();b(B),B.traverse(I=>{I.isMesh&&(tt.side=Le,tt.color.set(0),I.material=tt,I.scale.multiplyScalar(1.005))});for(let I=0;I<_.children.length;I++)_.children[I].visible=!1;for(let I=0;I<P.children.length;I++)P.children[I].visible=!1;es?(console.log("exception"),$.visible=!0,p($)):ts?(console.log("preparing step"),$.visible=!0,rs()):(console.log("main building step"),$.visible=!0,as())}},[$]);C.useEffect(()=>{ls()},[$]);const{setListOfStep:cs}=C.useContext(de);return cs(T),C.useState(null),z(K,{children:V($s,{children:[h?V(K,{children:[z("primitive",{ref:l,object:_,scale:1.0001}),z("primitive",{ref:u,object:P,scale:1})]}):null,V(fa,{multisampling:8,autoClear:!1,children:[z(da,{selection:_.scene,blendFunction:k.ALPHA,selectionLayer:1,blur:!0,visibleEdgeColor:65280,hiddenEdgeColor:65280,edgeStrength:50,width:1e3,height:1e3,xRay:!0}),z(Ja,{})]})]})})}const fl=fe.memo(ul);function dl(){let e=[],t=new jt;const{modelProperties:n,visibleObj:i,currentStepObject:s,setClickedParts:a,selectedParts:r,partsInOut:o,setCurrentPartsModel:l}=C.useContext(de),[u,c]=C.useState(null),[d,f]=C.useState(!1),[p,x]=C.useState(!1),w=te(m=>m.wiringStep),S=C.useCallback(()=>{if(t=new jt,e=[],u){for(let m=0;m<s.children.length;m++)if(s.children[m].userData.name===u){const h=s.children[m].clone();t.add(h),e.push(s.children[m].userData.name)}a(e),l(t)}});C.useEffect(()=>{e=[],a(e),S()},[s,u]),C.useEffect(()=>{f(!1),e=[],a(e),l(null)},[s]);const g=()=>{d===!0&&(f(!1),e=[],a(e),l(null)),d===!1&&(f(!0),S())};return z(K,{children:z("div",{children:z("ul",{children:n?n.partsNames.map(([m,h],A)=>z("li",{children:h===u&&d===!0?V("button",{id:`${h}`,style:{backgroundColor:"#669999",color:"#ffffff"},disabled:p,onClick:()=>{g()},className:"parts",children:[V("b",{children:[" ",m,"x"]}),"  ",h]}):w?V("p",{style:{paddingBottom:10},children:[V("b",{children:[" ",m,"x"]}),"  ",h]}):V("button",{id:`${h}`,disabled:p,onClick:()=>{c(h),g()},className:"parts",children:[V("b",{children:[" ",m,"x"]}),"  ",h]})},A)):null})})})}function hl(){const{modelProperties:e}=C.useContext(de);return z(K,{children:z("div",{children:e?e.titleName:null})})}function pl(){const{stepList:e,setStepPosition:t,stepCount:n,currentStepName:i,modelProperties:s}=C.useContext(de);C.useState("stepNaviBtn");const[a,r]=C.useState();return e&&[...Array(e.length)],z("div",{children:z("ul",{children:e?e.map((o,l)=>z("li",{children:s&&o===s.titleName?z("button",{id:`${o}`,style:{backgroundColor:"#000000",color:"#ffffff"},onClick:()=>{t(l)},className:"stepNaviBtn",children:o}):z("button",{id:`${o}`,style:{backgroundColor:a},onClick:()=>{t(l)},className:"stepNaviBtn",children:o})},l)):null})})}const ml=fe.memo(pl);function vl({cameraControlsRef:e}){let{visibleObj:t,modelProperties:n,selectedPartsModel:i,currentStepObject:s,setCamera:a}=C.useContext(de);const r=Ni(),o=te(l=>l.cameraPositionTag);C.useEffect(()=>{t?r.refresh(t).fit():r.refresh(s).fit()},[s,o]),C.useEffect(()=>{i?r.refresh(i).fit():i||r.refresh(t).fit()},[i])}let Dn=1,Wi=new Array;new Array;let xn=new Array,Ot;Un.get("https://sheets.googleapis.com/v4/spreadsheets/18hHq4XYLPYSN1Wc0RjY5zl5vCHoVVrlugpG-O7cULLw/values/Workbook?key=AIzaSyCqcO7MQv4dsj76ps3nNJnMwTT8Cvqv-eM").then(e=>{let t=e.data.values,n=new Array;for(const i of t)Dn>2&&i[1]!=""&&(Wi.push(n),n=new Array),n.push(i),++Dn});function gl(){let{stepCount:e}=C.useContext(de);return C.useEffect(()=>{Ot=new Array;for(const t of Wi[e+1])t[10]!=""&&t[10]!=null&&(xn=new Array,xn.push(t[10]),Ot.push(xn)),++Dn},[e]),z(K,{children:z("div",{children:z("ul",{children:Ot?Ot.map((t,n)=>V("li",{children:[" ",t]},n)):null})})})}/**
  * react-collapsed v4.1.2
  *
  * Copyright (c) 2019-2023, Rogin Farrer
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE.md file in the root directory of this source tree.
  *
  * @license MIT
  */var yl=class extends Error{constructor(e){super(`react-collapsed: ${e}`)}},Wt=(...e)=>(e[0],`${e[1]}`,void 0);function Xi(e){const t=C.useRef(e);return C.useEffect(()=>{t.current=e}),C.useCallback((...n)=>{var i;return(i=t.current)==null?void 0:i.call(t,...n)},[])}function xl(e,t,n){const[i,s]=C.useState(t),a=C.useRef(typeof e<"u"),r=a.current?e:i,o=Xi(n),l=C.useCallback(u=>{const d=typeof u=="function"?u(r):u;a.current||s(d),o==null||o(d)},[o,r]);return C.useEffect(()=>{Wt(!(a.current&&e==null),"`isExpanded` state is changing from controlled to uncontrolled. useCollapse should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop."),Wt(!(!a.current&&e!=null),"`isExpanded` state is changing from uncontrolled to controlled. useCollapse should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop.")},[e]),[r,l]}var Sl="(prefers-reduced-motion: reduce)";function bl(){const[e,t]=C.useState(!1);return C.useEffect(()=>{if(typeof window>"u"||typeof window.matchMedia!="function")return;const n=window.matchMedia(Sl);t(n.matches);const i=s=>{t(s.matches)};if(n.addEventListener)return n.addEventListener("change",i),()=>{n.removeEventListener("change",i)};if(n.addListener)return n.addListener(i),()=>{n.removeListener(i)}},[]),e}var wl=Bs["useId".toString()]||(()=>{});function Tl(){return wl()??""}var Al=typeof window<"u"?C.useLayoutEffect:C.useEffect,Sn=!1,_l=0,gi=()=>++_l;function El(e){const t=e||(Sn?gi():null),[n,i]=C.useState(t);return Al(()=>{n===null&&i(gi())},[]),C.useEffect(()=>{Sn===!1&&(Sn=!0)},[]),n!=null?String(n):void 0}function Cl(e){const t=Tl(),n=El(e);return typeof e=="string"?e:typeof t=="string"?t:n}function Ml(e,t){const n=performance.now(),i={};function s(){i.id=requestAnimationFrame(a=>{a-n>t?e():s()})}return s(),i}function yi(e){e.id&&cancelAnimationFrame(e.id)}function xi(e){return e!=null&&e.current?e.current.scrollHeight:(Wt(!0,"Was not able to find a ref to the collapse element via `getCollapseProps`. Ensure that the element exposes its `ref` prop. If it exposes the ref prop under a different name (like `innerRef`), use the `refKey` property to change it. Example:\n\nconst collapseProps = getCollapseProps({refKey: 'innerRef'})"),0)}function Pl(e){if(!e||typeof e=="string")return 0;const t=e/36;return Math.round((4+15*t**.25+t/5)*10)}function Bl(e,t){if(e!=null)if(typeof e=="function")e(t);else try{e.current=t}catch{throw new yl(`Cannot assign value "${t}" to ref "${e}"`)}}function Si(...e){return e.every(t=>t==null)?null:t=>{e.forEach(n=>{Bl(n,t)})}}function Rl(e){let t=n=>{};t=n=>{if(!(n!=null&&n.current))return;const{paddingTop:i,paddingBottom:s}=window.getComputedStyle(n.current);Wt(!(i&&i!=="0px"||s&&s!=="0px"),`Padding applied to the collapse element will cause the animation to break and not perform as expected. To fix, apply equivalent padding to the direct descendent of the collapse element. Example:

Before:   <div {...getCollapseProps({style: {padding: 10}})}>{children}</div>

After:   <div {...getCollapseProps()}>
             <div style={{padding: 10}}>
                 {children}
             </div>
          </div>`)},C.useEffect(()=>{t(e)},[e])}var zl=typeof window>"u"?C.useEffect:C.useLayoutEffect;function Nl({duration:e,easing:t="cubic-bezier(0.4, 0, 0.2, 1)",onTransitionStateChange:n=()=>{},isExpanded:i,defaultExpanded:s=!1,hasDisabledAnimation:a,id:r,...o}={}){const l=Xi(n),u=Cl(r?`${r}`:void 0),[c,d]=xl(i,s),f=C.useRef(c),[p,x]=C.useState(!1),w=bl(),S=a??w,g=C.useRef(),m=C.useRef(),h=C.useRef(null),[A,T]=C.useState(null);Rl(h);const M=`${o.collapsedHeight||0}px`;function _(v){if(!h.current)return;const y=h.current;for(const b in v){const P=v[b];P?y.style[b]=P:y.style.removeProperty(b)}}return zl(()=>{if(!h.current||c===f.current)return;f.current=c;function y(E){return S?0:e??Pl(E)}const b=E=>`height ${y(E)}ms ${t}`,P=E=>{function R(){c?(_({height:"",overflow:"",transition:"",display:""}),l("expandEnd")):(_({transition:""}),l("collapseEnd")),x(!1)}m.current&&yi(m.current),m.current=Ml(R,E)};return x(!0),c?g.current=requestAnimationFrame(()=>{l("expandStart"),_({display:"block",overflow:"hidden",height:M}),g.current=requestAnimationFrame(()=>{l("expanding");const E=xi(h);P(y(E)),h.current&&(h.current.style.transition=b(E),h.current.style.height=`${E}px`)})}):g.current=requestAnimationFrame(()=>{l("collapseStart");const E=xi(h);P(y(E)),_({transition:b(E),height:`${E}px`}),g.current=requestAnimationFrame(()=>{l("collapsing"),_({height:M,overflow:"hidden"})})}),()=>{g.current&&cancelAnimationFrame(g.current),m.current&&yi(m.current)}},[c,M,S,e,t,l]),{isExpanded:c,setExpanded:d,getToggleProps(v){const{disabled:y,onClick:b,refKey:P,...E}={refKey:"ref",onClick(){},disabled:!1,...v},R=A?A.tagName==="BUTTON":void 0,D=v==null?void 0:v[P||"ref"],L={id:`react-collapsed-toggle-${u}`,"aria-controls":`react-collapsed-panel-${u}`,"aria-expanded":c,onClick(ye){y||(b==null||b(ye),d($=>!$))},[P||"ref"]:Si(D,T)},j={type:"button",disabled:y?!0:void 0},ie={"aria-disabled":y?!0:void 0,role:"button",tabIndex:y?-1:0};return R===!1?{...L,...ie,...E}:R===!0?{...L,...j,...E}:{...L,...j,...ie,...E}},getCollapseProps(v){const{style:y,refKey:b}={refKey:"ref",style:{},...v},P=v==null?void 0:v[b||"ref"];return{id:`react-collapsed-panel-${u}`,"aria-hidden":!c,"aria-labelledby":`react-collapsed-toggle-${u}`,role:"region",...v,[b||"ref"]:Si(h,P),style:{boxSizing:"border-box",...!p&&!c?{display:M==="0px"?"none":"block",height:M,overflow:"hidden"}:{},...y}}}}}var qi={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},bi=fe.createContext&&fe.createContext(qi),Dl=["attr","size","title"];function Ll(e,t){if(e==null)return{};var n=Ul(e,t),i,s;if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)i=a[s],!(t.indexOf(i)>=0)&&Object.prototype.propertyIsEnumerable.call(e,i)&&(n[i]=e[i])}return n}function Ul(e,t){if(e==null)return{};var n={},i=Object.keys(e),s,a;for(a=0;a<i.length;a++)s=i[a],!(t.indexOf(s)>=0)&&(n[s]=e[s]);return n}function Xt(){return Xt=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i])}return e},Xt.apply(this,arguments)}function wi(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(e,s).enumerable})),n.push.apply(n,i)}return n}function qt(e){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?arguments[t]:{};t%2?wi(Object(n),!0).forEach(function(i){Il(e,i,n[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):wi(Object(n)).forEach(function(i){Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(n,i))})}return e}function Il(e,t,n){return t=Ol(t),t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function Ol(e){var t=kl(e,"string");return typeof t=="symbol"?t:String(t)}function kl(e,t){if(typeof e!="object"||e===null)return e;var n=e[Symbol.toPrimitive];if(n!==void 0){var i=n.call(e,t||"default");if(typeof i!="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(e)}function Yi(e){return e&&e.map((t,n)=>fe.createElement(t.tag,qt({key:n},t.attr),Yi(t.child)))}function xt(e){return t=>fe.createElement(Fl,Xt({attr:qt({},e.attr)},t),Yi(e.child))}function Fl(e){var t=n=>{var{attr:i,size:s,title:a}=e,r=Ll(e,Dl),o=s||n.size||"1em",l;return n.className&&(l=n.className),e.className&&(l=(l?l+" ":"")+e.className),fe.createElement("svg",Xt({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},n.attr,i,r,{className:l,style:qt(qt({color:e.color||n.color},n.style),e.style),height:o,width:o,xmlns:"http://www.w3.org/2000/svg"}),a&&fe.createElement("title",null,a),e.children)};return bi!==void 0?fe.createElement(bi.Consumer,null,n=>t(n)):t(qi)}function Hl(e){return xt({tag:"svg",attr:{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round"},child:[{tag:"circle",attr:{cx:"12",cy:"12",r:"10"},child:[]},{tag:"line",attr:{x1:"12",x2:"12",y1:"8",y2:"12"},child:[]},{tag:"line",attr:{x1:"12",x2:"12.01",y1:"16",y2:"16"},child:[]}]})(e)}function Vl(e){return xt({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M0 0h24v24H0z"},child:[]},{tag:"path",attr:{d:"m18.25 7.6-5.5-3.18a1.49 1.49 0 0 0-1.5 0L5.75 7.6c-.46.27-.75.76-.75 1.3v6.35c0 .54.29 1.03.75 1.3l5.5 3.18c.46.27 1.04.27 1.5 0l5.5-3.18c.46-.27.75-.76.75-1.3V8.9c0-.54-.29-1.03-.75-1.3zM7 14.96v-4.62l4 2.32v4.61l-4-2.31zm5-4.03L8 8.61l4-2.31 4 2.31-4 2.32zm1 6.34v-4.61l4-2.32v4.62l-4 2.31zM7 2H3.5C2.67 2 2 2.67 2 3.5V7h2V4h3V2zm10 0h3.5c.83 0 1.5.67 1.5 1.5V7h-2V4h-3V2zM7 22H3.5c-.83 0-1.5-.67-1.5-1.5V17h2v3h3v2zm10 0h3.5c.83 0 1.5-.67 1.5-1.5V17h-2v3h-3v2z"},child:[]}]})(e)}function Gl(e){return xt({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M0 0h24v24H0V0z"},child:[]},{tag:"path",attr:{d:"m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14l-6-6z"},child:[]}]})(e)}function jl(e){return xt({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M24 24H0V0h24v24z",opacity:".87"},child:[]},{tag:"path",attr:{d:"M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z"},child:[]}]})(e)}function Ti(e){return xt({tag:"svg",attr:{viewBox:"0 0 1024 1024"},child:[{tag:"path",attr:{d:"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"},child:[]},{tag:"path",attr:{d:"M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0 1 30.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1 0 80 0 40 40 0 1 0-80 0z"},child:[]}]})(e)}let gt=1,Ki=new Array,qe=new Array;Un.get("https://sheets.googleapis.com/v4/spreadsheets/18hHq4XYLPYSN1Wc0RjY5zl5vCHoVVrlugpG-O7cULLw/values/Workbook?key=AIzaSyCqcO7MQv4dsj76ps3nNJnMwTT8Cvqv-eM").then(e=>{let t=e.data.values,n=new Array;for(const i of t)gt>2&&i[1]!=""&&(Ki.push(n),n=new Array),n.push(i),++gt});function $l(){const[e,t]=C.useState(),[n,i]=C.useState(),[s,a]=C.useState(),r=te(p=>p.isNotVisibleToggle),o=te(p=>p.isVisibleToggle);te(p=>p.isVisible);let{stepCount:l,howToData:u,setHowToWorkbook:c,setClickedPath:d,path:f}=C.useContext(de);return C.useEffect(()=>{let p=new Array;Un.get("https://sheets.googleapis.com/v4/spreadsheets/1grTucZ2sqLgZ4AtJq8EkyO__kLg-pazRVl3sbLNMaIY/values/Blad1?key=AIzaSyCqcO7MQv4dsj76ps3nNJnMwTT8Cvqv-eM").then(x=>{let w=x.data.values,S=new Array,g=[];for(const m of w)gt>0&&m[0]!=""?(S=new Array,S.push(m),p.push(S)):S.push(m),++gt;c(p);for(const m of p)m[0]!=""&&(qe=new Array,qe.push(m[0][0],m[0][1]),g.push(qe));a(g)})},[]),C.useEffect(()=>{let p=new Array;for(const x of Ki[l+1])x[12]!=""&&x[12]!=null&&(qe=new Array,qe.push(x[12]),p.push(qe)),++gt;t(p)},[l]),C.useEffect(()=>{let p=[];if(s!=null){for(const x of e)for(const w of s)w.includes(`${x}`)&&p.push(w);i(p),e.length===0?r():o()}},[s,e]),z(K,{children:z("div",{children:z("ul",{children:n?n.map((p,x)=>V("li",{children:[z(Rs,{to:`/HowTo/${p[0]}`,target:"_blank",rel:"noopener noreferrer",children:V("button",{type:"button",className:"stepNaviBtn",children:[p[0],". ",p[1]]})})," "]},x)):null})})})}function Wl(){const e=C.useRef(),[t,n]=C.useState(!1),{getCollapseProps:i,getToggleProps:s}=Nl({isExpanded:t}),a=te(r=>r.isVisible);return V(K,{children:[z("button",{type:"button",...s({onClick:()=>n(r=>!r)}),className:t?"expanded":"btn",style:{position:"absolute",top:"20px",left:"20px",visibility:`${a}`},children:t?V(K,{children:[z(Ti,{})," How To ",z(Gl,{})]}):V(K,{children:[z(Ti,{})," How To ",z(jl,{})]})}),z("div",{ref:e,className:"howToBoxContent",...i(),children:z($l,{})})]})}function Xl(){let{visibleObj:e}=C.useContext(de);const t=te(o=>o.cameraPositionTag),n=te(o=>o.freeControls),i=Ni(),[s]=C.useState(()=>new N),[a]=C.useState(()=>new N),r=new N(4,1,8);return Bi((o,l)=>{t==="initial"&&(s.lerp(r,.1),a.lerp([0,0,0],.1),o.camera.position.copy(s),o.camera.lookAt(a),n(),i.refresh(e).fit())}),z(K,{})}(function(){var e="",t,n,i,s=[],a={passive:!0},r={passive:!1};window.addEventListener?(t="addEventListener",n="removeEventListener"):(t="attachEvent",n="detachEvent",e="on"),i="onwheel"in document.createElement("div")?"wheel":document.onmousewheel!==void 0?"mousewheel":"DOMMouseScroll";function o(x,w){var S=function(g){!g&&(g=window.event);var m={originalEvent:g,target:g.target||g.srcElement,type:"wheel",deltaMode:g.type=="MozMousePixelScroll"?0:1,deltaX:0,delatZ:0,preventDefault:function(){g.preventDefault?g.preventDefault():g.returnValue=!1}};return i=="mousewheel"?(m.deltaY=-.025*g.wheelDelta,g.wheelDeltaX&&(m.deltaX=-.025*g.wheelDeltaX)):m.deltaY=g.detail,w(m)};return s.push({element:x,fn:S}),S}function l(x){for(var w=0;w<s.length;w++)if(s[w].element===x)return s[w].fn;return function(){}}function u(x){for(var w=0;w<s.length;w++)if(s[w].element===x)return s.splice(w,1)}function c(x,w,S,g){var m;i==="wheel"?m=S:m=o(x,S),x[t](e+w,m,g?a:r)}function d(x,w,S,g){var m;i==="wheel"?m=S:m=l(x),x[n](e+w,m,g?a:r),u(x)}function f(x,w,S){c(x,i,w,S),i=="DOMMouseScroll"&&c(x,"MozMousePixelScroll",w,S)}function p(x,w,S){d(x,i,w,S),i=="DOMMouseScroll"&&d(x,"MozMousePixelScroll",w,S)}return{on:f,off:p}})();var ql={extend:function(e,t){e=e||{};for(var n in t)this.isObject(t[n])?e[n]=this.extend(e[n],t[n]):e[n]=t[n];return e},isElement:function(e){return e instanceof HTMLElement||e instanceof SVGElement||e instanceof SVGSVGElement||e&&typeof e=="object"&&e!==null&&e.nodeType===1&&typeof e.nodeName=="string"},isObject:function(e){return Object.prototype.toString.call(e)==="[object Object]"},isNumber:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},getSvg:function(e){var t,n;if(this.isElement(e))t=e;else if(typeof e=="string"||e instanceof String){if(t=document.querySelector(e),!t)throw new Error("Provided selector did not find any elements. Selector: "+e)}else throw new Error("Provided selector is not an HTML object nor String");if(t.tagName.toLowerCase()==="svg")n=t;else if(t.tagName.toLowerCase()==="object")n=t.contentDocument.documentElement;else if(t.tagName.toLowerCase()==="embed")n=t.getSVGDocument().documentElement;else throw t.tagName.toLowerCase()==="img"?new Error('Cannot script an SVG in an "img" element. Please use an "object" element or an in-line SVG.'):new Error("Cannot get SVG.");return n},proxy:function(e,t){return function(){return e.apply(t,arguments)}},getType:function(e){return Object.prototype.toString.apply(e).replace(/^\[object\s/,"").replace(/\]$/,"")},mouseAndTouchNormalize:function(e,t){if(e.clientX===void 0||e.clientX===null)if(e.clientX=0,e.clientY=0,e.touches!==void 0&&e.touches.length){if(e.touches[0].clientX!==void 0)e.clientX=e.touches[0].clientX,e.clientY=e.touches[0].clientY;else if(e.touches[0].pageX!==void 0){var n=t.getBoundingClientRect();e.clientX=e.touches[0].pageX-n.left,e.clientY=e.touches[0].pageY-n.top}}else e.originalEvent!==void 0&&e.originalEvent.clientX!==void 0&&(e.clientX=e.originalEvent.clientX,e.clientY=e.originalEvent.clientY)},isDblClick:function(e,t){if(e.detail===2)return!0;if(t!=null){var n=e.timeStamp-t.timeStamp,i=Math.sqrt(Math.pow(e.clientX-t.clientX,2)+Math.pow(e.clientY-t.clientY,2));return n<250&&i<10}return!1},now:Date.now||function(){return new Date().getTime()},throttle:function(e,t,n){var i=this,s,a,r,o=null,l=0;n||(n={});var u=function(){l=n.leading===!1?0:i.now(),o=null,r=e.apply(s,a),o||(s=a=null)};return function(){var c=i.now();!l&&n.leading===!1&&(l=c);var d=t-(c-l);return s=this,a=arguments,d<=0||d>t?(clearTimeout(o),o=null,l=c,r=e.apply(s,a),o||(s=a=null)):!o&&n.trailing!==!1&&(o=setTimeout(u,d)),r}},createRequestAnimationFrame:function(e){var t=null;return e!=="auto"&&e<60&&e>1&&(t=Math.floor(1e3/e)),t===null?window.requestAnimationFrame||Ai(33):Ai(t)}};function Ai(e){return function(t){window.setTimeout(t,e)}}var bn=ql,Zi="unknown";document.documentMode&&(Zi="ie");bn.throttle(function(){for(var e=document.querySelectorAll("defs"),t=e.length,n=0;n<t;n++){var i=e[n];i.parentNode.insertBefore(i,i)}},Zn?Zn.internetExplorerRedisplayInterval:null);function sc(){const e=Ke("./Fabulaser_V3_All_In.glb"),t=Ke("./Fabulaser_V3_All_Out.glb"),n=C.useMemo(()=>e.scene.clone(),[e]),i=C.useMemo(()=>e.scene.clone(),[e]),s=C.useMemo(()=>t.scene.clone(),[t]);C.useState(!1),C.useRef(),C.useRef(),Ke.clear("./Fabulaser_V3_All_In.glb"),Ke.clear("./Fabulaser_V3_All_Out.glb");const a=te(o=>o.resetCamera);function r(){const{active:o,progress:l,errors:u,item:c,loaded:d,total:f}=Ds();return V(Html,{center:!0,children:[l," % loaded"]})}return z(K,{children:V(C.Fragment,{children:[z("aside",{className:"stepNavi",children:z(ml,{})}),V("section",{id:"currentStepArea",children:[V("nav",{className:"currentStepBar",children:[z("h2",{id:"stepTitleArea",children:z(hl,{})}),V("div",{id:"stepControl",children:[z(Fs,{}),"                        "]})]}),V("div",{className:"infoColumn",children:[z("div",{className:"stepPartsArea",children:z(dl,{})}),V("div",{className:"stepRemarksArea",children:[V("div",{style:{margin:"auto",display:"inline",alignContent:"baseline"},children:[V("h3",{children:[" ",z(Hl,{})," Remarks"]})," ",z("br",{})]}),z(gl,{})]})]}),V("article",{className:"viewArea",id:"viewArea",children:[z(C.Suspense,{fallback:z(r,{}),children:V(zs,{linear:!0,flat:!0,frameloop:"demand",camera:{fov:45,near:1,far:10,position:[4,1,8]},children:[z(Yl,{}),z("color",{args:["#f5f5f5"],attach:"background"}),V(Ns,{clip:!0,observe:!0,damping:2,margin:.85,children:[z(fl,{modelIn:e,modelOut:t,modelInCopy:n,modelInCopy2:i,modelOutCopy:s}),z(vl,{})]}),z(Xl,{})]})}),V("button",{className:"btn",style:{position:"absolute",bottom:"20px",left:"20px"},onClick:a,children:[z(Vl,{})," Reset Camera"]}),z(Gs,{}),z(Wl,{})]})]})]})})}Ke.preload("./Fabulaser_V3_All_In.glb");Ke.preload("./Fabulaser_V3_All_Out.glb");function Yl(){const e=C.useRef();return z(K,{children:z(Ls,{ref:e,makeDefault:!0,enableDamping:!1,enableRotate:!0,minAzimuthAngle:1/0,maxAzimuthAngle:1/0,minPolarAngle:0,maxPolarAngle:1/0})})}export{sc as default};
//# sourceMappingURL=App-7e45a061.js.map
