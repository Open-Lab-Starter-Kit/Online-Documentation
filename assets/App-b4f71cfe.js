import{r as C,u as Q,M as ce,s as os,j as z,F as Z,a as V,C as pe,S as ve,U as ls,b as Xn,B as Ne,V as X,c as Ue,d as se,D as cs,e as us,f as fs,g as ds,W as ue,E as yt,L as Ti,N as wi,h as Re,i as H,R as hs,k as Qe,l as ps,m as ms,n as Ht,o as Kt,p as Vt,q as ft,t as bn,v as Zt,T as Yt,w as Je,x as Tn,P as Ai,y as vs,z as _i,A as Ei,G as Gt,H as me,I as Kn,J as de,K as Ln,O as Ci,Q as gs,X as ys,Y as xs,Z as Ss,_ as D,$ as Te,a0 as Mi,a1 as Se,a2 as dt,a3 as bs,a4 as ge,a5 as Ts,a6 as ht,a7 as kt,a8 as Pi,a9 as Ke,aa as Le,ab as ws,ac as As,ad as _s,ae as $t,af as Bi,ag as Nn,ah as Es,ai as Cs,aj as Ze,ak as Ms,al as Ps,am as Bs,an as Rs}from"./index-515c1046.js";import{Vector3 as zs,Vector2 as Ds,UniformsUtils as Ri,UniformsLib as Zn,ShaderMaterial as Ls}from"//cdn.skypack.dev/three@0.130.1/build/three.module.js";import"//cdn.skypack.dev/three@0.130.1/examples/jsm/lines/LineSegmentsGeometry.js";let st;function Ns(){var e;if(st!==void 0)return st;try{let t;const n=document.createElement("canvas");return st=!!(window.WebGL2RenderingContext&&(t=n.getContext("webgl2"))),t&&((e=t.getExtension("WEBGL_lose_context"))==null||e.loseContext()),st}catch{return st=!1}}function Us(){const e=C.useRef(),t=Q(s=>s.wiringStep);let{currentStepObject:n,setCurrentSVG:i}=C.useContext(ce);return C.useEffect(()=>{t&&document.getElementById("myEmbed").addEventListener("load",function(){i(os(document.getElementById("myEmbed")))})},[t]),z(Z,{children:t?z("div",{id:"svgContainer",style:{position:"absolute",width:"100%",height:"100%",bottom:"0px",left:"0px",padding:"10px"},children:z("embed",{style:{width:"100%",height:"100%",backgroundColor:"#e9e9e9"},ref:e,type:"image/svg+xml",src:`./${n.name}.svg`,id:"myEmbed"})}):null})}function Is(){let{setStepPosition:e,stepCount:t}=C.useContext(ce);const n=()=>{t++,e(t)},i=()=>{t--,e(t)};return V(Z,{children:[t>=1?z("button",{onClick:i,className:"btn",id:"nextStep",children:" ❮ Previous Step  "}):null,z("button",{onClick:n,className:"btn",id:"nextStep",children:"Next Step ❯ "})]})}function Os(){const{setModelInOut:e,selectedParts:t}=C.useContext(ce),[n,i]=C.useState(!1),s=Q(r=>r.wiringStep);return z(Z,{children:s?null:z("button",{onClick:()=>{n==!1?(document.getElementById("partsOut").innerHTML="Assemble",i(!0),e(n)):n==!0&&(document.getElementById("partsOut").innerHTML="Explode",i(!1),e(n))},className:"btn",id:"partsOut",children:"Explode"})})}let ks=class{constructor(t,n={}){this.enabled=!0;const i=n.defaultThickness!==void 0?n.defaultThickness:.003,s=new pe().fromArray(n.defaultColor!==void 0?n.defaultColor:[0,0,0]),a=n.defaultAlpha!==void 0?n.defaultAlpha:1,r=n.defaultKeepAlive!==void 0?n.defaultKeepAlive:!1,l={},o=60,u={},c={},d={outlineThickness:{value:i},outlineColor:{value:s},outlineAlpha:{value:a}},f=["#include <common>","#include <uv_pars_vertex>","#include <displacementmap_pars_vertex>","#include <fog_pars_vertex>","#include <morphtarget_pars_vertex>","#include <skinning_pars_vertex>","#include <logdepthbuf_pars_vertex>","#include <clipping_planes_pars_vertex>","uniform float outlineThickness;","vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {","	float thickness = outlineThickness;","	const float ratio = 1.0;","	vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );","	vec4 norm = normalize( pos - pos2 );","	return pos + norm * thickness * pos.w * ratio;","}","void main() {","	#include <uv_vertex>","	#include <beginnormal_vertex>","	#include <morphnormal_vertex>","	#include <skinbase_vertex>","	#include <skinnormal_vertex>","	#include <begin_vertex>","	#include <morphtarget_vertex>","	#include <skinning_vertex>","	#include <displacementmap_vertex>","	#include <project_vertex>","	vec3 outlineNormal = - objectNormal;","	gl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );","	#include <logdepthbuf_vertex>","	#include <clipping_planes_vertex>","	#include <fog_vertex>","}"].join(`
`),p=["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","#include <clipping_planes_pars_fragment>","uniform vec3 outlineColor;","uniform float outlineAlpha;","void main() {","	#include <clipping_planes_fragment>","	#include <logdepthbuf_fragment>","	gl_FragColor = vec4( outlineColor, outlineAlpha );","	#include <tonemapping_fragment>","	#include <encodings_fragment>","	#include <fog_fragment>","	#include <premultiplied_alpha_fragment>","}"].join(`
`);function S(){return new ve({type:"OutlineEffect",uniforms:ls.merge([Xn.fog,Xn.displacementmap,d]),vertexShader:f,fragmentShader:p,side:Ne})}function A(m){let g=l[m.uuid];return g===void 0&&(g={material:S(),used:!0,keepAlive:r,count:0},l[m.uuid]=g),g.used=!0,g.material}function x(m){const g=A(m);return u[g.uuid]=m,M(g,m),g}function y(m){const g=m.geometry,b=g!==void 0&&g.attributes.normal!==void 0;return m.isMesh===!0&&m.material!==void 0&&b===!0}function v(m){if(y(m)!==!1){if(Array.isArray(m.material))for(let g=0,b=m.material.length;g<b;g++)m.material[g]=x(m.material[g]);else m.material=x(m.material);c[m.uuid]=m.onBeforeRender,m.onBeforeRender=w}}function h(m){if(y(m)!==!1){if(Array.isArray(m.material))for(let g=0,b=m.material.length;g<b;g++)m.material[g]=u[m.material[g].uuid];else m.material=u[m.material.uuid];m.onBeforeRender=c[m.uuid]}}function w(m,g,b,P,E){const R=u[E.uuid];R!==void 0&&T(E,R)}function T(m,g){const b=g.userData.outlineParameters;m.uniforms.outlineAlpha.value=g.opacity,b!==void 0&&(b.thickness!==void 0&&(m.uniforms.outlineThickness.value=b.thickness),b.color!==void 0&&m.uniforms.outlineColor.value.fromArray(b.color),b.alpha!==void 0&&(m.uniforms.outlineAlpha.value=b.alpha)),g.displacementMap&&(m.uniforms.displacementMap.value=g.displacementMap,m.uniforms.displacementScale.value=g.displacementScale,m.uniforms.displacementBias.value=g.displacementBias)}function M(m,g){if(m.name==="invisible")return;const b=g.userData.outlineParameters;m.fog=g.fog,m.toneMapped=g.toneMapped,m.premultipliedAlpha=g.premultipliedAlpha,m.displacementMap=g.displacementMap,b!==void 0?(g.visible===!1?m.visible=!1:m.visible=b.visible!==void 0?b.visible:!0,m.transparent=b.alpha!==void 0&&b.alpha<1?!0:g.transparent,b.keepAlive!==void 0&&(l[g.uuid].keepAlive=b.keepAlive)):(m.transparent=g.transparent,m.visible=g.visible),(g.wireframe===!0||g.depthTest===!1)&&(m.visible=!1),g.clippingPlanes&&(m.clipping=!0,m.clippingPlanes=g.clippingPlanes,m.clipIntersection=g.clipIntersection,m.clipShadows=g.clipShadows),m.version=g.version}function _(){let m;m=Object.keys(u);for(let g=0,b=m.length;g<b;g++)u[m[g]]=void 0;m=Object.keys(c);for(let g=0,b=m.length;g<b;g++)c[m[g]]=void 0;m=Object.keys(l);for(let g=0,b=m.length;g<b;g++){const P=m[g];l[P].used===!1?(l[P].count++,l[P].keepAlive===!1&&l[P].count>o&&delete l[P]):(l[P].used=!1,l[P].count=0)}}this.render=function(m,g){if(this.enabled===!1){t.render(m,g);return}const b=t.autoClear;t.autoClear=this.autoClear,t.render(m,g),t.autoClear=b,this.renderOutline(m,g)},this.renderOutline=function(m,g){const b=t.autoClear,P=m.matrixWorldAutoUpdate,E=m.background,R=t.shadowMap.enabled;m.matrixWorldAutoUpdate=!1,m.background=null,t.autoClear=!1,t.shadowMap.enabled=!1,m.traverse(v),t.render(m,g),m.traverse(h),_(),m.matrixWorldAutoUpdate=P,m.background=E,t.autoClear=b,t.shadowMap.enabled=R},this.autoClear=t.autoClear,this.domElement=t.domElement,this.shadowMap=t.shadowMap,this.clear=function(m,g,b){t.clear(m,g,b)},this.getPixelRatio=function(){return t.getPixelRatio()},this.setPixelRatio=function(m){t.setPixelRatio(m)},this.getSize=function(m){return t.getSize(m)},this.setSize=function(m,g,b){t.setSize(m,g,b)},this.setViewport=function(m,g,b,P){t.setViewport(m,g,b,P)},this.setScissor=function(m,g,b,P){t.setScissor(m,g,b,P)},this.setScissorTest=function(m){t.setScissorTest(m)},this.setRenderTarget=function(m){t.setRenderTarget(m)}}};const zi=C.createContext(null);function Fs({children:e,enabled:t=!0}){const[n,i]=C.useState([]),s=C.useMemo(()=>({selected:n,select:i,enabled:t}),[n,i,t]);return z(zi.Provider,{value:s,children:e})}/**
 * postprocessing v6.35.3 build Sat Mar 30 2024
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2024 Raoul van Rüschen
 * @license Zlib
 */var tn=1/1e3,Hs=1e3,Vs=class{constructor(){this.startTime=performance.now(),this.previousTime=0,this.currentTime=0,this._delta=0,this._elapsed=0,this._fixedDelta=1e3/60,this.timescale=1,this.useFixedDelta=!1,this._autoReset=!1}get autoReset(){return this._autoReset}set autoReset(e){typeof document<"u"&&document.hidden!==void 0&&(e?document.addEventListener("visibilitychange",this):document.removeEventListener("visibilitychange",this),this._autoReset=e)}get delta(){return this._delta*tn}get fixedDelta(){return this._fixedDelta*tn}set fixedDelta(e){this._fixedDelta=e*Hs}get elapsed(){return this._elapsed*tn}update(e){this.useFixedDelta?this._delta=this.fixedDelta:(this.previousTime=this.currentTime,this.currentTime=(e!==void 0?e:performance.now())-this.startTime,this._delta=this.currentTime-this.previousTime),this._delta*=this.timescale,this._elapsed+=this._delta}reset(){this._delta=0,this._elapsed=0,this.currentTime=performance.now()-this.startTime}getDelta(){return this.delta}getElapsed(){return this.elapsed}handleEvent(e){document.hidden||(this.currentTime=performance.now()-this.startTime)}dispose(){this.autoReset=!1}},Gs=new Ei,Ae=null;function $s(){if(Ae===null){const e=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),t=new Float32Array([0,0,2,0,0,2]);Ae=new Gt,Ae.setAttribute!==void 0?(Ae.setAttribute("position",new me(e,3)),Ae.setAttribute("uv",new me(t,2))):(Ae.addAttribute("position",new me(e,3)),Ae.addAttribute("uv",new me(t,2)))}return Ae}var ne=class Di{constructor(t="Pass",n=new Ht,i=Gs){this.name=t,this.renderer=null,this.scene=n,this.camera=i,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}get renderToScreen(){return!this.rtt}set renderToScreen(t){if(this.rtt===t){const n=this.fullscreenMaterial;n!==null&&(n.needsUpdate=!0),this.rtt=!t}}set mainScene(t){}set mainCamera(t){}setRenderer(t){this.renderer=t}isEnabled(){return this.enabled}setEnabled(t){this.enabled=t}get fullscreenMaterial(){return this.screen!==null?this.screen.material:null}set fullscreenMaterial(t){let n=this.screen;n!==null?n.material=t:(n=new Kt($s(),t),n.frustumCulled=!1,this.scene===null&&(this.scene=new Ht),this.scene.add(n),this.screen=n)}getFullscreenMaterial(){return this.fullscreenMaterial}setFullscreenMaterial(t){this.fullscreenMaterial=t}getDepthTexture(){return null}setDepthTexture(t,n=Re){}render(t,n,i,s,a){throw new Error("Render method not implemented!")}setSize(t,n){}initialize(t,n,i){}dispose(){for(const t of Object.keys(this)){const n=this[t];(n instanceof ue||n instanceof Zt||n instanceof Yt||n instanceof Di)&&this[t].dispose()}}},js=class extends ne{constructor(){super("ClearMaskPass",null,null),this.needsSwap=!1}render(e,t,n,i,s){const a=e.state.buffers.stencil;a.setLocked(!1),a.setTest(!1)}},Ws=Number(_i.replace(/\D+/g,""));function Un(e){return Ws<154?e.replace("colorspace_fragment","encodings_fragment"):e}var qs=`#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <colorspace_fragment>
#include <dithering_fragment>
}`,Xs="varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",Li=class extends ve{constructor(){super({name:"CopyMaterial",uniforms:{inputBuffer:new H(null),opacity:new H(1)},blending:Je,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:qs,vertexShader:Xs}),this.fragmentShader=Un(this.fragmentShader)}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}getOpacity(e){return this.uniforms.opacity.value}setOpacity(e){this.uniforms.opacity.value=e}},Ks=class extends ne{constructor(e,t=!0){super("CopyPass"),this.fullscreenMaterial=new Li,this.needsSwap=!1,this.renderTarget=e,e===void 0&&(this.renderTarget=new ue(1,1,{minFilter:Vt,magFilter:Vt,stencilBuffer:!1,depthBuffer:!1}),this.renderTarget.texture.name="CopyPass.Target"),this.autoResize=t}get resize(){return this.autoResize}set resize(e){this.autoResize=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}setAutoResizeEnabled(e){this.autoResize=e}render(e,t,n,i,s){this.fullscreenMaterial.inputBuffer=t.texture,e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){this.autoResize&&this.renderTarget.setSize(e,t)}initialize(e,t,n){n!==void 0&&(this.renderTarget.texture.type=n,n!==Ue?this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1":e!==null&&e.outputColorSpace===se&&(this.renderTarget.texture.colorSpace=se))}},Yn=new pe,In=class extends ne{constructor(e=!0,t=!0,n=!1){super("ClearPass",null,null),this.needsSwap=!1,this.color=e,this.depth=t,this.stencil=n,this.overrideClearColor=null,this.overrideClearAlpha=-1}setClearFlags(e,t,n){this.color=e,this.depth=t,this.stencil=n}getOverrideClearColor(){return this.overrideClearColor}setOverrideClearColor(e){this.overrideClearColor=e}getOverrideClearAlpha(){return this.overrideClearAlpha}setOverrideClearAlpha(e){this.overrideClearAlpha=e}render(e,t,n,i,s){const a=this.overrideClearColor,r=this.overrideClearAlpha,l=e.getClearAlpha(),o=a!==null,u=r>=0;o?(e.getClearColor(Yn),e.setClearColor(a,u?r:l)):u&&e.setClearAlpha(r),e.setRenderTarget(this.renderToScreen?null:t),e.clear(this.color,this.depth,this.stencil),o?e.setClearColor(Yn,l):u&&e.setClearAlpha(l)}},Zs=class extends ne{constructor(e,t){super("MaskPass",e,t),this.needsSwap=!1,this.clearPass=new In(!1,!1,!0),this.inverse=!1}set mainScene(e){this.scene=e}set mainCamera(e){this.camera=e}get inverted(){return this.inverse}set inverted(e){this.inverse=e}get clear(){return this.clearPass.enabled}set clear(e){this.clearPass.enabled=e}getClearPass(){return this.clearPass}isInverted(){return this.inverted}setInverted(e){this.inverted=e}render(e,t,n,i,s){const a=e.getContext(),r=e.state.buffers,l=this.scene,o=this.camera,u=this.clearPass,c=this.inverted?0:1,d=1-c;r.color.setMask(!1),r.depth.setMask(!1),r.color.setLocked(!0),r.depth.setLocked(!0),r.stencil.setTest(!0),r.stencil.setOp(a.REPLACE,a.REPLACE,a.REPLACE),r.stencil.setFunc(a.ALWAYS,c,4294967295),r.stencil.setClear(d),r.stencil.setLocked(!0),this.clearPass.enabled&&(this.renderToScreen?u.render(e,null):(u.render(e,t),u.render(e,n))),this.renderToScreen?(e.setRenderTarget(null),e.render(l,o)):(e.setRenderTarget(t),e.render(l,o),e.setRenderTarget(n),e.render(l,o)),r.color.setLocked(!1),r.depth.setLocked(!1),r.stencil.setLocked(!1),r.stencil.setFunc(a.EQUAL,1,4294967295),r.stencil.setOp(a.KEEP,a.KEEP,a.KEEP),r.stencil.setLocked(!0)}},Ys=class{constructor(t=null,{depthBuffer:n=!0,stencilBuffer:i=!1,multisampling:s=0,frameBufferType:a}={}){this.renderer=null,this.inputBuffer=this.createBuffer(n,i,a,s),this.outputBuffer=this.inputBuffer.clone(),this.copyPass=new Ks,this.depthTexture=null,this.passes=[],this.timer=new Vs,this.autoRenderToScreen=!0,this.setRenderer(t)}get multisampling(){return this.inputBuffer.samples||0}set multisampling(t){const n=this.inputBuffer,i=this.multisampling;i>0&&t>0?(this.inputBuffer.samples=t,this.outputBuffer.samples=t,this.inputBuffer.dispose(),this.outputBuffer.dispose()):i!==t&&(this.inputBuffer.dispose(),this.outputBuffer.dispose(),this.inputBuffer=this.createBuffer(n.depthBuffer,n.stencilBuffer,n.texture.type,t),this.inputBuffer.depthTexture=this.depthTexture,this.outputBuffer=this.inputBuffer.clone())}getTimer(){return this.timer}getRenderer(){return this.renderer}setRenderer(t){if(this.renderer=t,t!==null){const n=t.getSize(new X),i=t.getContext().getContextAttributes().alpha,s=this.inputBuffer.texture.type;s===Ue&&t.outputColorSpace===se&&(this.inputBuffer.texture.colorSpace=se,this.outputBuffer.texture.colorSpace=se,this.inputBuffer.dispose(),this.outputBuffer.dispose()),t.autoClear=!1,this.setSize(n.width,n.height);for(const a of this.passes)a.initialize(t,i,s)}}replaceRenderer(t,n=!0){const i=this.renderer,s=i.domElement.parentNode;return this.setRenderer(t),n&&s!==null&&(s.removeChild(i.domElement),s.appendChild(t.domElement)),i}createDepthTexture(){const t=this.depthTexture=new cs;return this.inputBuffer.depthTexture=t,this.inputBuffer.dispose(),this.inputBuffer.stencilBuffer?(t.format=us,t.type=fs):t.type=ds,t}deleteDepthTexture(){if(this.depthTexture!==null){this.depthTexture.dispose(),this.depthTexture=null,this.inputBuffer.depthTexture=null,this.inputBuffer.dispose();for(const t of this.passes)t.setDepthTexture(null)}}createBuffer(t,n,i,s){const a=this.renderer,r=a===null?new X:a.getDrawingBufferSize(new X),l={minFilter:Vt,magFilter:Vt,stencilBuffer:n,depthBuffer:t,type:i},o=new ue(r.width,r.height,l);return s>0&&(o.ignoreDepthForMultisampleCopy=!1,o.samples=s),i===Ue&&a!==null&&a.outputColorSpace===se&&(o.texture.colorSpace=se),o.texture.name="EffectComposer.Buffer",o.texture.generateMipmaps=!1,o}setMainScene(t){for(const n of this.passes)n.mainScene=t}setMainCamera(t){for(const n of this.passes)n.mainCamera=t}addPass(t,n){const i=this.passes,s=this.renderer,a=s.getDrawingBufferSize(new X),r=s.getContext().getContextAttributes().alpha,l=this.inputBuffer.texture.type;if(t.setRenderer(s),t.setSize(a.width,a.height),t.initialize(s,r,l),this.autoRenderToScreen&&(i.length>0&&(i[i.length-1].renderToScreen=!1),t.renderToScreen&&(this.autoRenderToScreen=!1)),n!==void 0?i.splice(n,0,t):i.push(t),this.autoRenderToScreen&&(i[i.length-1].renderToScreen=!0),t.needsDepthTexture||this.depthTexture!==null)if(this.depthTexture===null){const o=this.createDepthTexture();for(t of i)t.setDepthTexture(o)}else t.setDepthTexture(this.depthTexture)}removePass(t){const n=this.passes,i=n.indexOf(t);if(i!==-1&&n.splice(i,1).length>0){if(this.depthTexture!==null){const r=(o,u)=>o||u.needsDepthTexture;n.reduce(r,!1)||(t.getDepthTexture()===this.depthTexture&&t.setDepthTexture(null),this.deleteDepthTexture())}this.autoRenderToScreen&&i===n.length&&(t.renderToScreen=!1,n.length>0&&(n[n.length-1].renderToScreen=!0))}}removeAllPasses(){const t=this.passes;this.deleteDepthTexture(),t.length>0&&(this.autoRenderToScreen&&(t[t.length-1].renderToScreen=!1),this.passes=[])}render(t){const n=this.renderer,i=this.copyPass;let s=this.inputBuffer,a=this.outputBuffer,r=!1,l,o,u;t===void 0&&(this.timer.update(),t=this.timer.getDelta());for(const c of this.passes)c.enabled&&(c.render(n,s,a,t,r),c.needsSwap&&(r&&(i.renderToScreen=c.renderToScreen,l=n.getContext(),o=n.state.buffers.stencil,o.setFunc(l.NOTEQUAL,1,4294967295),i.render(n,s,a,t,r),o.setFunc(l.EQUAL,1,4294967295)),u=s,s=a,a=u),c instanceof Zs?r=!0:c instanceof js&&(r=!1))}setSize(t,n,i){const s=this.renderer,a=s.getSize(new X);(t===void 0||n===void 0)&&(t=a.width,n=a.height),(a.width!==t||a.height!==n)&&s.setSize(t,n,i);const r=s.getDrawingBufferSize(new X);this.inputBuffer.setSize(r.width,r.height),this.outputBuffer.setSize(r.width,r.height);for(const l of this.passes)l.setSize(r.width,r.height)}reset(){this.dispose(),this.autoRenderToScreen=!0}dispose(){for(const t of this.passes)t.dispose();this.passes=[],this.inputBuffer!==null&&this.inputBuffer.dispose(),this.outputBuffer!==null&&this.outputBuffer.dispose(),this.deleteDepthTexture(),this.copyPass.dispose(),this.timer.dispose()}},be={NONE:0,DEPTH:1,CONVOLUTION:2},F={FRAGMENT_HEAD:"FRAGMENT_HEAD",FRAGMENT_MAIN_UV:"FRAGMENT_MAIN_UV",FRAGMENT_MAIN_IMAGE:"FRAGMENT_MAIN_IMAGE",VERTEX_HEAD:"VERTEX_HEAD",VERTEX_MAIN_SUPPORT:"VERTEX_MAIN_SUPPORT"},Qs=class{constructor(){this.shaderParts=new Map([[F.FRAGMENT_HEAD,null],[F.FRAGMENT_MAIN_UV,null],[F.FRAGMENT_MAIN_IMAGE,null],[F.VERTEX_HEAD,null],[F.VERTEX_MAIN_SUPPORT,null]]),this.defines=new Map,this.uniforms=new Map,this.blendModes=new Map,this.extensions=new Set,this.attributes=be.NONE,this.varyings=new Set,this.uvTransformation=!1,this.readDepth=!1,this.colorSpace=Ti}},nn=!1,Qn=class{constructor(e=null){this.originalMaterials=new Map,this.material=null,this.materials=null,this.materialsBackSide=null,this.materialsDoubleSide=null,this.materialsFlatShaded=null,this.materialsFlatShadedBackSide=null,this.materialsFlatShadedDoubleSide=null,this.setMaterial(e),this.meshCount=0,this.replaceMaterial=t=>{if(t.isMesh){let n;if(t.material.flatShading)switch(t.material.side){case ft:n=this.materialsFlatShadedDoubleSide;break;case Ne:n=this.materialsFlatShadedBackSide;break;default:n=this.materialsFlatShaded;break}else switch(t.material.side){case ft:n=this.materialsDoubleSide;break;case Ne:n=this.materialsBackSide;break;default:n=this.materials;break}this.originalMaterials.set(t,t.material),t.isSkinnedMesh?t.material=n[2]:t.isInstancedMesh?t.material=n[1]:t.material=n[0],++this.meshCount}}}cloneMaterial(e){if(!(e instanceof ve))return e.clone();const t=e.uniforms,n=new Map;for(const s in t){const a=t[s].value;a.isRenderTargetTexture&&(t[s].value=null,n.set(s,a))}const i=e.clone();for(const s of n)t[s[0]].value=s[1],i.uniforms[s[0]].value=s[1];return i}setMaterial(e){if(this.disposeMaterials(),this.material=e,e!==null){const t=this.materials=[this.cloneMaterial(e),this.cloneMaterial(e),this.cloneMaterial(e)];for(const n of t)n.uniforms=Object.assign({},e.uniforms),n.side=bn;t[2].skinning=!0,this.materialsBackSide=t.map(n=>{const i=this.cloneMaterial(n);return i.uniforms=Object.assign({},e.uniforms),i.side=Ne,i}),this.materialsDoubleSide=t.map(n=>{const i=this.cloneMaterial(n);return i.uniforms=Object.assign({},e.uniforms),i.side=ft,i}),this.materialsFlatShaded=t.map(n=>{const i=this.cloneMaterial(n);return i.uniforms=Object.assign({},e.uniforms),i.flatShading=!0,i}),this.materialsFlatShadedBackSide=t.map(n=>{const i=this.cloneMaterial(n);return i.uniforms=Object.assign({},e.uniforms),i.flatShading=!0,i.side=Ne,i}),this.materialsFlatShadedDoubleSide=t.map(n=>{const i=this.cloneMaterial(n);return i.uniforms=Object.assign({},e.uniforms),i.flatShading=!0,i.side=ft,i})}}render(e,t,n){const i=e.shadowMap.enabled;if(e.shadowMap.enabled=!1,nn){const s=this.originalMaterials;this.meshCount=0,t.traverse(this.replaceMaterial),e.render(t,n);for(const a of s)a[0].material=a[1];this.meshCount!==s.size&&s.clear()}else{const s=t.overrideMaterial;t.overrideMaterial=this.material,e.render(t,n),t.overrideMaterial=s}e.shadowMap.enabled=i}disposeMaterials(){if(this.material!==null){const e=this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);for(const t of e)t.dispose()}}dispose(){this.originalMaterials.clear(),this.disposeMaterials()}static get workaroundEnabled(){return nn}static set workaroundEnabled(e){nn=e}},_e=-1,Y=class extends yt{constructor(e,t=_e,n=_e,i=1){super(),this.resizable=e,this.baseSize=new X(1,1),this.preferredSize=new X(t,n),this.target=this.preferredSize,this.s=i,this.effectiveSize=new X,this.addEventListener("change",()=>this.updateEffectiveSize()),this.updateEffectiveSize()}updateEffectiveSize(){const e=this.baseSize,t=this.preferredSize,n=this.effectiveSize,i=this.scale;t.width!==_e?n.width=t.width:t.height!==_e?n.width=Math.round(t.height*(e.width/Math.max(e.height,1))):n.width=Math.round(e.width*i),t.height!==_e?n.height=t.height:t.width!==_e?n.height=Math.round(t.width/Math.max(e.width/Math.max(e.height,1),1)):n.height=Math.round(e.height*i)}get width(){return this.effectiveSize.width}set width(e){this.preferredWidth=e}get height(){return this.effectiveSize.height}set height(e){this.preferredHeight=e}getWidth(){return this.width}getHeight(){return this.height}get scale(){return this.s}set scale(e){this.s!==e&&(this.s=e,this.preferredSize.setScalar(_e),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getScale(){return this.scale}setScale(e){this.scale=e}get baseWidth(){return this.baseSize.width}set baseWidth(e){this.baseSize.width!==e&&(this.baseSize.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseWidth(){return this.baseWidth}setBaseWidth(e){this.baseWidth=e}get baseHeight(){return this.baseSize.height}set baseHeight(e){this.baseSize.height!==e&&(this.baseSize.height=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseHeight(){return this.baseHeight}setBaseHeight(e){this.baseHeight=e}setBaseSize(e,t){(this.baseSize.width!==e||this.baseSize.height!==t)&&(this.baseSize.set(e,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}get preferredWidth(){return this.preferredSize.width}set preferredWidth(e){this.preferredSize.width!==e&&(this.preferredSize.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredWidth(){return this.preferredWidth}setPreferredWidth(e){this.preferredWidth=e}get preferredHeight(){return this.preferredSize.height}set preferredHeight(e){this.preferredSize.height!==e&&(this.preferredSize.height=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredHeight(){return this.preferredHeight}setPreferredHeight(e){this.preferredHeight=e}setPreferredSize(e,t){(this.preferredSize.width!==e||this.preferredSize.height!==t)&&(this.preferredSize.set(e,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}copy(e){this.s=e.scale,this.baseSize.set(e.baseWidth,e.baseHeight),this.preferredSize.set(e.preferredWidth,e.preferredHeight),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height)}static get AUTO_SIZE(){return _e}},Js=class extends Set{constructor(e,t=10){super(),this.l=t,this.exclusive=!1,e!==void 0&&this.set(e)}get layer(){return this.l}set layer(e){const t=this.l;for(const n of this)n.layers.disable(t),n.layers.enable(e);this.l=e}getLayer(){return this.layer}setLayer(e){this.layer=e}isExclusive(){return this.exclusive}setExclusive(e){this.exclusive=e}clear(){const e=this.layer;for(const t of this)t.layers.disable(e);return super.clear()}set(e){this.clear();for(const t of e)this.add(t);return this}indexOf(e){return this.has(e)?0:-1}add(e){return this.exclusive?e.layers.set(this.layer):e.layers.enable(this.layer),super.add(e)}delete(e){return this.has(e)&&e.layers.disable(this.layer),super.delete(e)}toggle(e){let t;return this.has(e)?(this.delete(e),t=!1):(this.add(e),t=!0),t}setVisible(e){for(const t of this)e?t.layers.enable(0):t.layers.disable(0);return this}},O={SKIP:9,SET:30,ADD:0,ALPHA:1,AVERAGE:2,COLOR:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,DIVIDE:8,DST:9,EXCLUSION:10,HARD_LIGHT:11,HARD_MIX:12,HUE:13,INVERT:14,INVERT_RGB:15,LIGHTEN:16,LINEAR_BURN:17,LINEAR_DODGE:18,LINEAR_LIGHT:19,LUMINOSITY:20,MULTIPLY:21,NEGATION:22,NORMAL:23,OVERLAY:24,PIN_LIGHT:25,REFLECT:26,SATURATION:27,SCREEN:28,SOFT_LIGHT:29,SRC:30,SUBTRACT:31,VIVID_LIGHT:32},er="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}",tr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}",nr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}",ir="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",sr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}",rr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}",ar="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}",or="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}",lr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}",cr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}",ur="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}",fr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}",dr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}",hr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}",pr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}",mr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}",vr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}",gr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}",yr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}",xr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",Sr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}",br="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}",Tr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}",wr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}",Ar="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}",_r="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}",Er="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",Cr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}",Mr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}",Pr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",Br="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}",Rr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}",zr=new Map([[O.ADD,er],[O.ALPHA,tr],[O.AVERAGE,nr],[O.COLOR,ir],[O.COLOR_BURN,sr],[O.COLOR_DODGE,rr],[O.DARKEN,ar],[O.DIFFERENCE,or],[O.DIVIDE,lr],[O.DST,null],[O.EXCLUSION,cr],[O.HARD_LIGHT,ur],[O.HARD_MIX,fr],[O.HUE,dr],[O.INVERT,hr],[O.INVERT_RGB,pr],[O.LIGHTEN,mr],[O.LINEAR_BURN,vr],[O.LINEAR_DODGE,gr],[O.LINEAR_LIGHT,yr],[O.LUMINOSITY,xr],[O.MULTIPLY,Sr],[O.NEGATION,br],[O.NORMAL,Tr],[O.OVERLAY,wr],[O.PIN_LIGHT,Ar],[O.REFLECT,_r],[O.SATURATION,Er],[O.SCREEN,Cr],[O.SOFT_LIGHT,Mr],[O.SRC,Pr],[O.SUBTRACT,Br],[O.VIVID_LIGHT,Rr]]),Dr=class extends yt{constructor(t,n=1){super(),this._blendFunction=t,this.opacity=new H(n)}getOpacity(){return this.opacity.value}setOpacity(t){this.opacity.value=t}get blendFunction(){return this._blendFunction}set blendFunction(t){this._blendFunction=t,this.dispatchEvent({type:"change"})}getBlendFunction(){return this.blendFunction}setBlendFunction(t){this.blendFunction=t}getShaderCode(){return zr.get(this.blendFunction)}},On={VERY_SMALL:0,SMALL:1,MEDIUM:2,LARGE:3,VERY_LARGE:4,HUGE:5},Lr=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <colorspace_fragment>
}`,Nr="uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",Ur=[new Float32Array([0,0]),new Float32Array([0,1,1]),new Float32Array([0,1,1,2]),new Float32Array([0,1,2,2,3]),new Float32Array([0,1,2,3,4,4,5]),new Float32Array([0,1,2,3,4,5,7,8,9,10])],Ir=class extends ve{constructor(e=new Kn){super({name:"KawaseBlurMaterial",uniforms:{inputBuffer:new H(null),texelSize:new H(new Kn),scale:new H(1),kernel:new H(0)},blending:Je,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Lr,vertexShader:Nr}),this.fragmentShader=Un(this.fragmentShader),this.setTexelSize(e.x,e.y),this.kernelSize=On.MEDIUM}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.inputBuffer=e}get kernelSequence(){return Ur[this.kernelSize]}get scale(){return this.uniforms.scale.value}set scale(e){this.uniforms.scale.value=e}getScale(){return this.uniforms.scale.value}setScale(e){this.uniforms.scale.value=e}getKernel(){return null}get kernel(){return this.uniforms.kernel.value}set kernel(e){this.uniforms.kernel.value=e}setKernel(e){this.kernel=e}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t,e*.5,t*.5)}setSize(e,t){const n=1/e,i=1/t;this.uniforms.texelSize.value.set(n,i,n*.5,i*.5)}},Or=class extends ne{constructor({kernelSize:e=On.MEDIUM,resolutionScale:t=.5,width:n=Y.AUTO_SIZE,height:i=Y.AUTO_SIZE,resolutionX:s=n,resolutionY:a=i}={}){super("KawaseBlurPass"),this.renderTargetA=new ue(1,1,{depthBuffer:!1}),this.renderTargetA.texture.name="Blur.Target.A",this.renderTargetB=this.renderTargetA.clone(),this.renderTargetB.texture.name="Blur.Target.B";const r=this.resolution=new Y(this,s,a,t);r.addEventListener("change",l=>this.setSize(r.baseWidth,r.baseHeight)),this._blurMaterial=new Ir,this._blurMaterial.kernelSize=e,this.copyMaterial=new Li}getResolution(){return this.resolution}get blurMaterial(){return this._blurMaterial}set blurMaterial(e){this._blurMaterial=e}get dithering(){return this.copyMaterial.dithering}set dithering(e){this.copyMaterial.dithering=e}get kernelSize(){return this.blurMaterial.kernelSize}set kernelSize(e){this.blurMaterial.kernelSize=e}get width(){return this.resolution.width}set width(e){this.resolution.preferredWidth=e}get height(){return this.resolution.height}set height(e){this.resolution.preferredHeight=e}get scale(){return this.blurMaterial.scale}set scale(e){this.blurMaterial.scale=e}getScale(){return this.blurMaterial.scale}setScale(e){this.blurMaterial.scale=e}getKernelSize(){return this.kernelSize}setKernelSize(e){this.kernelSize=e}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}render(e,t,n,i,s){const a=this.scene,r=this.camera,l=this.renderTargetA,o=this.renderTargetB,u=this.blurMaterial,c=u.kernelSequence;let d=t;this.fullscreenMaterial=u;for(let f=0,p=c.length;f<p;++f){const S=f&1?o:l;u.kernel=c[f],u.inputBuffer=d.texture,e.setRenderTarget(S),e.render(a,r),d=S}this.fullscreenMaterial=this.copyMaterial,this.copyMaterial.inputBuffer=d.texture,e.setRenderTarget(this.renderToScreen?null:n),e.render(a,r)}setSize(e,t){const n=this.resolution;n.setBaseSize(e,t);const i=n.width,s=n.height;this.renderTargetA.setSize(i,s),this.renderTargetB.setSize(i,s),this.blurMaterial.setSize(e,t)}initialize(e,t,n){n!==void 0&&(this.renderTargetA.texture.type=n,this.renderTargetB.texture.type=n,n!==Ue?(this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1"):e!==null&&e.outputColorSpace===se&&(this.renderTargetA.texture.colorSpace=se,this.renderTargetB.texture.colorSpace=se))}static get AUTO_SIZE(){return Y.AUTO_SIZE}},wn=class extends yt{constructor(t,n,{attributes:i=be.NONE,blendFunction:s=O.NORMAL,defines:a=new Map,uniforms:r=new Map,extensions:l=null,vertexShader:o=null}={}){super(),this.name=t,this.renderer=null,this.attributes=i,this.fragmentShader=n,this.vertexShader=o,this.defines=a,this.uniforms=r,this.extensions=l,this.blendMode=new Dr(s),this.blendMode.addEventListener("change",u=>this.setChanged()),this._inputColorSpace=Ti,this._outputColorSpace=wi}get inputColorSpace(){return this._inputColorSpace}set inputColorSpace(t){this._inputColorSpace=t,this.setChanged()}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(t){this._outputColorSpace=t,this.setChanged()}set mainScene(t){}set mainCamera(t){}getName(){return this.name}setRenderer(t){this.renderer=t}getDefines(){return this.defines}getUniforms(){return this.uniforms}getExtensions(){return this.extensions}getBlendMode(){return this.blendMode}getAttributes(){return this.attributes}setAttributes(t){this.attributes=t,this.setChanged()}getFragmentShader(){return this.fragmentShader}setFragmentShader(t){this.fragmentShader=t,this.setChanged()}getVertexShader(){return this.vertexShader}setVertexShader(t){this.vertexShader=t,this.setChanged()}setChanged(){this.dispatchEvent({type:"change"})}setDepthTexture(t,n=Re){}update(t,n,i){}setSize(t,n){}initialize(t,n,i){}dispose(){for(const t of Object.keys(this)){const n=this[t];(n instanceof ue||n instanceof Zt||n instanceof Yt||n instanceof ne)&&this[t].dispose()}}},kr=class extends ne{constructor(e,t="inputBuffer"){super("ShaderPass"),this.fullscreenMaterial=e,this.input=t}setInput(e){this.input=e}render(e,t,n,i,s){const a=this.fullscreenMaterial.uniforms;t!==null&&a!==void 0&&a[this.input]!==void 0&&(a[this.input].value=t.texture),e.setRenderTarget(this.renderToScreen?null:n),e.render(this.scene,this.camera)}initialize(e,t,n){n!==void 0&&n!==Ue&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},Qt=class extends ne{constructor(e,t,n=null){super("RenderPass",e,t),this.needsSwap=!1,this.clearPass=new In,this.overrideMaterialManager=n===null?null:new Qn(n),this.ignoreBackground=!1,this.skipShadowMapUpdate=!1,this.selection=null}set mainScene(e){this.scene=e}set mainCamera(e){this.camera=e}get renderToScreen(){return super.renderToScreen}set renderToScreen(e){super.renderToScreen=e,this.clearPass.renderToScreen=e}get overrideMaterial(){const e=this.overrideMaterialManager;return e!==null?e.material:null}set overrideMaterial(e){const t=this.overrideMaterialManager;e!==null?t!==null?t.setMaterial(e):this.overrideMaterialManager=new Qn(e):t!==null&&(t.dispose(),this.overrideMaterialManager=null)}getOverrideMaterial(){return this.overrideMaterial}setOverrideMaterial(e){this.overrideMaterial=e}get clear(){return this.clearPass.enabled}set clear(e){this.clearPass.enabled=e}getSelection(){return this.selection}setSelection(e){this.selection=e}isBackgroundDisabled(){return this.ignoreBackground}setBackgroundDisabled(e){this.ignoreBackground=e}isShadowMapDisabled(){return this.skipShadowMapUpdate}setShadowMapDisabled(e){this.skipShadowMapUpdate=e}getClearPass(){return this.clearPass}render(e,t,n,i,s){const a=this.scene,r=this.camera,l=this.selection,o=r.layers.mask,u=a.background,c=e.shadowMap.autoUpdate,d=this.renderToScreen?null:t;l!==null&&r.layers.set(l.getLayer()),this.skipShadowMapUpdate&&(e.shadowMap.autoUpdate=!1),(this.ignoreBackground||this.clearPass.overrideClearColor!==null)&&(a.background=null),this.clearPass.enabled&&this.clearPass.render(e,t),e.setRenderTarget(d),this.overrideMaterialManager!==null?this.overrideMaterialManager.render(e,a,r):e.render(a,r),r.layers.mask=o,a.background=u,e.shadowMap.autoUpdate=c}},Fr=`#include <packing>
#include <clipping_planes_pars_fragment>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float cameraNear;uniform float cameraFar;centroid varying float vViewZ;centroid varying vec4 vProjTexCoord;void main(){
#include <clipping_planes_fragment>
vec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);
#if DEPTH_PACKING == 3201
float fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));
#else
float fragCoordZ=texture2D(depthBuffer,projTexCoord).r;
#endif
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);
#else
float viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);
#endif
float depthTest=(-vViewZ>-viewZ)?1.0:0.0;gl_FragColor.rg=vec2(0.0,depthTest);}`,Hr=`#include <common>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
varying float vViewZ;varying vec4 vProjTexCoord;void main(){
#include <skinbase_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <project_vertex>
vViewZ=mvPosition.z;vProjTexCoord=gl_Position;
#include <clipping_planes_vertex>
}`,Vr=class extends ve{constructor(e=null,t){super({name:"DepthComparisonMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new H(null),cameraNear:new H(.3),cameraFar:new H(1e3)},blending:Je,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Fr,vertexShader:Hr}),this.depthBuffer=e,this.depthPacking=Tn,this.copyCameraSettings(t)}set depthBuffer(e){this.uniforms.depthBuffer.value=e}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=Tn){this.depthBuffer=e,this.depthPacking=t}adoptCameraSettings(e){this.copyCameraSettings(e)}copyCameraSettings(e){e&&(this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far,e instanceof Ai?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}},Gr="uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)?vec2(d,0.0):vec2(0.0,d);}",$r="uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}",jr=class extends ve{constructor(e=new X){super({name:"OutlineMaterial",uniforms:{inputBuffer:new H(null),texelSize:new H(new X)},blending:Je,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Gr,vertexShader:$r}),this.uniforms.texelSize.value.set(e.x,e.y),this.uniforms.maskTexture=this.uniforms.inputBuffer}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t)}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}},Wr=class extends ne{constructor(e,t,{renderTarget:n,resolutionScale:i=1,width:s=Y.AUTO_SIZE,height:a=Y.AUTO_SIZE,resolutionX:r=s,resolutionY:l=a}={}){super("DepthPass"),this.needsSwap=!1,this.renderPass=new Qt(e,t,new vs({depthPacking:Tn}));const o=this.renderPass;o.skipShadowMapUpdate=!0,o.ignoreBackground=!0;const u=o.clearPass;u.overrideClearColor=new pe(16777215),u.overrideClearAlpha=1,this.renderTarget=n,this.renderTarget===void 0&&(this.renderTarget=new ue(1,1,{minFilter:Qe,magFilter:Qe}),this.renderTarget.texture.name="DepthPass.Target");const c=this.resolution=new Y(this,r,l,i);c.addEventListener("change",d=>this.setSize(c.baseWidth,c.baseHeight))}set mainScene(e){this.renderPass.mainScene=e}set mainCamera(e){this.renderPass.mainCamera=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}render(e,t,n,i,s){const a=this.renderToScreen?null:this.renderTarget;this.renderPass.render(e,a)}setSize(e,t){const n=this.resolution;n.setBaseSize(e,t),this.renderTarget.setSize(n.width,n.height)}},qr=`uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;
#ifdef USE_PATTERN
uniform lowp sampler2D patternTexture;varying vec2 vUvPattern;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;
#ifndef X_RAY
edge.y=0.0;
#endif
edge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;
#ifdef USE_PATTERN
vec4 patternColor=texture2D(patternTexture,vUvPattern);
#ifdef X_RAY
float hiddenFactor=0.5;
#else
float hiddenFactor=0.0;
#endif
visibilityFactor=(1.0-mask.y>0.0)?1.0:hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;
#endif
float alpha=max(max(edge.x,edge.y),visibilityFactor);
#ifdef ALPHA
outputColor=vec4(color,alpha);
#else
outputColor=vec4(color,max(alpha,inputColor.a));
#endif
}`,Xr="uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}",Kr=class extends wn{constructor(e,t,{blendFunction:n=O.SCREEN,patternTexture:i=null,patternScale:s=1,edgeStrength:a=1,pulseSpeed:r=0,visibleEdgeColor:l=16777215,hiddenEdgeColor:o=2230538,kernelSize:u=On.VERY_SMALL,blur:c=!1,xRay:d=!0,multisampling:f=0,resolutionScale:p=.5,width:S=Y.AUTO_SIZE,height:A=Y.AUTO_SIZE,resolutionX:x=S,resolutionY:y=A}={}){super("OutlineEffect",qr,{uniforms:new Map([["maskTexture",new H(null)],["edgeTexture",new H(null)],["edgeStrength",new H(a)],["visibleEdgeColor",new H(new pe(l))],["hiddenEdgeColor",new H(new pe(o))],["pulse",new H(1)],["patternScale",new H(s)],["patternTexture",new H(null)]])}),this.blendMode.addEventListener("change",T=>{this.blendMode.blendFunction===O.ALPHA?this.defines.set("ALPHA","1"):this.defines.delete("ALPHA"),this.setChanged()}),this.blendMode.blendFunction=n,this.patternTexture=i,this.xRay=d,this.scene=e,this.camera=t,this.renderTargetMask=new ue(1,1),this.renderTargetMask.samples=f,this.renderTargetMask.texture.name="Outline.Mask",this.uniforms.get("maskTexture").value=this.renderTargetMask.texture,this.renderTargetOutline=new ue(1,1,{depthBuffer:!1}),this.renderTargetOutline.texture.name="Outline.Edges",this.uniforms.get("edgeTexture").value=this.renderTargetOutline.texture,this.clearPass=new In,this.clearPass.overrideClearColor=new pe(0),this.clearPass.overrideClearAlpha=1,this.depthPass=new Wr(e,t),this.maskPass=new Qt(e,t,new Vr(this.depthPass.texture,t));const v=this.maskPass.clearPass;v.overrideClearColor=new pe(16777215),v.overrideClearAlpha=1,this.blurPass=new Or({resolutionScale:p,resolutionX:x,resolutionY:y,kernelSize:u}),this.blurPass.enabled=c;const h=this.blurPass.resolution;h.addEventListener("change",T=>this.setSize(h.baseWidth,h.baseHeight)),this.outlinePass=new kr(new jr);const w=this.outlinePass.fullscreenMaterial;w.inputBuffer=this.renderTargetMask.texture,this.time=0,this.forceUpdate=!0,this.selection=new Js,this.selection.layer=10,this.pulseSpeed=r}set mainScene(e){this.scene=e,this.depthPass.mainScene=e,this.maskPass.mainScene=e}set mainCamera(e){this.camera=e,this.depthPass.mainCamera=e,this.maskPass.mainCamera=e,this.maskPass.overrideMaterial.copyCameraSettings(e)}get resolution(){return this.blurPass.resolution}getResolution(){return this.blurPass.getResolution()}get multisampling(){return this.renderTargetMask.samples}set multisampling(e){this.renderTargetMask.samples=e,this.renderTargetMask.dispose()}get patternScale(){return this.uniforms.get("patternScale").value}set patternScale(e){this.uniforms.get("patternScale").value=e}get edgeStrength(){return this.uniforms.get("edgeStrength").value}set edgeStrength(e){this.uniforms.get("edgeStrength").value=e}get visibleEdgeColor(){return this.uniforms.get("visibleEdgeColor").value}set visibleEdgeColor(e){this.uniforms.get("visibleEdgeColor").value=e}get hiddenEdgeColor(){return this.uniforms.get("hiddenEdgeColor").value}set hiddenEdgeColor(e){this.uniforms.get("hiddenEdgeColor").value=e}getBlurPass(){return this.blurPass}getSelection(){return this.selection}getPulseSpeed(){return this.pulseSpeed}setPulseSpeed(e){this.pulseSpeed=e}get width(){return this.resolution.width}set width(e){this.resolution.preferredWidth=e}get height(){return this.resolution.height}set height(e){this.resolution.preferredHeight=e}get selectionLayer(){return this.selection.layer}set selectionLayer(e){this.selection.layer=e}get dithering(){return this.blurPass.dithering}set dithering(e){this.blurPass.dithering=e}get kernelSize(){return this.blurPass.kernelSize}set kernelSize(e){this.blurPass.kernelSize=e}get blur(){return this.blurPass.enabled}set blur(e){this.blurPass.enabled=e}get xRay(){return this.defines.has("X_RAY")}set xRay(e){this.xRay!==e&&(e?this.defines.set("X_RAY","1"):this.defines.delete("X_RAY"),this.setChanged())}isXRayEnabled(){return this.xRay}setXRayEnabled(e){this.xRay=e}get patternTexture(){return this.uniforms.get("patternTexture").value}set patternTexture(e){e!==null?(e.wrapS=e.wrapT=hs,this.defines.set("USE_PATTERN","1"),this.setVertexShader(Xr)):(this.defines.delete("USE_PATTERN"),this.setVertexShader(null)),this.uniforms.get("patternTexture").value=e,this.setChanged()}setPatternTexture(e){this.patternTexture=e}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}setSelection(e){return this.selection.set(e),this}clearSelection(){return this.selection.clear(),this}selectObject(e){return this.selection.add(e),this}deselectObject(e){return this.selection.delete(e),this}update(e,t,n){const i=this.scene,s=this.camera,a=this.selection,l=this.uniforms.get("pulse"),o=i.background,u=s.layers.mask;(this.forceUpdate||a.size>0)&&(i.background=null,l.value=1,this.pulseSpeed>0&&(l.value=Math.cos(this.time*this.pulseSpeed*10)*.375+.625),this.time+=n,a.setVisible(!1),this.depthPass.render(e),a.setVisible(!0),s.layers.set(a.layer),this.maskPass.render(e,this.renderTargetMask),s.layers.mask=u,i.background=o,this.outlinePass.render(e,null,this.renderTargetOutline),this.blurPass.enabled&&this.blurPass.render(e,this.renderTargetOutline,this.renderTargetOutline)),this.forceUpdate=a.size>0}setSize(e,t){this.blurPass.setSize(e,t),this.renderTargetMask.setSize(e,t);const n=this.resolution;n.setBaseSize(e,t);const i=n.width,s=n.height;this.depthPass.setSize(i,s),this.renderTargetOutline.setSize(i,s),this.outlinePass.fullscreenMaterial.setSize(i,s)}initialize(e,t,n){this.blurPass.initialize(e,t,Ue),n!==void 0&&(this.depthPass.initialize(e,t,n),this.maskPass.initialize(e,t,n),this.outlinePass.initialize(e,t,n))}},Zr=`#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;
#else
vec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);
#endif
gl_FragColor=vec4(n[index],d[index]);}`,Yr="uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}",Qr=class extends ve{constructor(){super({name:"DepthDownsamplingMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new H(null),normalBuffer:new H(null),texelSize:new H(new X)},blending:Je,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Zr,vertexShader:Yr})}set depthBuffer(e){this.uniforms.depthBuffer.value=e}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=Re){this.depthBuffer=e,this.depthPacking=t}set normalBuffer(e){this.uniforms.normalBuffer.value=e,e!==null?this.defines.DOWNSAMPLE_NORMALS="1":delete this.defines.DOWNSAMPLE_NORMALS,this.needsUpdate=!0}setNormalBuffer(e){this.normalBuffer=e}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t)}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}},Jr=class extends ne{constructor({normalBuffer:e=null,resolutionScale:t=.5,width:n=Y.AUTO_SIZE,height:i=Y.AUTO_SIZE,resolutionX:s=n,resolutionY:a=i}={}){super("DepthDownsamplingPass");const r=new Qr;r.normalBuffer=e,this.fullscreenMaterial=r,this.needsDepthTexture=!0,this.needsSwap=!1,this.renderTarget=new ue(1,1,{minFilter:Qe,magFilter:Qe,depthBuffer:!1,type:ps}),this.renderTarget.texture.name="DepthDownsamplingPass.Target",this.renderTarget.texture.generateMipmaps=!1;const l=this.resolution=new Y(this,s,a,t);l.addEventListener("change",o=>this.setSize(l.baseWidth,l.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}setDepthTexture(e,t=Re){this.fullscreenMaterial.depthBuffer=e,this.fullscreenMaterial.depthPacking=t}render(e,t,n,i,s){e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){const n=this.resolution;n.setBaseSize(e,t),this.renderTarget.setSize(n.width,n.height),this.fullscreenMaterial.setSize(e,t)}initialize(e,t,n){const i=e.getContext();if(!(i.getExtension("EXT_color_buffer_float")||i.getExtension("EXT_color_buffer_half_float")))throw new Error("Rendering to float texture is not supported.")}},ea=`#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`,ta="uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}",na=class extends ve{constructor(e,t,n,i,s=!1){super({name:"EffectMaterial",defines:{THREE_REVISION:_i.replace(/\D+/g,""),DEPTH_PACKING:"0",ENCODE_OUTPUT:"1"},uniforms:{inputBuffer:new H(null),depthBuffer:new H(null),resolution:new H(new X),texelSize:new H(new X),cameraNear:new H(.3),cameraFar:new H(1e3),aspect:new H(1),time:new H(0)},blending:Je,toneMapped:!1,depthWrite:!1,depthTest:!1,dithering:s}),e&&this.setShaderParts(e),t&&this.setDefines(t),n&&this.setUniforms(n),this.copyCameraSettings(i)}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(e){this.uniforms.depthBuffer.value=e}get depthPacking(){return Number(this.defines.DEPTH_PACKING)}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=Re){this.depthBuffer=e,this.depthPacking=t}setShaderData(e){this.setShaderParts(e.shaderParts),this.setDefines(e.defines),this.setUniforms(e.uniforms),this.setExtensions(e.extensions)}setShaderParts(e){return this.fragmentShader=ea.replace(F.FRAGMENT_HEAD,e.get(F.FRAGMENT_HEAD)||"").replace(F.FRAGMENT_MAIN_UV,e.get(F.FRAGMENT_MAIN_UV)||"").replace(F.FRAGMENT_MAIN_IMAGE,e.get(F.FRAGMENT_MAIN_IMAGE)||""),this.vertexShader=ta.replace(F.VERTEX_HEAD,e.get(F.VERTEX_HEAD)||"").replace(F.VERTEX_MAIN_SUPPORT,e.get(F.VERTEX_MAIN_SUPPORT)||""),this.fragmentShader=Un(this.fragmentShader),this.needsUpdate=!0,this}setDefines(e){for(const t of e.entries())this.defines[t[0]]=t[1];return this.needsUpdate=!0,this}setUniforms(e){for(const t of e.entries())this.uniforms[t[0]]=t[1];return this}setExtensions(e){this.extensions={};for(const t of e)this.extensions[t]=!0;return this}get encodeOutput(){return this.defines.ENCODE_OUTPUT!==void 0}set encodeOutput(e){this.encodeOutput!==e&&(e?this.defines.ENCODE_OUTPUT="1":delete this.defines.ENCODE_OUTPUT,this.needsUpdate=!0)}isOutputEncodingEnabled(e){return this.encodeOutput}setOutputEncodingEnabled(e){this.encodeOutput=e}get time(){return this.uniforms.time.value}set time(e){this.uniforms.time.value=e}setDeltaTime(e){this.uniforms.time.value+=e}adoptCameraSettings(e){this.copyCameraSettings(e)}copyCameraSettings(e){e&&(this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far,e instanceof Ai?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}setSize(e,t){const n=this.uniforms;n.resolution.value.set(e,t),n.texelSize.value.set(1/e,1/t),n.aspect.value=e/t}static get Section(){return F}};function Jn(e,t,n){for(const i of t){const s="$1"+e+i.charAt(0).toUpperCase()+i.slice(1),a=new RegExp("([^\\.])(\\b"+i+"\\b)","g");for(const r of n.entries())r[1]!==null&&n.set(r[0],r[1].replace(a,s))}}function ia(e,t,n){let i=t.getFragmentShader(),s=t.getVertexShader();const a=i!==void 0&&/mainImage/.test(i),r=i!==void 0&&/mainUv/.test(i);if(n.attributes|=t.getAttributes(),i===void 0)throw new Error(`Missing fragment shader (${t.name})`);if(r&&n.attributes&be.CONVOLUTION)throw new Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`);if(!a&&!r)throw new Error(`Could not find mainImage or mainUv function (${t.name})`);{const l=/\w+\s+(\w+)\([\w\s,]*\)\s*{/g,o=n.shaderParts;let u=o.get(F.FRAGMENT_HEAD)||"",c=o.get(F.FRAGMENT_MAIN_UV)||"",d=o.get(F.FRAGMENT_MAIN_IMAGE)||"",f=o.get(F.VERTEX_HEAD)||"",p=o.get(F.VERTEX_MAIN_SUPPORT)||"";const S=new Set,A=new Set;if(r&&(c+=`	${e}MainUv(UV);
`,n.uvTransformation=!0),s!==null&&/mainSupport/.test(s)){const v=/mainSupport *\([\w\s]*?uv\s*?\)/.test(s);p+=`	${e}MainSupport(`,p+=v?`vUv);
`:`);
`;for(const h of s.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))for(const w of h[1].split(/\s*,\s*/))n.varyings.add(w),S.add(w),A.add(w);for(const h of s.matchAll(l))A.add(h[1])}for(const v of i.matchAll(l))A.add(v[1]);for(const v of t.defines.keys())A.add(v.replace(/\([\w\s,]*\)/g,""));for(const v of t.uniforms.keys())A.add(v);A.delete("while"),A.delete("for"),A.delete("if"),t.uniforms.forEach((v,h)=>n.uniforms.set(e+h.charAt(0).toUpperCase()+h.slice(1),v)),t.defines.forEach((v,h)=>n.defines.set(e+h.charAt(0).toUpperCase()+h.slice(1),v));const x=new Map([["fragment",i],["vertex",s]]);Jn(e,A,n.defines),Jn(e,A,x),i=x.get("fragment"),s=x.get("vertex");const y=t.blendMode;if(n.blendModes.set(y.blendFunction,y),a){t.inputColorSpace!==null&&t.inputColorSpace!==n.colorSpace&&(d+=t.inputColorSpace===se?`color0 = LinearTosRGB(color0);
	`:`color0 = sRGBToLinear(color0);
	`),t.outputColorSpace!==wi?n.colorSpace=t.outputColorSpace:t.inputColorSpace!==null&&(n.colorSpace=t.inputColorSpace);const v=/MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;d+=`${e}MainImage(color0, UV, `,n.attributes&be.DEPTH&&v.test(i)&&(d+="depth, ",n.readDepth=!0),d+=`color1);
	`;const h=e+"BlendOpacity";n.uniforms.set(h,y.opacity),d+=`color0 = blend${y.blendFunction}(color0, color1, ${h});

	`,u+=`uniform float ${h};

`}if(u+=i+`
`,s!==null&&(f+=s+`
`),o.set(F.FRAGMENT_HEAD,u),o.set(F.FRAGMENT_MAIN_UV,c),o.set(F.FRAGMENT_MAIN_IMAGE,d),o.set(F.VERTEX_HEAD,f),o.set(F.VERTEX_MAIN_SUPPORT,p),t.extensions!==null)for(const v of t.extensions)n.extensions.add(v)}}var sa=class extends ne{constructor(e,...t){super("EffectPass"),this.fullscreenMaterial=new na(null,null,null,e),this.listener=n=>this.handleEvent(n),this.effects=[],this.setEffects(t),this.skipRendering=!1,this.minTime=1,this.maxTime=Number.POSITIVE_INFINITY,this.timeScale=1}set mainScene(e){for(const t of this.effects)t.mainScene=e}set mainCamera(e){this.fullscreenMaterial.copyCameraSettings(e);for(const t of this.effects)t.mainCamera=e}get encodeOutput(){return this.fullscreenMaterial.encodeOutput}set encodeOutput(e){this.fullscreenMaterial.encodeOutput=e}get dithering(){return this.fullscreenMaterial.dithering}set dithering(e){const t=this.fullscreenMaterial;t.dithering=e,t.needsUpdate=!0}setEffects(e){for(const t of this.effects)t.removeEventListener("change",this.listener);this.effects=e.sort((t,n)=>n.attributes-t.attributes);for(const t of this.effects)t.addEventListener("change",this.listener)}updateMaterial(){const e=new Qs;let t=0;for(const r of this.effects)if(r.blendMode.blendFunction===O.DST)e.attributes|=r.getAttributes()&be.DEPTH;else{if(e.attributes&r.getAttributes()&be.CONVOLUTION)throw new Error(`Convolution effects cannot be merged (${r.name})`);ia("e"+t++,r,e)}let n=e.shaderParts.get(F.FRAGMENT_HEAD),i=e.shaderParts.get(F.FRAGMENT_MAIN_IMAGE),s=e.shaderParts.get(F.FRAGMENT_MAIN_UV);const a=/\bblend\b/g;for(const r of e.blendModes.values())n+=r.getShaderCode().replace(a,`blend${r.blendFunction}`)+`
`;e.attributes&be.DEPTH?(e.readDepth&&(i=`float depth = readDepth(UV);

	`+i),this.needsDepthTexture=this.getDepthTexture()===null):this.needsDepthTexture=!1,e.colorSpace===se&&(i+=`color0 = sRGBToLinear(color0);
	`),e.uvTransformation?(s=`vec2 transformedUv = vUv;
`+s,e.defines.set("UV","transformedUv")):e.defines.set("UV","vUv"),e.shaderParts.set(F.FRAGMENT_HEAD,n),e.shaderParts.set(F.FRAGMENT_MAIN_IMAGE,i),e.shaderParts.set(F.FRAGMENT_MAIN_UV,s);for(const[r,l]of e.shaderParts)l!==null&&e.shaderParts.set(r,l.trim().replace(/^#/,`
#`));this.skipRendering=t===0,this.needsSwap=!this.skipRendering,this.fullscreenMaterial.setShaderData(e)}recompile(){this.updateMaterial()}getDepthTexture(){return this.fullscreenMaterial.depthBuffer}setDepthTexture(e,t=Re){this.fullscreenMaterial.depthBuffer=e,this.fullscreenMaterial.depthPacking=t;for(const n of this.effects)n.setDepthTexture(e,t)}render(e,t,n,i,s){for(const a of this.effects)a.update(e,t,i);if(!this.skipRendering||this.renderToScreen){const a=this.fullscreenMaterial;a.inputBuffer=t.texture,a.time+=i*this.timeScale,e.setRenderTarget(this.renderToScreen?null:n),e.render(this.scene,this.camera)}}setSize(e,t){this.fullscreenMaterial.setSize(e,t);for(const n of this.effects)n.setSize(e,t)}initialize(e,t,n){this.renderer=e;for(const i of this.effects)i.initialize(e,t,n);this.updateMaterial(),n!==void 0&&n!==Ue&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}dispose(){super.dispose();for(const e of this.effects)e.removeEventListener("change",this.listener),e.dispose()}handleEvent(e){switch(e.type){case"change":this.recompile();break}}},ra=class extends ne{constructor(e,t,{renderTarget:n,resolutionScale:i=1,width:s=Y.AUTO_SIZE,height:a=Y.AUTO_SIZE,resolutionX:r=s,resolutionY:l=a}={}){super("NormalPass"),this.needsSwap=!1,this.renderPass=new Qt(e,t,new ms);const o=this.renderPass;o.ignoreBackground=!0,o.skipShadowMapUpdate=!0;const u=o.getClearPass();u.overrideClearColor=new pe(7829503),u.overrideClearAlpha=1,this.renderTarget=n,this.renderTarget===void 0&&(this.renderTarget=new ue(1,1,{minFilter:Qe,magFilter:Qe}),this.renderTarget.texture.name="NormalPass.Target");const c=this.resolution=new Y(this,r,l,i);c.addEventListener("change",d=>this.setSize(c.baseWidth,c.baseHeight))}set mainScene(e){this.renderPass.mainScene=e}set mainCamera(e){this.renderPass.mainCamera=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}render(e,t,n,i,s){const a=this.renderToScreen?null:this.renderTarget;this.renderPass.render(e,a,a)}setSize(e,t){const n=this.resolution;n.setBaseSize(e,t),this.renderTarget.setSize(n.width,n.height)}};const Ni=C.createContext(null),ei=e=>(e.getAttributes()&be.CONVOLUTION)===be.CONVOLUTION,aa=de.memo(C.forwardRef(({children:e,camera:t,scene:n,resolutionScale:i,enabled:s=!0,renderPriority:a=1,autoClear:r=!0,depthBuffer:l,enableNormalPass:o,stencilBuffer:u,multisampling:c=8,frameBufferType:d=xs},f)=>{const{gl:p,scene:S,camera:A,size:x}=Ln(),y=n||S,v=t||A,[h,w,T]=C.useMemo(()=>{const g=Ns(),b=new Ys(p,{depthBuffer:l,stencilBuffer:u,multisampling:c>0&&g?c:0,frameBufferType:d});b.addPass(new Qt(y,v));let P=null,E=null;return o&&(E=new ra(y,v),E.enabled=!1,b.addPass(E),i!==void 0&&g&&(P=new Jr({normalBuffer:E.texture,resolutionScale:i}),P.enabled=!1,b.addPass(P))),[b,E,P]},[v,p,l,u,c,d,y,o,i]);C.useEffect(()=>h==null?void 0:h.setSize(x.width,x.height),[h,x]),Ci((g,b)=>{if(s){const P=p.autoClear;p.autoClear=r,u&&!r&&p.clearStencil(),h.render(b),p.autoClear=P}},s?a:0);const M=C.useRef(null),_=gs(M);C.useLayoutEffect(()=>{const g=[];if(M.current&&_.current&&h){const b=_.current.objects;for(let P=0;P<b.length;P++){const E=b[P];if(E instanceof wn){const R=[E];if(!ei(E)){let N=null;for(;(N=b[P+1])instanceof wn&&!ei(N);)R.push(N),P++}const L=new sa(v,...R);g.push(L)}else E instanceof ne&&g.push(E)}for(const P of g)h==null||h.addPass(P);w&&(w.enabled=!0),T&&(T.enabled=!0)}return()=>{for(const b of g)h==null||h.removePass(b);w&&(w.enabled=!1),T&&(T.enabled=!1)}},[h,e,v,w,T,_]),C.useEffect(()=>{const g=p.toneMapping;return p.toneMapping=ys,()=>{p.toneMapping=g}},[]);const m=C.useMemo(()=>({composer:h,normalPass:w,downSamplingPass:T,resolutionScale:i,camera:v,scene:y}),[h,w,T,i,v,y]);return C.useImperativeHandle(f,()=>h,[h]),z(Ni.Provider,{value:m,children:z("group",{ref:M,children:e})})})),ti=e=>typeof e=="object"&&e!=null&&"current"in e?e.current:e,oa=C.forwardRef(function({selection:t=[],selectionLayer:n=10,blendFunction:i,patternTexture:s,edgeStrength:a,pulseSpeed:r,visibleEdgeColor:l,hiddenEdgeColor:o,width:u,height:c,kernelSize:d,blur:f,xRay:p,...S},A){const x=Ln(T=>T.invalidate),{scene:y,camera:v}=C.useContext(Ni),h=C.useMemo(()=>new Kr(y,v,{blendFunction:i,patternTexture:s,edgeStrength:a,pulseSpeed:r,visibleEdgeColor:l,hiddenEdgeColor:o,width:u,height:c,kernelSize:d,blur:f,xRay:p,...S}),[i,f,v,a,c,o,d,s,r,y,l,u,p]),w=C.useContext(zi);return C.useEffect(()=>{if(!w&&t)return h.selection.set(Array.isArray(t)?t.map(ti):[ti(t)]),x(),()=>{h.selection.clear(),x()}},[h,t,w,x]),C.useEffect(()=>{h.selectionLayer=n,x()},[h,x,n]),C.useRef(),C.useEffect(()=>{var T;if(w&&w.enabled&&(T=w.selected)!=null&&T.length)return h.selection.set(w.selected),x(),()=>{h.selection.clear(),x()}},[w,h.selection,x]),C.useEffect(()=>()=>{h.dispose()},[h]),z("primitive",{ref:A,object:h})});/**
 * postprocessing v6.30.2 build Fri Mar 31 2023
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2023 Raoul van Rüschen
 * @license Zlib
 */var k={SKIP:9,SET:30,ADD:0,ALPHA:1,AVERAGE:2,COLOR:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,DIVIDE:8,DST:9,EXCLUSION:10,HARD_LIGHT:11,HARD_MIX:12,HUE:13,INVERT:14,INVERT_RGB:15,LIGHTEN:16,LINEAR_BURN:17,LINEAR_DODGE:18,LINEAR_LIGHT:19,LUMINOSITY:20,MULTIPLY:21,NEGATION:22,NORMAL:23,OVERLAY:24,PIN_LIGHT:25,REFLECT:26,SATURATION:27,SCREEN:28,SOFT_LIGHT:29,SRC:30,SUBTRACT:31,VIVID_LIGHT:32},la={NONE:0,DEPTH:1,CONVOLUTION:2},ca=new Ei,Ee=null;function ua(){if(Ee===null){const e=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),t=new Float32Array([0,0,2,0,0,2]);Ee=new Gt,Ee.setAttribute!==void 0?(Ee.setAttribute("position",new me(e,3)),Ee.setAttribute("uv",new me(t,2))):(Ee.addAttribute("position",new me(e,3)),Ee.addAttribute("uv",new me(t,2)))}return Ee}var Ui=class{constructor(e="Pass",t=new Ht,n=ca){this.name=e,this.renderer=null,this.scene=t,this.camera=n,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}get renderToScreen(){return!this.rtt}set renderToScreen(e){if(this.rtt===e){const t=this.fullscreenMaterial;t!==null&&(t.needsUpdate=!0),this.rtt=!e}}set mainScene(e){}set mainCamera(e){}setRenderer(e){this.renderer=e}isEnabled(){return this.enabled}setEnabled(e){this.enabled=e}get fullscreenMaterial(){return this.screen!==null?this.screen.material:null}set fullscreenMaterial(e){let t=this.screen;t!==null?t.material=e:(t=new Kt(ua(),e),t.frustumCulled=!1,this.scene===null&&(this.scene=new Ht),this.scene.add(t),this.screen=t)}getFullscreenMaterial(){return this.fullscreenMaterial}setFullscreenMaterial(e){this.fullscreenMaterial=e}getDepthTexture(){return null}setDepthTexture(e,t=Re){}render(e,t,n,i,s){throw new Error("Render method not implemented!")}setSize(e,t){}initialize(e,t,n){}dispose(){for(const e of Object.keys(this)){const t=this[e];(t instanceof ue||t instanceof Zt||t instanceof Yt||t instanceof Ui)&&this[e].dispose()}}};new pe;var fa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}",da="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}",ha="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}",pa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",ma="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}",va="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}",ga="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}",ya="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}",xa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}",Sa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}",ba="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}",Ta="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}",wa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}",Aa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}",_a="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}",Ea="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}",Ca="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}",Ma="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}",Pa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}",Ba="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",Ra="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}",za="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}",Da="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}",La="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}",Na="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}",Ua="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}",Ia="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",Oa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}",ka="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}",Fa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",Ha="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}",Va="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}",Ga=new Map([[k.ADD,fa],[k.ALPHA,da],[k.AVERAGE,ha],[k.COLOR,pa],[k.COLOR_BURN,ma],[k.COLOR_DODGE,va],[k.DARKEN,ga],[k.DIFFERENCE,ya],[k.DIVIDE,xa],[k.DST,null],[k.EXCLUSION,Sa],[k.HARD_LIGHT,ba],[k.HARD_MIX,Ta],[k.HUE,wa],[k.INVERT,Aa],[k.INVERT_RGB,_a],[k.LIGHTEN,Ea],[k.LINEAR_BURN,Ca],[k.LINEAR_DODGE,Ma],[k.LINEAR_LIGHT,Pa],[k.LUMINOSITY,Ba],[k.MULTIPLY,Ra],[k.NEGATION,za],[k.NORMAL,Da],[k.OVERLAY,La],[k.PIN_LIGHT,Na],[k.REFLECT,Ua],[k.SATURATION,Ia],[k.SCREEN,Oa],[k.SOFT_LIGHT,ka],[k.SRC,Fa],[k.SUBTRACT,Ha],[k.VIVID_LIGHT,Va]]),$a=class extends yt{constructor(e,t=1){super(),this._blendFunction=e,this.opacity=new H(t)}getOpacity(){return this.opacity.value}setOpacity(e){this.opacity.value=e}get blendFunction(){return this._blendFunction}set blendFunction(e){this._blendFunction=e,this.dispatchEvent({type:"change"})}getBlendFunction(){return this.blendFunction}setBlendFunction(e){this.blendFunction=e}getShaderCode(){return Ga.get(this.blendFunction)}},ja=class extends yt{constructor(e,t,{attributes:n=la.NONE,blendFunction:i=k.NORMAL,defines:s=new Map,uniforms:a=new Map,extensions:r=null,vertexShader:l=null}={}){super(),this.name=e,this.renderer=null,this.attributes=n,this.fragmentShader=t,this.vertexShader=l,this.defines=s,this.uniforms=a,this.extensions=r,this.blendMode=new $a(i),this.blendMode.addEventListener("change",o=>this.setChanged()),this._inputColorSpace=Ss,this._outputColorSpace=null}get inputColorSpace(){return this._inputColorSpace}set inputColorSpace(e){this._inputColorSpace=e,this.setChanged()}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e,this.setChanged()}set mainScene(e){}set mainCamera(e){}getName(){return this.name}setRenderer(e){this.renderer=e}getDefines(){return this.defines}getUniforms(){return this.uniforms}getExtensions(){return this.extensions}getBlendMode(){return this.blendMode}getAttributes(){return this.attributes}setAttributes(e){this.attributes=e,this.setChanged()}getFragmentShader(){return this.fragmentShader}setFragmentShader(e){this.fragmentShader=e,this.setChanged()}getVertexShader(){return this.vertexShader}setVertexShader(e){this.vertexShader=e,this.setChanged()}setChanged(){this.dispatchEvent({type:"change"})}setDepthTexture(e,t=Re){}update(e,t,n){}setSize(e,t){}initialize(e,t,n){}dispose(){for(const e of Object.keys(this)){const t=this[e];(t instanceof ue||t instanceof Zt||t instanceof Yt||t instanceof Ui)&&this[e].dispose()}}};new D;new Te;new pe;new D;new D;const Wa=`
    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor)
    {
        outputColor = vec4(uv, 1.0, 1.0);
    }
`;class qa extends ja{constructor(){super("HighlightEffect",Wa,{})}}function Xa(){return new qa,z(Z,{})}const Ii=0,Ka=1,Za=2,ni=2,sn=1.25,ii=1,mt=6*4+4+4,Jt=65535,Ya=Math.pow(2,-24),rn=Symbol("SKIP_GENERATION");function Qa(e){return e.index?e.index.count:e.attributes.position.count}function et(e){return Qa(e)/3}function Ja(e,t=ArrayBuffer){return e>65535?new Uint32Array(new t(4*e)):new Uint16Array(new t(2*e))}function eo(e,t){if(!e.index){const n=e.attributes.position.count,i=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Ja(n,i);e.setIndex(new me(s,1));for(let a=0;a<n;a++)s[a]=a}}function Oi(e){const t=et(e),n=e.drawRange,i=n.start/3,s=(n.start+n.count)/3,a=Math.max(0,i),r=Math.min(t,s)-a;return[{offset:Math.floor(a),count:Math.floor(r)}]}function ki(e){if(!e.groups||!e.groups.length)return Oi(e);const t=[],n=new Set,i=e.drawRange,s=i.start/3,a=(i.start+i.count)/3;for(const l of e.groups){const o=l.start/3,u=(l.start+l.count)/3;n.add(Math.max(s,o)),n.add(Math.min(a,u))}const r=Array.from(n.values()).sort((l,o)=>l-o);for(let l=0;l<r.length-1;l++){const o=r[l],u=r[l+1];t.push({offset:Math.floor(o),count:Math.floor(u-o)})}return t}function to(e){if(e.groups.length===0)return!1;const t=et(e),n=ki(e).sort((a,r)=>a.offset-r.offset),i=n[n.length-1];i.count=Math.min(t-i.offset,i.count);let s=0;return n.forEach(({count:a})=>s+=a),t!==s}function an(e,t,n,i,s){let a=1/0,r=1/0,l=1/0,o=-1/0,u=-1/0,c=-1/0,d=1/0,f=1/0,p=1/0,S=-1/0,A=-1/0,x=-1/0;for(let y=t*6,v=(t+n)*6;y<v;y+=6){const h=e[y+0],w=e[y+1],T=h-w,M=h+w;T<a&&(a=T),M>o&&(o=M),h<d&&(d=h),h>S&&(S=h);const _=e[y+2],m=e[y+3],g=_-m,b=_+m;g<r&&(r=g),b>u&&(u=b),_<f&&(f=_),_>A&&(A=_);const P=e[y+4],E=e[y+5],R=P-E,L=P+E;R<l&&(l=R),L>c&&(c=L),P<p&&(p=P),P>x&&(x=P)}i[0]=a,i[1]=r,i[2]=l,i[3]=o,i[4]=u,i[5]=c,s[0]=d,s[1]=f,s[2]=p,s[3]=S,s[4]=A,s[5]=x}function no(e,t=null,n=null,i=null){const s=e.attributes.position,a=e.index?e.index.array:null,r=et(e),l=s.normalized;let o;t===null?(o=new Float32Array(r*6*4),n=0,i=r):(o=t,n=n||0,i=i||r);const u=s.array,c=s.offset||0;let d=3;s.isInterleavedBufferAttribute&&(d=s.data.stride);const f=["getX","getY","getZ"];for(let p=n;p<n+i;p++){const S=p*3,A=p*6;let x=S+0,y=S+1,v=S+2;a&&(x=a[x],y=a[y],v=a[v]),l||(x=x*d+c,y=y*d+c,v=v*d+c);for(let h=0;h<3;h++){let w,T,M;l?(w=s[f[h]](x),T=s[f[h]](y),M=s[f[h]](v)):(w=u[x+h],T=u[y+h],M=u[v+h]);let _=w;T<_&&(_=T),M<_&&(_=M);let m=w;T>m&&(m=T),M>m&&(m=M);const g=(m-_)/2,b=h*2;o[A+b+0]=_+g,o[A+b+1]=g+(Math.abs(_)+g)*Ya}}return o}function q(e,t,n){return n.min.x=t[e],n.min.y=t[e+1],n.min.z=t[e+2],n.max.x=t[e+3],n.max.y=t[e+4],n.max.z=t[e+5],n}function si(e){let t=-1,n=-1/0;for(let i=0;i<3;i++){const s=e[i+3]-e[i];s>n&&(n=s,t=i)}return t}function ri(e,t){t.set(e)}function ai(e,t,n){let i,s;for(let a=0;a<3;a++){const r=a+3;i=e[a],s=t[a],n[a]=i<s?i:s,i=e[r],s=t[r],n[r]=i>s?i:s}}function At(e,t,n){for(let i=0;i<3;i++){const s=t[e+2*i],a=t[e+2*i+1],r=s-a,l=s+a;r<n[i]&&(n[i]=r),l>n[i+3]&&(n[i+3]=l)}}function rt(e){const t=e[3]-e[0],n=e[4]-e[1],i=e[5]-e[2];return 2*(t*n+n*i+i*t)}const xe=32,io=(e,t)=>e.candidate-t.candidate,Ce=new Array(xe).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),_t=new Float32Array(6);function so(e,t,n,i,s,a){let r=-1,l=0;if(a===Ii)r=si(t),r!==-1&&(l=(t[r]+t[r+3])/2);else if(a===Ka)r=si(e),r!==-1&&(l=ro(n,i,s,r));else if(a===Za){const o=rt(e);let u=sn*s;const c=i*6,d=(i+s)*6;for(let f=0;f<3;f++){const p=t[f],x=(t[f+3]-p)/xe;if(s<xe/4){const y=[...Ce];y.length=s;let v=0;for(let w=c;w<d;w+=6,v++){const T=y[v];T.candidate=n[w+2*f],T.count=0;const{bounds:M,leftCacheBounds:_,rightCacheBounds:m}=T;for(let g=0;g<3;g++)m[g]=1/0,m[g+3]=-1/0,_[g]=1/0,_[g+3]=-1/0,M[g]=1/0,M[g+3]=-1/0;At(w,n,M)}y.sort(io);let h=s;for(let w=0;w<h;w++){const T=y[w];for(;w+1<h&&y[w+1].candidate===T.candidate;)y.splice(w+1,1),h--}for(let w=c;w<d;w+=6){const T=n[w+2*f];for(let M=0;M<h;M++){const _=y[M];T>=_.candidate?At(w,n,_.rightCacheBounds):(At(w,n,_.leftCacheBounds),_.count++)}}for(let w=0;w<h;w++){const T=y[w],M=T.count,_=s-T.count,m=T.leftCacheBounds,g=T.rightCacheBounds;let b=0;M!==0&&(b=rt(m)/o);let P=0;_!==0&&(P=rt(g)/o);const E=ii+sn*(b*M+P*_);E<u&&(r=f,u=E,l=T.candidate)}}else{for(let h=0;h<xe;h++){const w=Ce[h];w.count=0,w.candidate=p+x+h*x;const T=w.bounds;for(let M=0;M<3;M++)T[M]=1/0,T[M+3]=-1/0}for(let h=c;h<d;h+=6){let M=~~((n[h+2*f]-p)/x);M>=xe&&(M=xe-1);const _=Ce[M];_.count++,At(h,n,_.bounds)}const y=Ce[xe-1];ri(y.bounds,y.rightCacheBounds);for(let h=xe-2;h>=0;h--){const w=Ce[h],T=Ce[h+1];ai(w.bounds,T.rightCacheBounds,w.rightCacheBounds)}let v=0;for(let h=0;h<xe-1;h++){const w=Ce[h],T=w.count,M=w.bounds,m=Ce[h+1].rightCacheBounds;T!==0&&(v===0?ri(M,_t):ai(M,_t,_t)),v+=T;let g=0,b=0;v!==0&&(g=rt(_t)/o);const P=s-v;P!==0&&(b=rt(m)/o);const E=ii+sn*(g*v+b*P);E<u&&(r=f,u=E,l=w.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);return{axis:r,pos:l}}function ro(e,t,n,i){let s=0;for(let a=t,r=t+n;a<r;a++)s+=e[a*6+i*2];return s/n}class on{constructor(){this.boundingData=new Float32Array(6)}}function ao(e,t,n,i,s,a){let r=i,l=i+s-1;const o=a.pos,u=a.axis*2;for(;;){for(;r<=l&&n[r*6+u]<o;)r++;for(;r<=l&&n[l*6+u]>=o;)l--;if(r<l){for(let c=0;c<3;c++){let d=t[r*3+c];t[r*3+c]=t[l*3+c],t[l*3+c]=d}for(let c=0;c<6;c++){let d=n[r*6+c];n[r*6+c]=n[l*6+c],n[l*6+c]=d}r++,l--}else return r}}function oo(e,t,n,i,s,a){let r=i,l=i+s-1;const o=a.pos,u=a.axis*2;for(;;){for(;r<=l&&n[r*6+u]<o;)r++;for(;r<=l&&n[l*6+u]>=o;)l--;if(r<l){let c=e[r];e[r]=e[l],e[l]=c;for(let d=0;d<6;d++){let f=n[r*6+d];n[r*6+d]=n[l*6+d],n[l*6+d]=f}r++,l--}else return r}}function ee(e,t){return t[e+15]===65535}function te(e,t){return t[e+6]}function re(e,t){return t[e+14]}function ae(e){return e+8}function oe(e,t){return t[e+6]}function Fi(e,t){return t[e+7]}let Hi,pt,Ft,Vi;const lo=Math.pow(2,32);function An(e){return"count"in e?1:1+An(e.left)+An(e.right)}function co(e,t,n){return Hi=new Float32Array(n),pt=new Uint32Array(n),Ft=new Uint16Array(n),Vi=new Uint8Array(n),_n(e,t)}function _n(e,t){const n=e/4,i=e/2,s="count"in t,a=t.boundingData;for(let r=0;r<6;r++)Hi[n+r]=a[r];if(s)if(t.buffer){const r=t.buffer;Vi.set(new Uint8Array(r),e);for(let l=e,o=e+r.byteLength;l<o;l+=mt){const u=l/2;ee(u,Ft)||(pt[l/4+6]+=n)}return e+r.byteLength}else{const r=t.offset,l=t.count;return pt[n+6]=r,Ft[i+14]=l,Ft[i+15]=Jt,e+mt}else{const r=t.left,l=t.right,o=t.splitAxis;let u;if(u=_n(e+mt,r),u/4>lo)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return pt[n+6]=u/4,u=_n(u,l),pt[n+7]=o,u}}function uo(e,t){const n=(e.index?e.index.count:e.attributes.position.count)/3,i=n>2**16,s=i?4:2,a=t?new SharedArrayBuffer(n*s):new ArrayBuffer(n*s),r=i?new Uint32Array(a):new Uint16Array(a);for(let l=0,o=r.length;l<o;l++)r[l]=l;return r}function fo(e,t,n,i,s){const{maxDepth:a,verbose:r,maxLeafTris:l,strategy:o,onProgress:u,indirect:c}=s,d=e._indirectBuffer,f=e.geometry,p=f.index?f.index.array:null,S=c?oo:ao,A=et(f),x=new Float32Array(6);let y=!1;const v=new on;return an(t,n,i,v.boundingData,x),w(v,n,i,x),v;function h(T){u&&u(T/A)}function w(T,M,_,m=null,g=0){if(!y&&g>=a&&(y=!0,r&&(console.warn(`MeshBVH: Max depth of ${a} reached when generating BVH. Consider increasing maxDepth.`),console.warn(f))),_<=l||g>=a)return h(M+_),T.offset=M,T.count=_,T;const b=so(T.boundingData,m,t,M,_,o);if(b.axis===-1)return h(M+_),T.offset=M,T.count=_,T;const P=S(d,p,t,M,_,b);if(P===M||P===M+_)h(M+_),T.offset=M,T.count=_;else{T.splitAxis=b.axis;const E=new on,R=M,L=P-M;T.left=E,an(t,R,L,E.boundingData,x),w(E,R,L,x,g+1);const N=new on,$=P,ie=_-L;T.right=N,an(t,$,ie,N.boundingData,x),w(N,$,ie,x,g+1)}return T}}function ho(e,t){const n=e.geometry;t.indirect&&(e._indirectBuffer=uo(n,t.useSharedArrayBuffer),to(n)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),e._indirectBuffer||eo(n,t);const i=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=no(n),a=t.indirect?Oi(n):ki(n);e._roots=a.map(r=>{const l=fo(e,s,r.offset,r.count,t),o=An(l),u=new i(mt*o);return co(0,l,u),u})}class we{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,n){let i=1/0,s=-1/0;for(let a=0,r=t.length;a<r;a++){const o=t[a][n];i=o<i?o:i,s=o>s?o:s}this.min=i,this.max=s}setFromPoints(t,n){let i=1/0,s=-1/0;for(let a=0,r=n.length;a<r;a++){const l=n[a],o=t.dot(l);i=o<i?o:i,s=o>s?o:s}this.min=i,this.max=s}isSeparated(t){return this.min>t.max||t.min>this.max}}we.prototype.setFromBox=function(){const e=new D;return function(n,i){const s=i.min,a=i.max;let r=1/0,l=-1/0;for(let o=0;o<=1;o++)for(let u=0;u<=1;u++)for(let c=0;c<=1;c++){e.x=s.x*o+a.x*(1-o),e.y=s.y*u+a.y*(1-u),e.z=s.z*c+a.z*(1-c);const d=n.dot(e);r=Math.min(d,r),l=Math.max(d,l)}this.min=r,this.max=l}}();const po=function(){const e=new D,t=new D,n=new D;return function(s,a,r){const l=s.start,o=e,u=a.start,c=t;n.subVectors(l,u),e.subVectors(s.end,s.start),t.subVectors(a.end,a.start);const d=n.dot(c),f=c.dot(o),p=c.dot(c),S=n.dot(o),x=o.dot(o)*p-f*f;let y,v;x!==0?y=(d*f-S*p)/x:y=0,v=(d+y*f)/p,r.x=y,r.y=v}}(),kn=function(){const e=new X,t=new D,n=new D;return function(s,a,r,l){po(s,a,e);let o=e.x,u=e.y;if(o>=0&&o<=1&&u>=0&&u<=1){s.at(o,r),a.at(u,l);return}else if(o>=0&&o<=1){u<0?a.at(0,l):a.at(1,l),s.closestPointToPoint(l,!0,r);return}else if(u>=0&&u<=1){o<0?s.at(0,r):s.at(1,r),a.closestPointToPoint(r,!0,l);return}else{let c;o<0?c=s.start:c=s.end;let d;u<0?d=a.start:d=a.end;const f=t,p=n;if(s.closestPointToPoint(d,!0,t),a.closestPointToPoint(c,!0,n),f.distanceToSquared(d)<=p.distanceToSquared(c)){r.copy(f),l.copy(d);return}else{r.copy(c),l.copy(p);return}}}}(),mo=function(){const e=new D,t=new D,n=new Mi,i=new Se;return function(a,r){const{radius:l,center:o}=a,{a:u,b:c,c:d}=r;if(i.start=u,i.end=c,i.closestPointToPoint(o,!0,e).distanceTo(o)<=l||(i.start=u,i.end=d,i.closestPointToPoint(o,!0,e).distanceTo(o)<=l)||(i.start=c,i.end=d,i.closestPointToPoint(o,!0,e).distanceTo(o)<=l))return!0;const A=r.getPlane(n);if(Math.abs(A.distanceToPoint(o))<=l){const y=A.projectPoint(o,t);if(r.containsPoint(y))return!0}return!1}}(),vo=1e-15;function ln(e){return Math.abs(e)<vo}class he extends dt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new D),this.satBounds=new Array(4).fill().map(()=>new we),this.points=[this.a,this.b,this.c],this.sphere=new bs,this.plane=new Mi,this.needsUpdate=!0}intersectsSphere(t){return mo(t,this)}update(){const t=this.a,n=this.b,i=this.c,s=this.points,a=this.satAxes,r=this.satBounds,l=a[0],o=r[0];this.getNormal(l),o.setFromPoints(l,s);const u=a[1],c=r[1];u.subVectors(t,n),c.setFromPoints(u,s);const d=a[2],f=r[2];d.subVectors(n,i),f.setFromPoints(d,s);const p=a[3],S=r[3];p.subVectors(i,t),S.setFromPoints(p,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(l,t),this.needsUpdate=!1}}he.prototype.closestPointToSegment=function(){const e=new D,t=new D,n=new Se;return function(s,a=null,r=null){const{start:l,end:o}=s,u=this.points;let c,d=1/0;for(let f=0;f<3;f++){const p=(f+1)%3;n.start.copy(u[f]),n.end.copy(u[p]),kn(n,s,e,t),c=e.distanceToSquared(t),c<d&&(d=c,a&&a.copy(e),r&&r.copy(t))}return this.closestPointToPoint(l,e),c=l.distanceToSquared(e),c<d&&(d=c,a&&a.copy(e),r&&r.copy(l)),this.closestPointToPoint(o,e),c=o.distanceToSquared(e),c<d&&(d=c,a&&a.copy(e),r&&r.copy(o)),Math.sqrt(d)}}();he.prototype.intersectsTriangle=function(){const e=new he,t=new Array(3),n=new Array(3),i=new we,s=new we,a=new D,r=new D,l=new D,o=new D,u=new D,c=new Se,d=new Se,f=new Se,p=new D;function S(A,x,y){const v=A.points;let h=0,w=-1;for(let T=0;T<3;T++){const{start:M,end:_}=c;M.copy(v[T]),_.copy(v[(T+1)%3]),c.delta(r);const m=ln(x.distanceToPoint(M));if(ln(x.normal.dot(r))&&m){y.copy(c),h=2;break}const g=x.intersectLine(c,p);if(!g&&m&&p.copy(M),(g||m)&&!ln(p.distanceTo(_))){if(h<=1)(h===1?y.start:y.end).copy(p),m&&(w=h);else if(h>=2){(w===1?y.start:y.end).copy(p),h=2;break}if(h++,h===2&&w===-1)break}}return h}return function(x,y=null,v=!1){this.needsUpdate&&this.update(),x.isExtendedTriangle?x.needsUpdate&&x.update():(e.copy(x),e.update(),x=e);const h=this.plane,w=x.plane;if(Math.abs(h.normal.dot(w.normal))>1-1e-10){const T=this.satBounds,M=this.satAxes;n[0]=x.a,n[1]=x.b,n[2]=x.c;for(let g=0;g<4;g++){const b=T[g],P=M[g];if(i.setFromPoints(P,n),b.isSeparated(i))return!1}const _=x.satBounds,m=x.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let g=0;g<4;g++){const b=_[g],P=m[g];if(i.setFromPoints(P,t),b.isSeparated(i))return!1}for(let g=0;g<4;g++){const b=M[g];for(let P=0;P<4;P++){const E=m[P];if(a.crossVectors(b,E),i.setFromPoints(a,t),s.setFromPoints(a,n),i.isSeparated(s))return!1}}return y&&(v||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),y.start.set(0,0,0),y.end.set(0,0,0)),!0}else{const T=S(this,w,d);if(T===1&&x.containsPoint(d.end))return y&&(y.start.copy(d.end),y.end.copy(d.end)),!0;if(T!==2)return!1;const M=S(x,h,f);if(M===1&&this.containsPoint(f.end))return y&&(y.start.copy(f.end),y.end.copy(f.end)),!0;if(M!==2)return!1;if(d.delta(l),f.delta(o),l.dot(o)<0){let R=f.start;f.start=f.end,f.end=R}const _=d.start.dot(l),m=d.end.dot(l),g=f.start.dot(l),b=f.end.dot(l),P=m<g,E=_<b;return _!==b&&g!==m&&P===E?!1:(y&&(u.subVectors(d.start,f.start),u.dot(l)>0?y.start.copy(d.start):y.start.copy(f.start),u.subVectors(d.end,f.end),u.dot(l)<0?y.end.copy(d.end):y.end.copy(f.end)),!0)}}}();he.prototype.distanceToPoint=function(){const e=new D;return function(n){return this.closestPointToPoint(n,e),n.distanceTo(e)}}();he.prototype.distanceToTriangle=function(){const e=new D,t=new D,n=["a","b","c"],i=new Se,s=new Se;return function(r,l=null,o=null){const u=l||o?i:null;if(this.intersectsTriangle(r,u))return(l||o)&&(l&&u.getCenter(l),o&&u.getCenter(o)),0;let c=1/0;for(let d=0;d<3;d++){let f;const p=n[d],S=r[p];this.closestPointToPoint(S,e),f=S.distanceToSquared(e),f<c&&(c=f,l&&l.copy(e),o&&o.copy(S));const A=this[p];r.closestPointToPoint(A,e),f=A.distanceToSquared(e),f<c&&(c=f,l&&l.copy(A),o&&o.copy(e))}for(let d=0;d<3;d++){const f=n[d],p=n[(d+1)%3];i.set(this[f],this[p]);for(let S=0;S<3;S++){const A=n[S],x=n[(S+1)%3];s.set(r[A],r[x]),kn(i,s,e,t);const y=e.distanceToSquared(t);y<c&&(c=y,l&&l.copy(e),o&&o.copy(t))}}return Math.sqrt(c)}}();class J{constructor(t,n,i){this.isOrientedBox=!0,this.min=new D,this.max=new D,this.matrix=new Te,this.invMatrix=new Te,this.points=new Array(8).fill().map(()=>new D),this.satAxes=new Array(3).fill().map(()=>new D),this.satBounds=new Array(3).fill().map(()=>new we),this.alignedSatBounds=new Array(3).fill().map(()=>new we),this.needsUpdate=!1,t&&this.min.copy(t),n&&this.max.copy(n),i&&this.matrix.copy(i)}set(t,n,i){this.min.copy(t),this.max.copy(n),this.matrix.copy(i),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}J.prototype.update=function(){return function(){const t=this.matrix,n=this.min,i=this.max,s=this.points;for(let u=0;u<=1;u++)for(let c=0;c<=1;c++)for(let d=0;d<=1;d++){const f=1*u|2*c|4*d,p=s[f];p.x=u?i.x:n.x,p.y=c?i.y:n.y,p.z=d?i.z:n.z,p.applyMatrix4(t)}const a=this.satBounds,r=this.satAxes,l=s[0];for(let u=0;u<3;u++){const c=r[u],d=a[u],f=1<<u,p=s[f];c.subVectors(l,p),d.setFromPoints(c,s)}const o=this.alignedSatBounds;o[0].setFromPointsField(s,"x"),o[1].setFromPointsField(s,"y"),o[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();J.prototype.intersectsBox=function(){const e=new we;return function(n){this.needsUpdate&&this.update();const i=n.min,s=n.max,a=this.satBounds,r=this.satAxes,l=this.alignedSatBounds;if(e.min=i.x,e.max=s.x,l[0].isSeparated(e)||(e.min=i.y,e.max=s.y,l[1].isSeparated(e))||(e.min=i.z,e.max=s.z,l[2].isSeparated(e)))return!1;for(let o=0;o<3;o++){const u=r[o],c=a[o];if(e.setFromBox(u,n),c.isSeparated(e))return!1}return!0}}();J.prototype.intersectsTriangle=function(){const e=new he,t=new Array(3),n=new we,i=new we,s=new D;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(e.copy(r),e.update(),r=e);const l=this.satBounds,o=this.satAxes;t[0]=r.a,t[1]=r.b,t[2]=r.c;for(let f=0;f<3;f++){const p=l[f],S=o[f];if(n.setFromPoints(S,t),p.isSeparated(n))return!1}const u=r.satBounds,c=r.satAxes,d=this.points;for(let f=0;f<3;f++){const p=u[f],S=c[f];if(n.setFromPoints(S,d),p.isSeparated(n))return!1}for(let f=0;f<3;f++){const p=o[f];for(let S=0;S<4;S++){const A=c[S];if(s.crossVectors(p,A),n.setFromPoints(s,t),i.setFromPoints(s,d),n.isSeparated(i))return!1}}return!0}}();J.prototype.closestPointToPoint=function(){return function(t,n){return this.needsUpdate&&this.update(),n.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),n}}();J.prototype.distanceToPoint=function(){const e=new D;return function(n){return this.closestPointToPoint(n,e),n.distanceTo(e)}}();J.prototype.distanceToBox=function(){const e=["x","y","z"],t=new Array(12).fill().map(()=>new Se),n=new Array(12).fill().map(()=>new Se),i=new D,s=new D;return function(r,l=0,o=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(o||u)&&(r.getCenter(s),this.closestPointToPoint(s,i),r.closestPointToPoint(i,s),o&&o.copy(i),u&&u.copy(s)),0;const c=l*l,d=r.min,f=r.max,p=this.points;let S=1/0;for(let x=0;x<8;x++){const y=p[x];s.copy(y).clamp(d,f);const v=y.distanceToSquared(s);if(v<S&&(S=v,o&&o.copy(y),u&&u.copy(s),v<c))return Math.sqrt(v)}let A=0;for(let x=0;x<3;x++)for(let y=0;y<=1;y++)for(let v=0;v<=1;v++){const h=(x+1)%3,w=(x+2)%3,T=y<<h|v<<w,M=1<<x|y<<h|v<<w,_=p[T],m=p[M];t[A].set(_,m);const b=e[x],P=e[h],E=e[w],R=n[A],L=R.start,N=R.end;L[b]=d[b],L[P]=y?d[P]:f[P],L[E]=v?d[E]:f[P],N[b]=f[b],N[P]=y?d[P]:f[P],N[E]=v?d[E]:f[P],A++}for(let x=0;x<=1;x++)for(let y=0;y<=1;y++)for(let v=0;v<=1;v++){s.x=x?f.x:d.x,s.y=y?f.y:d.y,s.z=v?f.z:d.z,this.closestPointToPoint(s,i);const h=s.distanceToSquared(i);if(h<S&&(S=h,o&&o.copy(i),u&&u.copy(s),h<c))return Math.sqrt(h)}for(let x=0;x<12;x++){const y=t[x];for(let v=0;v<12;v++){const h=n[v];kn(y,h,i,s);const w=i.distanceToSquared(s);if(w<S&&(S=w,o&&o.copy(i),u&&u.copy(s),w<c))return Math.sqrt(w)}}return Math.sqrt(S)}}();class Fn{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class go extends Fn{constructor(){super(()=>new he)}}const le=new go;class yo{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let n=null;this.setBuffer=i=>{n&&t.push(n),n=i,this.float32Array=new Float32Array(i),this.uint16Array=new Uint16Array(i),this.uint32Array=new Uint32Array(i)},this.clearBuffer=()=>{n=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const W=new yo;let Pe,Ye;const Oe=[],Et=new Fn(()=>new ge);function xo(e,t,n,i,s,a){Pe=Et.getPrimitive(),Ye=Et.getPrimitive(),Oe.push(Pe,Ye),W.setBuffer(e._roots[t]);const r=En(0,e.geometry,n,i,s,a);W.clearBuffer(),Et.releasePrimitive(Pe),Et.releasePrimitive(Ye),Oe.pop(),Oe.pop();const l=Oe.length;return l>0&&(Ye=Oe[l-1],Pe=Oe[l-2]),r}function En(e,t,n,i,s=null,a=0,r=0){const{float32Array:l,uint16Array:o,uint32Array:u}=W;let c=e*2;if(ee(c,o)){const f=te(e,u),p=re(c,o);return q(e,l,Pe),i(f,p,!1,r,a+e,Pe)}else{let b=function(E){const{uint16Array:R,uint32Array:L}=W;let N=E*2;for(;!ee(N,R);)E=ae(E),N=E*2;return te(E,L)},P=function(E){const{uint16Array:R,uint32Array:L}=W;let N=E*2;for(;!ee(N,R);)E=oe(E,L),N=E*2;return te(E,L)+re(N,R)};const f=ae(e),p=oe(e,u);let S=f,A=p,x,y,v,h;if(s&&(v=Pe,h=Ye,q(S,l,v),q(A,l,h),x=s(v),y=s(h),y<x)){S=p,A=f;const E=x;x=y,y=E,v=h}v||(v=Pe,q(S,l,v));const w=ee(S*2,o),T=n(v,w,x,r+1,a+S);let M;if(T===ni){const E=b(S),L=P(S)-E;M=i(E,L,!0,r+1,a+S,v)}else M=T&&En(S,t,n,i,s,a,r+1);if(M)return!0;h=Ye,q(A,l,h);const _=ee(A*2,o),m=n(h,_,y,r+1,a+A);let g;if(m===ni){const E=b(A),L=P(A)-E;g=i(E,L,!0,r+1,a+A,h)}else g=m&&En(A,t,n,i,s,a,r+1);return!!g}}const at=new D,cn=new D;function So(e,t,n={},i=0,s=1/0){const a=i*i,r=s*s;let l=1/0,o=null;if(e.shapecast({boundsTraverseOrder:c=>(at.copy(t).clamp(c.min,c.max),at.distanceToSquared(t)),intersectsBounds:(c,d,f)=>f<l&&f<r,intersectsTriangle:(c,d)=>{c.closestPointToPoint(t,at);const f=t.distanceToSquared(at);return f<l&&(cn.copy(at),l=f,o=d),f<a}}),l===1/0)return null;const u=Math.sqrt(l);return n.point?n.point.copy(cn):n.point=cn.clone(),n.distance=u,n.faceIndex=o,n}const ke=new D,Fe=new D,He=new D,Ct=new X,Mt=new X,Pt=new X,oi=new D,li=new D,ci=new D,Bt=new D;function bo(e,t,n,i,s,a){let r;return a===Ne?r=e.intersectTriangle(i,n,t,!0,s):r=e.intersectTriangle(t,n,i,a!==ft,s),r===null?null:{distance:e.origin.distanceTo(s),point:s.clone()}}function To(e,t,n,i,s,a,r,l,o){ke.fromBufferAttribute(t,a),Fe.fromBufferAttribute(t,r),He.fromBufferAttribute(t,l);const u=bo(e,ke,Fe,He,Bt,o);if(u){i&&(Ct.fromBufferAttribute(i,a),Mt.fromBufferAttribute(i,r),Pt.fromBufferAttribute(i,l),u.uv=dt.getInterpolation(Bt,ke,Fe,He,Ct,Mt,Pt,new X)),s&&(Ct.fromBufferAttribute(s,a),Mt.fromBufferAttribute(s,r),Pt.fromBufferAttribute(s,l),u.uv1=dt.getInterpolation(Bt,ke,Fe,He,Ct,Mt,Pt,new X)),n&&(oi.fromBufferAttribute(n,a),li.fromBufferAttribute(n,r),ci.fromBufferAttribute(n,l),u.normal=dt.getInterpolation(Bt,ke,Fe,He,oi,li,ci,new D),u.normal.dot(e.direction)>0&&u.normal.multiplyScalar(-1));const c={a,b:r,c:l,normal:new D,materialIndex:0};dt.getNormal(ke,Fe,He,c.normal),u.face=c,u.faceIndex=a}return u}function en(e,t,n,i,s){const a=i*3;let r=a+0,l=a+1,o=a+2;const u=e.index;e.index&&(r=u.getX(r),l=u.getX(l),o=u.getX(o));const{position:c,normal:d,uv:f,uv1:p}=e.attributes,S=To(n,c,d,f,p,r,l,o,t);return S?(S.faceIndex=i,s&&s.push(S),S):null}function K(e,t,n,i){const s=e.a,a=e.b,r=e.c;let l=t,o=t+1,u=t+2;n&&(l=n.getX(l),o=n.getX(o),u=n.getX(u)),s.x=i.getX(l),s.y=i.getY(l),s.z=i.getZ(l),a.x=i.getX(o),a.y=i.getY(o),a.z=i.getZ(o),r.x=i.getX(u),r.y=i.getY(u),r.z=i.getZ(u)}function wo(e,t,n,i,s,a){const{geometry:r,_indirectBuffer:l}=e;for(let o=i,u=i+s;o<u;o++)en(r,t,n,o,a)}function Ao(e,t,n,i,s){const{geometry:a,_indirectBuffer:r}=e;let l=1/0,o=null;for(let u=i,c=i+s;u<c;u++){let d;d=en(a,t,n,u),d&&d.distance<l&&(o=d,l=d.distance)}return o}function _o(e,t,n,i,s,a,r){const{geometry:l}=n,{index:o}=l,u=l.attributes.position;for(let c=e,d=t+e;c<d;c++){let f;if(f=c,K(r,f*3,o,u),r.needsUpdate=!0,i(r,f,s,a))return!0}return!1}function Eo(e,t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=e.geometry,i=n.index?n.index.array:null,s=n.attributes.position;let a,r,l,o,u=0;const c=e._roots;for(let f=0,p=c.length;f<p;f++)a=c[f],r=new Uint32Array(a),l=new Uint16Array(a),o=new Float32Array(a),d(0,u),u+=a.byteLength;function d(f,p,S=!1){const A=f*2;if(l[A+15]===Jt){const y=r[f+6],v=l[A+14];let h=1/0,w=1/0,T=1/0,M=-1/0,_=-1/0,m=-1/0;for(let g=3*y,b=3*(y+v);g<b;g++){let P=i[g];const E=s.getX(P),R=s.getY(P),L=s.getZ(P);E<h&&(h=E),E>M&&(M=E),R<w&&(w=R),R>_&&(_=R),L<T&&(T=L),L>m&&(m=L)}return o[f+0]!==h||o[f+1]!==w||o[f+2]!==T||o[f+3]!==M||o[f+4]!==_||o[f+5]!==m?(o[f+0]=h,o[f+1]=w,o[f+2]=T,o[f+3]=M,o[f+4]=_,o[f+5]=m,!0):!1}else{const y=f+8,v=r[f+6],h=y+p,w=v+p;let T=S,M=!1,_=!1;t?T||(M=t.has(h),_=t.has(w),T=!M&&!_):(M=!0,_=!0);const m=T||M,g=T||_;let b=!1;m&&(b=d(y,p,T));let P=!1;g&&(P=d(v,p,T));const E=b||P;if(E)for(let R=0;R<3;R++){const L=y+R,N=v+R,$=o[L],ie=o[L+3],ye=o[N],j=o[N+3];o[f+R]=$<ye?$:ye,o[f+R+3]=ie>j?ie:j}return E}}}function Be(e,t,n){let i,s,a,r,l,o;const u=1/n.direction.x,c=1/n.direction.y,d=1/n.direction.z,f=n.origin.x,p=n.origin.y,S=n.origin.z;let A=t[e],x=t[e+3],y=t[e+1],v=t[e+3+1],h=t[e+2],w=t[e+3+2];return u>=0?(i=(A-f)*u,s=(x-f)*u):(i=(x-f)*u,s=(A-f)*u),c>=0?(a=(y-p)*c,r=(v-p)*c):(a=(v-p)*c,r=(y-p)*c),!(i>r||a>s||((a>i||isNaN(i))&&(i=a),(r<s||isNaN(s))&&(s=r),d>=0?(l=(h-S)*d,o=(w-S)*d):(l=(w-S)*d,o=(h-S)*d),i>o||l>s)||((o<s||s!==s)&&(s=o),s<0))}function Co(e,t,n,i,s,a){const{geometry:r,_indirectBuffer:l}=e;for(let o=i,u=i+s;o<u;o++){let c=l?l[o]:o;en(r,t,n,c,a)}}function Mo(e,t,n,i,s){const{geometry:a,_indirectBuffer:r}=e;let l=1/0,o=null;for(let u=i,c=i+s;u<c;u++){let d;d=en(a,t,n,r?r[u]:u),d&&d.distance<l&&(o=d,l=d.distance)}return o}function Po(e,t,n,i,s,a,r){const{geometry:l}=n,{index:o}=l,u=l.attributes.position;for(let c=e,d=t+e;c<d;c++){let f;if(f=n.resolveTriangleIndex(c),K(r,f*3,o,u),r.needsUpdate=!0,i(r,f,s,a))return!0}return!1}function Bo(e,t,n,i,s){W.setBuffer(e._roots[t]),Cn(0,e,n,i,s),W.clearBuffer()}function Cn(e,t,n,i,s){const{float32Array:a,uint16Array:r,uint32Array:l}=W,o=e*2;if(ee(o,r)){const c=te(e,l),d=re(o,r);wo(t,n,i,c,d,s)}else{const c=ae(e);Be(c,a,i)&&Cn(c,t,n,i,s);const d=oe(e,l);Be(d,a,i)&&Cn(d,t,n,i,s)}}const Ro=["x","y","z"];function zo(e,t,n,i){W.setBuffer(e._roots[t]);const s=Mn(0,e,n,i);return W.clearBuffer(),s}function Mn(e,t,n,i){const{float32Array:s,uint16Array:a,uint32Array:r}=W;let l=e*2;if(ee(l,a)){const u=te(e,r),c=re(l,a);return Ao(t,n,i,u,c)}else{const u=Fi(e,r),c=Ro[u],f=i.direction[c]>=0;let p,S;f?(p=ae(e),S=oe(e,r)):(p=oe(e,r),S=ae(e));const x=Be(p,s,i)?Mn(p,t,n,i):null;if(x){const h=x.point[c];if(f?h<=s[S+u]:h>=s[S+u+3])return x}const v=Be(S,s,i)?Mn(S,t,n,i):null;return x&&v?x.distance<=v.distance?x:v:x||v||null}}const Rt=new ge,Ve=new he,Ge=new he,ot=new Te,ui=new J,zt=new J;function Do(e,t,n,i){W.setBuffer(e._roots[t]);const s=Pn(0,e,n,i);return W.clearBuffer(),s}function Pn(e,t,n,i,s=null){const{float32Array:a,uint16Array:r,uint32Array:l}=W;let o=e*2;if(s===null&&(n.boundingBox||n.computeBoundingBox(),ui.set(n.boundingBox.min,n.boundingBox.max,i),s=ui),ee(o,r)){const c=t.geometry,d=c.index,f=c.attributes.position,p=n.index,S=n.attributes.position,A=te(e,l),x=re(o,r);if(ot.copy(i).invert(),n.boundsTree)return q(e,a,zt),zt.matrix.copy(ot),zt.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:v=>zt.intersectsBox(v),intersectsTriangle:v=>{v.a.applyMatrix4(i),v.b.applyMatrix4(i),v.c.applyMatrix4(i),v.needsUpdate=!0;for(let h=A*3,w=(x+A)*3;h<w;h+=3)if(K(Ge,h,d,f),Ge.needsUpdate=!0,v.intersectsTriangle(Ge))return!0;return!1}});for(let y=A*3,v=(x+A)*3;y<v;y+=3){K(Ve,y,d,f),Ve.a.applyMatrix4(ot),Ve.b.applyMatrix4(ot),Ve.c.applyMatrix4(ot),Ve.needsUpdate=!0;for(let h=0,w=p.count;h<w;h+=3)if(K(Ge,h,p,S),Ge.needsUpdate=!0,Ve.intersectsTriangle(Ge))return!0}}else{const c=e+8,d=l[e+6];return q(c,a,Rt),!!(s.intersectsBox(Rt)&&Pn(c,t,n,i,s)||(q(d,a,Rt),s.intersectsBox(Rt)&&Pn(d,t,n,i,s)))}}const Dt=new Te,un=new J,lt=new J,Lo=new D,No=new D,Uo=new D,Io=new D;function Oo(e,t,n,i={},s={},a=0,r=1/0){t.boundingBox||t.computeBoundingBox(),un.set(t.boundingBox.min,t.boundingBox.max,n),un.needsUpdate=!0;const l=e.geometry,o=l.attributes.position,u=l.index,c=t.attributes.position,d=t.index,f=le.getPrimitive(),p=le.getPrimitive();let S=Lo,A=No,x=null,y=null;s&&(x=Uo,y=Io);let v=1/0,h=null,w=null;return Dt.copy(n).invert(),lt.matrix.copy(Dt),e.shapecast({boundsTraverseOrder:T=>un.distanceToBox(T),intersectsBounds:(T,M,_)=>_<v&&_<r?(M&&(lt.min.copy(T.min),lt.max.copy(T.max),lt.needsUpdate=!0),!0):!1,intersectsRange:(T,M)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:m=>lt.distanceToBox(m),intersectsBounds:(m,g,b)=>b<v&&b<r,intersectsRange:(m,g)=>{for(let b=m,P=m+g;b<P;b++){K(p,3*b,d,c),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let E=T,R=T+M;E<R;E++){K(f,3*E,u,o),f.needsUpdate=!0;const L=f.distanceToTriangle(p,S,x);if(L<v&&(A.copy(S),y&&y.copy(x),v=L,h=E,w=b),L<a)return!0}}}});{const _=et(t);for(let m=0,g=_;m<g;m++){K(p,3*m,d,c),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let b=T,P=T+M;b<P;b++){K(f,3*b,u,o),f.needsUpdate=!0;const E=f.distanceToTriangle(p,S,x);if(E<v&&(A.copy(S),y&&y.copy(x),v=E,h=b,w=m),E<a)return!0}}}}}),le.releasePrimitive(f),le.releasePrimitive(p),v===1/0?null:(i.point?i.point.copy(A):i.point=A.clone(),i.distance=v,i.faceIndex=h,s&&(s.point?s.point.copy(y):s.point=y.clone(),s.point.applyMatrix4(Dt),A.applyMatrix4(Dt),s.distance=A.sub(s.point).length(),s.faceIndex=w),i)}function ko(e,t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=e.geometry,i=n.index?n.index.array:null,s=n.attributes.position;let a,r,l,o,u=0;const c=e._roots;for(let f=0,p=c.length;f<p;f++)a=c[f],r=new Uint32Array(a),l=new Uint16Array(a),o=new Float32Array(a),d(0,u),u+=a.byteLength;function d(f,p,S=!1){const A=f*2;if(l[A+15]===Jt){const y=r[f+6],v=l[A+14];let h=1/0,w=1/0,T=1/0,M=-1/0,_=-1/0,m=-1/0;for(let g=y,b=y+v;g<b;g++){const P=3*e.resolveTriangleIndex(g);for(let E=0;E<3;E++){let R=P+E;R=i?i[R]:R;const L=s.getX(R),N=s.getY(R),$=s.getZ(R);L<h&&(h=L),L>M&&(M=L),N<w&&(w=N),N>_&&(_=N),$<T&&(T=$),$>m&&(m=$)}}return o[f+0]!==h||o[f+1]!==w||o[f+2]!==T||o[f+3]!==M||o[f+4]!==_||o[f+5]!==m?(o[f+0]=h,o[f+1]=w,o[f+2]=T,o[f+3]=M,o[f+4]=_,o[f+5]=m,!0):!1}else{const y=f+8,v=r[f+6],h=y+p,w=v+p;let T=S,M=!1,_=!1;t?T||(M=t.has(h),_=t.has(w),T=!M&&!_):(M=!0,_=!0);const m=T||M,g=T||_;let b=!1;m&&(b=d(y,p,T));let P=!1;g&&(P=d(v,p,T));const E=b||P;if(E)for(let R=0;R<3;R++){const L=y+R,N=v+R,$=o[L],ie=o[L+3],ye=o[N],j=o[N+3];o[f+R]=$<ye?$:ye,o[f+R+3]=ie>j?ie:j}return E}}}function Fo(e,t,n,i,s){W.setBuffer(e._roots[t]),Bn(0,e,n,i,s),W.clearBuffer()}function Bn(e,t,n,i,s){const{float32Array:a,uint16Array:r,uint32Array:l}=W,o=e*2;if(ee(o,r)){const c=te(e,l),d=re(o,r);Co(t,n,i,c,d,s)}else{const c=ae(e);Be(c,a,i)&&Bn(c,t,n,i,s);const d=oe(e,l);Be(d,a,i)&&Bn(d,t,n,i,s)}}const Ho=["x","y","z"];function Vo(e,t,n,i){W.setBuffer(e._roots[t]);const s=Rn(0,e,n,i);return W.clearBuffer(),s}function Rn(e,t,n,i){const{float32Array:s,uint16Array:a,uint32Array:r}=W;let l=e*2;if(ee(l,a)){const u=te(e,r),c=re(l,a);return Mo(t,n,i,u,c)}else{const u=Fi(e,r),c=Ho[u],f=i.direction[c]>=0;let p,S;f?(p=ae(e),S=oe(e,r)):(p=oe(e,r),S=ae(e));const x=Be(p,s,i)?Rn(p,t,n,i):null;if(x){const h=x.point[c];if(f?h<=s[S+u]:h>=s[S+u+3])return x}const v=Be(S,s,i)?Rn(S,t,n,i):null;return x&&v?x.distance<=v.distance?x:v:x||v||null}}const Lt=new ge,$e=new he,je=new he,ct=new Te,fi=new J,Nt=new J;function Go(e,t,n,i){W.setBuffer(e._roots[t]);const s=zn(0,e,n,i);return W.clearBuffer(),s}function zn(e,t,n,i,s=null){const{float32Array:a,uint16Array:r,uint32Array:l}=W;let o=e*2;if(s===null&&(n.boundingBox||n.computeBoundingBox(),fi.set(n.boundingBox.min,n.boundingBox.max,i),s=fi),ee(o,r)){const c=t.geometry,d=c.index,f=c.attributes.position,p=n.index,S=n.attributes.position,A=te(e,l),x=re(o,r);if(ct.copy(i).invert(),n.boundsTree)return q(e,a,Nt),Nt.matrix.copy(ct),Nt.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:v=>Nt.intersectsBox(v),intersectsTriangle:v=>{v.a.applyMatrix4(i),v.b.applyMatrix4(i),v.c.applyMatrix4(i),v.needsUpdate=!0;for(let h=A,w=x+A;h<w;h++)if(K(je,3*t.resolveTriangleIndex(h),d,f),je.needsUpdate=!0,v.intersectsTriangle(je))return!0;return!1}});for(let y=A,v=x+A;y<v;y++){const h=t.resolveTriangleIndex(y);K($e,3*h,d,f),$e.a.applyMatrix4(ct),$e.b.applyMatrix4(ct),$e.c.applyMatrix4(ct),$e.needsUpdate=!0;for(let w=0,T=p.count;w<T;w+=3)if(K(je,w,p,S),je.needsUpdate=!0,$e.intersectsTriangle(je))return!0}}else{const c=e+8,d=l[e+6];return q(c,a,Lt),!!(s.intersectsBox(Lt)&&zn(c,t,n,i,s)||(q(d,a,Lt),s.intersectsBox(Lt)&&zn(d,t,n,i,s)))}}const Ut=new Te,fn=new J,ut=new J,$o=new D,jo=new D,Wo=new D,qo=new D;function Xo(e,t,n,i={},s={},a=0,r=1/0){t.boundingBox||t.computeBoundingBox(),fn.set(t.boundingBox.min,t.boundingBox.max,n),fn.needsUpdate=!0;const l=e.geometry,o=l.attributes.position,u=l.index,c=t.attributes.position,d=t.index,f=le.getPrimitive(),p=le.getPrimitive();let S=$o,A=jo,x=null,y=null;s&&(x=Wo,y=qo);let v=1/0,h=null,w=null;return Ut.copy(n).invert(),ut.matrix.copy(Ut),e.shapecast({boundsTraverseOrder:T=>fn.distanceToBox(T),intersectsBounds:(T,M,_)=>_<v&&_<r?(M&&(ut.min.copy(T.min),ut.max.copy(T.max),ut.needsUpdate=!0),!0):!1,intersectsRange:(T,M)=>{if(t.boundsTree){const _=t.boundsTree;return _.shapecast({boundsTraverseOrder:m=>ut.distanceToBox(m),intersectsBounds:(m,g,b)=>b<v&&b<r,intersectsRange:(m,g)=>{for(let b=m,P=m+g;b<P;b++){const E=_.resolveTriangleIndex(b);K(p,3*E,d,c),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let R=T,L=T+M;R<L;R++){const N=e.resolveTriangleIndex(R);K(f,3*N,u,o),f.needsUpdate=!0;const $=f.distanceToTriangle(p,S,x);if($<v&&(A.copy(S),y&&y.copy(x),v=$,h=R,w=b),$<a)return!0}}}})}else{const _=et(t);for(let m=0,g=_;m<g;m++){K(p,3*m,d,c),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let b=T,P=T+M;b<P;b++){const E=e.resolveTriangleIndex(b);K(f,3*E,u,o),f.needsUpdate=!0;const R=f.distanceToTriangle(p,S,x);if(R<v&&(A.copy(S),y&&y.copy(x),v=R,h=b,w=m),R<a)return!0}}}}}),le.releasePrimitive(f),le.releasePrimitive(p),v===1/0?null:(i.point?i.point.copy(A):i.point=A.clone(),i.distance=v,i.faceIndex=h,s&&(s.point?s.point.copy(y):s.point=y.clone(),s.point.applyMatrix4(Ut),A.applyMatrix4(Ut),s.distance=A.sub(s.point).length(),s.faceIndex=w),i)}function Ko(){return typeof SharedArrayBuffer<"u"}const vt=new W.constructor,jt=new W.constructor,Me=new Fn(()=>new ge),We=new ge,qe=new ge,dn=new ge,hn=new ge;let pn=!1;function Zo(e,t,n,i){if(pn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");pn=!0;const s=e._roots,a=t._roots;let r,l=0,o=0;const u=new Te().copy(n).invert();for(let c=0,d=s.length;c<d;c++){vt.setBuffer(s[c]),o=0;const f=Me.getPrimitive();q(0,vt.float32Array,f),f.applyMatrix4(u);for(let p=0,S=a.length;p<S&&(jt.setBuffer(a[c]),r=fe(0,0,n,u,i,l,o,0,0,f),jt.clearBuffer(),o+=a[p].length,!r);p++);if(Me.releasePrimitive(f),vt.clearBuffer(),l+=s[c].length,r)break}return pn=!1,r}function fe(e,t,n,i,s,a=0,r=0,l=0,o=0,u=null,c=!1){let d,f;c?(d=jt,f=vt):(d=vt,f=jt);const p=d.float32Array,S=d.uint32Array,A=d.uint16Array,x=f.float32Array,y=f.uint32Array,v=f.uint16Array,h=e*2,w=t*2,T=ee(h,A),M=ee(w,v);let _=!1;if(M&&T)c?_=s(te(t,y),re(t*2,v),te(e,S),re(e*2,A),o,r+t,l,a+e):_=s(te(e,S),re(e*2,A),te(t,y),re(t*2,v),l,a+e,o,r+t);else if(M){const m=Me.getPrimitive();q(t,x,m),m.applyMatrix4(n);const g=ae(e),b=oe(e,S);q(g,p,We),q(b,p,qe);const P=m.intersectsBox(We),E=m.intersectsBox(qe);_=P&&fe(t,g,i,n,s,r,a,o,l+1,m,!c)||E&&fe(t,b,i,n,s,r,a,o,l+1,m,!c),Me.releasePrimitive(m)}else{const m=ae(t),g=oe(t,y);q(m,x,dn),q(g,x,hn);const b=u.intersectsBox(dn),P=u.intersectsBox(hn);if(b&&P)_=fe(e,m,n,i,s,a,r,l,o+1,u,c)||fe(e,g,n,i,s,a,r,l,o+1,u,c);else if(b)if(T)_=fe(e,m,n,i,s,a,r,l,o+1,u,c);else{const E=Me.getPrimitive();E.copy(dn).applyMatrix4(n);const R=ae(e),L=oe(e,S);q(R,p,We),q(L,p,qe);const N=E.intersectsBox(We),$=E.intersectsBox(qe);_=N&&fe(m,R,i,n,s,r,a,o,l+1,E,!c)||$&&fe(m,L,i,n,s,r,a,o,l+1,E,!c),Me.releasePrimitive(E)}else if(P)if(T)_=fe(e,g,n,i,s,a,r,l,o+1,u,c);else{const E=Me.getPrimitive();E.copy(hn).applyMatrix4(n);const R=ae(e),L=oe(e,S);q(R,p,We),q(L,p,qe);const N=E.intersectsBox(We),$=E.intersectsBox(qe);_=N&&fe(g,R,i,n,s,r,a,o,l+1,E,!c)||$&&fe(g,L,i,n,s,r,a,o,l+1,E,!c),Me.releasePrimitive(E)}}return _}const It=new J,di=new ge,Yo={strategy:Ii,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class Hn{static serialize(t,n={}){n={cloneBuffers:!0,...n};const i=t.geometry,s=t._roots,a=t._indirectBuffer,r=i.getIndex();let l;return n.cloneBuffers?l={roots:s.map(o=>o.slice()),index:r?r.array.slice():null,indirectBuffer:a?a.slice():null}:l={roots:s,index:r?r.array:null,indirectBuffer:a},l}static deserialize(t,n,i={}){i={setIndex:!0,indirect:!!t.indirectBuffer,...i};const{index:s,roots:a,indirectBuffer:r}=t,l=new Hn(n,{...i,[rn]:!0});if(l._roots=a,l._indirectBuffer=r||null,i.setIndex){const o=n.getIndex();if(o===null){const u=new me(t.index,1,!1);n.setIndex(u)}else o.array!==s&&(o.array.set(s),o.needsUpdate=!0)}return l}get indirect(){return!!this._indirectBuffer}constructor(t,n={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(n=Object.assign({...Yo,[rn]:!1},n),n.useSharedArrayBuffer&&!Ko())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,n[rn]||(ho(this,n),!t.boundingBox&&n.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new ge)));const{_indirectBuffer:i}=this;this.resolveTriangleIndex=n.indirect?s=>i[s]:s=>s}refit(t=null){return(this.indirect?ko:Eo)(this,t)}traverse(t,n=0){const i=this._roots[n],s=new Uint32Array(i),a=new Uint16Array(i);r(0);function r(l,o=0){const u=l*2,c=a[u+15]===Jt;if(c){const d=s[l+6],f=a[u+14];t(o,c,new Float32Array(i,l*4,6),d,f)}else{const d=l+mt/4,f=s[l+6],p=s[l+7];t(o,c,new Float32Array(i,l*4,6),p)||(r(d,o+1),r(f,o+1))}}}raycast(t,n=bn){const i=this._roots,s=this.geometry,a=[],r=n.isMaterial,l=Array.isArray(n),o=s.groups,u=r?n.side:n,c=this.indirect?Fo:Bo;for(let d=0,f=i.length;d<f;d++){const p=l?n[o[d].materialIndex].side:u,S=a.length;if(c(this,d,p,t,a),l){const A=o[d].materialIndex;for(let x=S,y=a.length;x<y;x++)a[x].face.materialIndex=A}}return a}raycastFirst(t,n=bn){const i=this._roots,s=this.geometry,a=n.isMaterial,r=Array.isArray(n);let l=null;const o=s.groups,u=a?n.side:n,c=this.indirect?Vo:zo;for(let d=0,f=i.length;d<f;d++){const p=r?n[o[d].materialIndex].side:u,S=c(this,d,p,t);S!=null&&(l==null||S.distance<l.distance)&&(l=S,r&&(S.face.materialIndex=o[d].materialIndex))}return l}intersectsGeometry(t,n){let i=!1;const s=this._roots,a=this.indirect?Go:Do;for(let r=0,l=s.length;r<l&&(i=a(this,r,t,n),!i);r++);return i}shapecast(t){const n=le.getPrimitive(),i=this.indirect?Po:_o;let{boundsTraverseOrder:s,intersectsBounds:a,intersectsRange:r,intersectsTriangle:l}=t;if(r&&l){const d=r;r=(f,p,S,A,x)=>d(f,p,S,A,x)?!0:i(f,p,this,l,S,A,n)}else r||(l?r=(d,f,p,S)=>i(d,f,this,l,p,S,n):r=(d,f,p)=>p);let o=!1,u=0;const c=this._roots;for(let d=0,f=c.length;d<f;d++){const p=c[d];if(o=xo(this,d,a,r,s,u),o)break;u+=p.byteLength}return le.releasePrimitive(n),o}bvhcast(t,n,i){let{intersectsRanges:s,intersectsTriangles:a}=i;const r=le.getPrimitive(),l=this.geometry.index,o=this.geometry.attributes.position,u=this.indirect?S=>{const A=this.resolveTriangleIndex(S);K(r,A*3,l,o)}:S=>{K(r,S*3,l,o)},c=le.getPrimitive(),d=t.geometry.index,f=t.geometry.attributes.position,p=t.indirect?S=>{const A=t.resolveTriangleIndex(S);K(c,A*3,d,f)}:S=>{K(c,S*3,d,f)};if(a){const S=(A,x,y,v,h,w,T,M)=>{for(let _=y,m=y+v;_<m;_++){p(_),c.a.applyMatrix4(n),c.b.applyMatrix4(n),c.c.applyMatrix4(n),c.needsUpdate=!0;for(let g=A,b=A+x;g<b;g++)if(u(g),r.needsUpdate=!0,a(r,c,g,_,h,w,T,M))return!0}return!1};if(s){const A=s;s=function(x,y,v,h,w,T,M,_){return A(x,y,v,h,w,T,M,_)?!0:S(x,y,v,h,w,T,M,_)}}else s=S}return Zo(this,t,n,s)}intersectsBox(t,n){return It.set(t.min,t.max,n),It.needsUpdate=!0,this.shapecast({intersectsBounds:i=>It.intersectsBox(i),intersectsTriangle:i=>It.intersectsTriangle(i)})}intersectsSphere(t){return this.shapecast({intersectsBounds:n=>t.intersectsBox(n),intersectsTriangle:n=>n.intersectsSphere(t)})}closestPointToGeometry(t,n,i={},s={},a=0,r=1/0){return(this.indirect?Xo:Oo)(this,t,n,i,s,a,r)}closestPointToPoint(t,n={},i=0,s=1/0){return So(this,t,n,i,s)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(i=>{q(0,new Float32Array(i),di),t.union(di)}),t}}function hi(e,t,n){return e===null||(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(n.ray.origin),e.object=t,e.distance<n.near||e.distance>n.far)?null:e}const mn=new Ts,pi=new Te,Qo=Kt.prototype.raycast;function Jo(e,t){if(this.geometry.boundsTree){if(this.material===void 0)return;pi.copy(this.matrixWorld).invert(),mn.copy(e.ray).applyMatrix4(pi);const n=this.geometry.boundsTree;if(e.firstHitOnly===!0){const i=hi(n.raycastFirst(mn,this.material),this,e);i&&t.push(i)}else{const i=n.raycast(mn,this.material);for(let s=0,a=i.length;s<a;s++){const r=hi(i[s],this,e);r&&t.push(r)}}}else Qo.call(this,e,t)}function el(e){return this.boundsTree=new Hn(this,e),this.boundsTree}function tl(){this.boundsTree=null}function nl({modelInCopy:e}){const t=new ht({color:15461355});var n=new kt({color:10921638,linewidth:10});const i=new ve(Pi);return i.uniforms.diffuse.value.set(0),C.useEffect(()=>{const s=[];e.traverse(a=>{if(a.frustumCulled=!0,a.isMesh){a.material=t,a.frustumCulled=!1;var r=new Ke(a.geometry,20),l=new Le(r,n);s.push(a.geometry);const o=new ws(As(a.geometry)),u=new Le(o,i);a.add(l),a.add(u),r.dispose(),a.geometry.dispose(),t.dispose()}})},[]),z(Z,{children:z("primitive",{object:e,scale:1})})}de.memo(nl);new zs;const il={linewidth:{value:1},resolution:{value:new Ds(1,1)},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1},opacity:{value:1}},vn={uniforms:Ri.merge([Zn.common,Zn.fog,il]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 control0;
		attribute vec3 control1;
		attribute vec3 direction;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		varying vec2 vUv;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = resolution.x / resolution.y;

			vUv = uv;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec2 ndcStart = clipStart.xy / clipStart.w;
			vec2 ndcEnd = clipEnd.xy / clipEnd.w;

			// direction
			vec2 dir = ndcEnd - ndcStart;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			// perpendicular to dir
			vec2 offset = vec2( dir.y, - dir.x );

			// undo aspect ratio adjustment
			dir.x /= aspect;
			offset.x /= aspect;

			// sign flip
			if ( position.x < 0.0 ) offset *= - 1.0;

			// endcaps
			if ( position.y < 0.0 ) {

				offset += - dir;

			} else if ( position.y > 1.0 ) {

				offset += dir;

			}

			// adjust for linewidth
			offset *= linewidth;

			// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
			offset /= resolution.y;

			// select end
			vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

			// back to clip space
			offset *= clip.w;

			clip.xy += offset;

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

			// conditional logic
			// Transform the line segment ends and control points into camera clip space
			vec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );
			vec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );
			vec4 p0 = projectionMatrix * modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 p1 = projectionMatrix * modelViewMatrix * vec4( instanceStart + direction, 1.0 );

			c0 /= c0.w;
			c1 /= c1.w;
			p0 /= p0.w;
			p1 /= p1.w;

			// Get the direction of the segment and an orthogonal vector
			vec2 segDir = p1.xy - p0.xy;
			vec2 norm = vec2( - segDir.y, segDir.x );

			// Get control point directions from the line
			vec2 c0dir = c0.xy - p1.xy;
			vec2 c1dir = c1.xy - p1.xy;

			// If the vectors to the controls points are pointed in different directions away
			// from the line segment then the line should not be drawn.
			float d0 = dot( normalize( norm ), normalize( c0dir ) );
			float d1 = dot( normalize( norm ), normalize( c1dir ) );
			float discardFlag = float( sign( d0 ) != sign( d1 ) );
			gl_Position = discardFlag > 0.5 ? c0 : gl_Position;
			// end conditional line logic

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;

		#ifdef USE_DASH

			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		varying vec2 vUv;

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			if ( abs( vUv.y ) > 1.0 ) {

				float a = vUv.x;
				float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
				float len2 = a * a + b * b;

				if ( len2 > 1.0 ) discard;

			}

			vec4 diffuseColor = vec4( diffuse, opacity );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};class sl extends Ls{constructor(t){super({type:"ConditionalLineMaterial",uniforms:Ri.clone(vn.uniforms),vertexShader:vn.vertexShader,fragmentShader:vn.fragmentShader,clipping:!0}),this.dashed=!1,Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(n){this.uniforms.diffuse.value=n}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(n){this.uniforms.linewidth.value=n}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(n){this.uniforms.dashScale.value=n}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(n){this.uniforms.dashSize.value=n}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(n){this.uniforms.gapSize.value=n}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(n){this.uniforms.opacity.value=n}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(n){this.uniforms.resolution.value.copy(n)}}}),this.setValues(t)}}sl.prototype.isConditionalLineMaterial=!0;_s({OutlineEffect:ks});const gn=[],yn=[];function rl({modelIn:e,modelOut:t,modelInCopy:n,modelInCopy2:i,modelOutCopy:s}){Gt.prototype.computeBoundsTree=el,Gt.prototype.disposeBoundsTree=tl,Kt.prototype.raycast=Jo,console.log("render count");const{gl:a,camera:r,scene:l}=Ln(),o=C.useRef(),u=C.useRef();C.useRef(),C.useRef(),C.useRef(),a.setPixelRatio(Math.min(window.devicePixelRatio,2));let{stepCount:c,modelProperties:d,partsInOut:f,setVisibleModel:p,setCurrentStepObj:S,currentStepObject:A,selectedParts:x,setProperties:y,cameraPosition:v}=C.useContext(ce);const[h,w]=C.useState(!1),[T,M]=C.useState(!1),[_,m]=C.useState(i),[g,b]=C.useState(),[P,E]=C.useState(n),[R,L]=C.useState(i),[N,$]=C.useState();C.useState(),C.useState();const[ie,ye]=C.useState(),[j,St]=C.useState(),tt=new ht({color:15461355}),ze=new ht({color:16777215}),bt=new ht({color:16711680,wireframe:!0}),Vn=new ht({color:13754592});var Tt=new kt({color:4210752,linewidth:10}),Gn=new kt({color:6723993,linewidth:50}),Xi=new kt({color:10921638,linewidth:10});new ve(Pi).uniforms.diffuse.value.set(0);const $n=["291_Prepare_the_Fillet_Profile"],nt=[["091_Bed_Frame","092_Bed_Legs","093_Bed_Lamella"],["141_Preparing_the_X-axis_1","142_Preparing_the_X-axis_2","143_Preparing_the_X-axis_3"],["301_Prepare_Window_1","302_Prepare_the_Window_2"]],Ki=["131_Wiring_DC","132_Wiring_AC","271_Wiring_DC_2"],jn=[];let Wn=[],it=[];C.useEffect(()=>{f===!0?(m(i),St(i.getObjectByName(h[c]))):f===!1&&(m(s),St(s.getObjectByName(h[c])))},[f]),C.useEffect(()=>{_.traverse(B=>{B.isObject3D&&!B.isMesh&&!B.isGroup&&(gn.push(B.name),yn.push(B.userData.name))}),gn.sort(),w(gn),yn.sort(),M(yn),R.traverse(B=>{if(B.frustumCulled=!0,B.isMesh){B.frustumCulled=!1,B.material=ze,ze.dispose();var I=new Ke(B.geometry,20),U=new Le(I,Tt);B.add(U),I.dispose(),B.geometry.dispose(),ze.dispose(),B.userData.name==="Curves"&&(B.material=bt,bt.dispose()),B.geometry.dispose()}}),s.traverse(B=>{if(B.frustumCulled=!0,B.isMesh&&B.parent.userData.name!="Curves"){B.frustumCulled=!1,B.material=ze,ze.dispose();var I=new Ke(B.geometry,20),U=new Le(I,Tt);B.add(U),I.dispose(),B.geometry.dispose(),ze.dispose(),B.geometry.dispose()}if(B.userData.name==="Curves"&&(B.material=bt,B.isGroup))for(let G=0;G<B.children.length;G++)B.children[G].isMesh&&(B.children[G].material=bt)}),P.traverse(B=>{if(B.isMesh){B.material=tt,B.frustumCulled=!1;var I=new Ke(B.geometry,20),U=new Le(I,Xi);B.add(U),I.dispose(),B.geometry.dispose(),tt.dispose()}}),S(n.getObjectByName(h[0])),St(_.getObjectByName(h[0])),qn()},[]);const Zi=$n.some(B=>B.includes(h[c])),Yi=nt.some(B=>B.includes(h[c]));Q(B=>B.wiringStep);const Qi=Q(B=>B.isWiringStep),Ji=Q(B=>B.isNotWiringStep);Ki.some(B=>B.includes(h[c]))?Qi():Ji(),C.useEffect(()=>{S(n.getObjectByName(h[c])),St(_.getObjectByName(h[c]))},[h,c]),C.useEffect(()=>{qn()},[h,c,A]),C.useEffect(()=>{j&&x!=[]&&is()},[x,j]);const qn=C.useCallback(()=>{let B=[],I=[];const U=[];if(A){for(let Ie=0;Ie<A.children.length;Ie++)A.children[Ie].traverse(De=>{De.isGroup&&De.userData.name!=null&&U.push(De.userData.name),B=[...new Set(U)],I=B.map(wt=>[U.filter(as=>as===wt).length,wt])});const G=A.userData.name;y({partsNames:I,titleName:G})}}),es=C.useCallback(()=>{for(let B=c-1;B>=0;B--)for(let I=it.length-1;I>=0;I--)if(h[B]===it[I]){let U=P.getObjectByName(`${h[B]}`,!0);Wn.push(U)}}),ts=C.useCallback(()=>{for(let U=0;U<nt.length;U++){it=nt[U];for(let G=0;G<it.length;G++)it.some(De=>De.includes(h[c]))&&es()}let B=new $t,I=j.clone();B.add(I),Wn.filter(U=>nt.some(G=>G.includes(U.name))).forEach(U=>{U.visible=!0;let G=U.clone();B.add(G)}),p(B)}),ns=C.useCallback(()=>{for(let U=c-1;U>=0;U--){let G=P.getObjectByName(`${h[U]}`,!0);jn.push(G)}let B=new $t,I=j.clone();B.add(I),jn.filter(U=>!$n.some(G=>G.includes(U.name))&&!nt.some(G=>G.includes(U.name))).forEach(U=>{U.visible=!0;let G=U.clone();B.add(G)}),p(B)}),is=C.useCallback(()=>{if(j){const B=[];for(let I=0;I<j.children.length;I++)j.children[I].traverse(U=>{if(U.isMesh&&x.includes(j.children[I].userData.name)){const wt=U.geometry.clone();B.push(wt),U.material=Vn;var G=new Ke(U.geometry,20),Ie=new Le(G,Gn);U.add(Ie),Vn.dispose(),G.dispose(),Gn.dispose()}else if(U.isMesh&&j.children[I].userData.name!="Curves"){U.material=ze;var G=new Ke(U.geometry,20),De=new Le(G,Tt);U.add(De),G.dispose(),Tt.dispose()}});ye(x)}});C.useCallback(()=>{N.traverse(B=>{B.name==="Botom_Panel"&&console.log(N.userData.name)})}),C.useCallback(B=>{B.stopPropagation(),console.log(B.object)});const ss=C.useCallback(()=>{if(j){const B=j.clone();b(B),B.traverse(I=>{I.isMesh&&(tt.side=Ne,tt.color.set(0),I.material=tt,I.scale.multiplyScalar(1.005))});for(let I=0;I<_.children.length;I++)_.children[I].visible=!1;for(let I=0;I<P.children.length;I++)P.children[I].visible=!1;Zi?(console.log("exception"),j.visible=!0,p(j)):Yi?(console.log("preparing step"),j.visible=!0,ts()):(console.log("main building step"),j.visible=!0,ns())}},[j]);C.useEffect(()=>{ss()},[j]);const{setListOfStep:rs}=C.useContext(ce);return rs(T),C.useState(null),z(Z,{children:V(Fs,{children:[h?V(Z,{children:[z("primitive",{ref:o,object:_,scale:1.0001}),z("primitive",{ref:u,object:P,scale:1})]}):null,V(aa,{multisampling:8,autoClear:!1,children:[z(oa,{selection:_.scene,blendFunction:k.ALPHA,selectionLayer:1,blur:!0,visibleEdgeColor:65280,hiddenEdgeColor:65280,edgeStrength:50,width:1e3,height:1e3,xRay:!0}),z(Xa,{})]})]})})}const al=de.memo(rl);function ol(){let e=[],t=new $t;const{modelProperties:n,visibleObj:i,currentStepObject:s,setClickedParts:a,selectedParts:r,partsInOut:l,setCurrentPartsModel:o}=C.useContext(ce),[u,c]=C.useState(null),[d,f]=C.useState(!1),[p,S]=C.useState(!1),A=Q(v=>v.wiringStep),x=C.useCallback(()=>{if(t=new $t,e=[],u){for(let v=0;v<s.children.length;v++)if(s.children[v].userData.name===u){const h=s.children[v].clone();t.add(h),e.push(s.children[v].userData.name)}a(e),o(t)}});C.useEffect(()=>{e=[],a(e),x()},[s,u]),C.useEffect(()=>{f(!1),e=[],a(e),o(null)},[s]);const y=()=>{d===!0&&(f(!1),e=[],a(e),o(null)),d===!1&&(f(!0),x())};return z(Z,{children:z("div",{children:z("ul",{children:n?n.partsNames.map(([v,h],w)=>z("li",{children:h===u&&d===!0?V("button",{id:`${h}`,style:{backgroundColor:"#669999",color:"#ffffff"},disabled:p,onClick:()=>{y()},className:"parts",children:[V("b",{children:[" ",v,"x"]}),"  ",h]}):A?V("p",{style:{paddingBottom:10},children:[V("b",{children:[" ",v,"x"]}),"  ",h]}):V("button",{id:`${h}`,disabled:p,onClick:()=>{c(h),y()},className:"parts",children:[V("b",{children:[" ",v,"x"]}),"  ",h]})},w)):null})})})}function ll(){const{modelProperties:e}=C.useContext(ce);return z(Z,{children:z("div",{children:e?e.titleName:null})})}function cl(){const{stepList:e,setStepPosition:t,stepCount:n,currentStepName:i,modelProperties:s}=C.useContext(ce);C.useState("stepNaviBtn");const[a,r]=C.useState();return e&&[...Array(e.length)],z("div",{children:z("ul",{children:e?e.map((l,o)=>z("li",{children:s&&l===s.titleName?z("button",{id:`${l}`,style:{backgroundColor:"#000000",color:"#ffffff"},onClick:()=>{t(o)},className:"stepNaviBtn",children:l}):z("button",{id:`${l}`,style:{backgroundColor:a},onClick:()=>{t(o)},className:"stepNaviBtn",children:l})},o)):null})})}const ul=de.memo(cl);function fl({cameraControlsRef:e}){let{visibleObj:t,modelProperties:n,selectedPartsModel:i,currentStepObject:s,setCamera:a}=C.useContext(ce);const r=Bi(),l=Q(o=>o.cameraPositionTag);C.useEffect(()=>{t?r.refresh(t).fit():r.refresh(s).fit()},[s,l]),C.useEffect(()=>{i?r.refresh(i).fit():i||r.refresh(t).fit()},[i])}let Dn=1,Gi=new Array;new Array;let xn=new Array,Ot;Nn.get("https://sheets.googleapis.com/v4/spreadsheets/18hHq4XYLPYSN1Wc0RjY5zl5vCHoVVrlugpG-O7cULLw/values/Workbook?key=AIzaSyCqcO7MQv4dsj76ps3nNJnMwTT8Cvqv-eM").then(e=>{let t=e.data.values,n=new Array;for(const i of t)Dn>2&&i[1]!=""&&(Gi.push(n),n=new Array),n.push(i),++Dn});function dl(){let{stepCount:e}=C.useContext(ce);return C.useEffect(()=>{Ot=new Array;for(const t of Gi[e+1])t[10]!=""&&t[10]!=null&&(xn=new Array,xn.push(t[10]),Ot.push(xn)),++Dn},[e]),z(Z,{children:z("div",{children:z("ul",{children:Ot?Ot.map((t,n)=>V("li",{children:[" ",t]},n)):null})})})}/**
  * react-collapsed v4.1.2
  *
  * Copyright (c) 2019-2023, Rogin Farrer
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE.md file in the root directory of this source tree.
  *
  * @license MIT
  */var hl=class extends Error{constructor(e){super(`react-collapsed: ${e}`)}},Wt=(...e)=>(e[0],`${e[1]}`,void 0);function $i(e){const t=C.useRef(e);return C.useEffect(()=>{t.current=e}),C.useCallback((...n)=>{var i;return(i=t.current)==null?void 0:i.call(t,...n)},[])}function pl(e,t,n){const[i,s]=C.useState(t),a=C.useRef(typeof e<"u"),r=a.current?e:i,l=$i(n),o=C.useCallback(u=>{const d=typeof u=="function"?u(r):u;a.current||s(d),l==null||l(d)},[l,r]);return C.useEffect(()=>{Wt(!(a.current&&e==null),"`isExpanded` state is changing from controlled to uncontrolled. useCollapse should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop."),Wt(!(!a.current&&e!=null),"`isExpanded` state is changing from uncontrolled to controlled. useCollapse should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop.")},[e]),[r,o]}var ml="(prefers-reduced-motion: reduce)";function vl(){const[e,t]=C.useState(!1);return C.useEffect(()=>{if(typeof window>"u"||typeof window.matchMedia!="function")return;const n=window.matchMedia(ml);t(n.matches);const i=s=>{t(s.matches)};if(n.addEventListener)return n.addEventListener("change",i),()=>{n.removeEventListener("change",i)};if(n.addListener)return n.addListener(i),()=>{n.removeListener(i)}},[]),e}var gl=Es["useId".toString()]||(()=>{});function yl(){return gl()??""}var xl=typeof window<"u"?C.useLayoutEffect:C.useEffect,Sn=!1,Sl=0,mi=()=>++Sl;function bl(e){const t=e||(Sn?mi():null),[n,i]=C.useState(t);return xl(()=>{n===null&&i(mi())},[]),C.useEffect(()=>{Sn===!1&&(Sn=!0)},[]),n!=null?String(n):void 0}function Tl(e){const t=yl(),n=bl(e);return typeof e=="string"?e:typeof t=="string"?t:n}function wl(e,t){const n=performance.now(),i={};function s(){i.id=requestAnimationFrame(a=>{a-n>t?e():s()})}return s(),i}function vi(e){e.id&&cancelAnimationFrame(e.id)}function gi(e){return e!=null&&e.current?e.current.scrollHeight:(Wt(!0,"Was not able to find a ref to the collapse element via `getCollapseProps`. Ensure that the element exposes its `ref` prop. If it exposes the ref prop under a different name (like `innerRef`), use the `refKey` property to change it. Example:\n\nconst collapseProps = getCollapseProps({refKey: 'innerRef'})"),0)}function Al(e){if(!e||typeof e=="string")return 0;const t=e/36;return Math.round((4+15*t**.25+t/5)*10)}function _l(e,t){if(e!=null)if(typeof e=="function")e(t);else try{e.current=t}catch{throw new hl(`Cannot assign value "${t}" to ref "${e}"`)}}function yi(...e){return e.every(t=>t==null)?null:t=>{e.forEach(n=>{_l(n,t)})}}function El(e){let t=n=>{};t=n=>{if(!(n!=null&&n.current))return;const{paddingTop:i,paddingBottom:s}=window.getComputedStyle(n.current);Wt(!(i&&i!=="0px"||s&&s!=="0px"),`Padding applied to the collapse element will cause the animation to break and not perform as expected. To fix, apply equivalent padding to the direct descendent of the collapse element. Example:

Before:   <div {...getCollapseProps({style: {padding: 10}})}>{children}</div>

After:   <div {...getCollapseProps()}>
             <div style={{padding: 10}}>
                 {children}
             </div>
          </div>`)},C.useEffect(()=>{t(e)},[e])}var Cl=typeof window>"u"?C.useEffect:C.useLayoutEffect;function Ml({duration:e,easing:t="cubic-bezier(0.4, 0, 0.2, 1)",onTransitionStateChange:n=()=>{},isExpanded:i,defaultExpanded:s=!1,hasDisabledAnimation:a,id:r,...l}={}){const o=$i(n),u=Tl(r?`${r}`:void 0),[c,d]=pl(i,s),f=C.useRef(c),[p,S]=C.useState(!1),A=vl(),x=a??A,y=C.useRef(),v=C.useRef(),h=C.useRef(null),[w,T]=C.useState(null);El(h);const M=`${l.collapsedHeight||0}px`;function _(m){if(!h.current)return;const g=h.current;for(const b in m){const P=m[b];P?g.style[b]=P:g.style.removeProperty(b)}}return Cl(()=>{if(!h.current||c===f.current)return;f.current=c;function g(E){return x?0:e??Al(E)}const b=E=>`height ${g(E)}ms ${t}`,P=E=>{function R(){c?(_({height:"",overflow:"",transition:"",display:""}),o("expandEnd")):(_({transition:""}),o("collapseEnd")),S(!1)}v.current&&vi(v.current),v.current=wl(R,E)};return S(!0),c?y.current=requestAnimationFrame(()=>{o("expandStart"),_({display:"block",overflow:"hidden",height:M}),y.current=requestAnimationFrame(()=>{o("expanding");const E=gi(h);P(g(E)),h.current&&(h.current.style.transition=b(E),h.current.style.height=`${E}px`)})}):y.current=requestAnimationFrame(()=>{o("collapseStart");const E=gi(h);P(g(E)),_({transition:b(E),height:`${E}px`}),y.current=requestAnimationFrame(()=>{o("collapsing"),_({height:M,overflow:"hidden"})})}),()=>{y.current&&cancelAnimationFrame(y.current),v.current&&vi(v.current)}},[c,M,x,e,t,o]),{isExpanded:c,setExpanded:d,getToggleProps(m){const{disabled:g,onClick:b,refKey:P,...E}={refKey:"ref",onClick(){},disabled:!1,...m},R=w?w.tagName==="BUTTON":void 0,L=m==null?void 0:m[P||"ref"],N={id:`react-collapsed-toggle-${u}`,"aria-controls":`react-collapsed-panel-${u}`,"aria-expanded":c,onClick(ye){g||(b==null||b(ye),d(j=>!j))},[P||"ref"]:yi(L,T)},$={type:"button",disabled:g?!0:void 0},ie={"aria-disabled":g?!0:void 0,role:"button",tabIndex:g?-1:0};return R===!1?{...N,...ie,...E}:R===!0?{...N,...$,...E}:{...N,...$,...ie,...E}},getCollapseProps(m){const{style:g,refKey:b}={refKey:"ref",style:{},...m},P=m==null?void 0:m[b||"ref"];return{id:`react-collapsed-panel-${u}`,"aria-hidden":!c,"aria-labelledby":`react-collapsed-toggle-${u}`,role:"region",...m,[b||"ref"]:yi(h,P),style:{boxSizing:"border-box",...!p&&!c?{display:M==="0px"?"none":"block",height:M,overflow:"hidden"}:{},...g}}}}}var ji={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},xi=de.createContext&&de.createContext(ji),Pl=["attr","size","title"];function Bl(e,t){if(e==null)return{};var n=Rl(e,t),i,s;if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)i=a[s],!(t.indexOf(i)>=0)&&Object.prototype.propertyIsEnumerable.call(e,i)&&(n[i]=e[i])}return n}function Rl(e,t){if(e==null)return{};var n={},i=Object.keys(e),s,a;for(a=0;a<i.length;a++)s=i[a],!(t.indexOf(s)>=0)&&(n[s]=e[s]);return n}function qt(){return qt=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i])}return e},qt.apply(this,arguments)}function Si(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(e,s).enumerable})),n.push.apply(n,i)}return n}function Xt(e){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?arguments[t]:{};t%2?Si(Object(n),!0).forEach(function(i){zl(e,i,n[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Si(Object(n)).forEach(function(i){Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(n,i))})}return e}function zl(e,t,n){return t=Dl(t),t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function Dl(e){var t=Ll(e,"string");return typeof t=="symbol"?t:String(t)}function Ll(e,t){if(typeof e!="object"||e===null)return e;var n=e[Symbol.toPrimitive];if(n!==void 0){var i=n.call(e,t||"default");if(typeof i!="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(e)}function Wi(e){return e&&e.map((t,n)=>de.createElement(t.tag,Xt({key:n},t.attr),Wi(t.child)))}function xt(e){return t=>de.createElement(Nl,qt({attr:Xt({},e.attr)},t),Wi(e.child))}function Nl(e){var t=n=>{var{attr:i,size:s,title:a}=e,r=Bl(e,Pl),l=s||n.size||"1em",o;return n.className&&(o=n.className),e.className&&(o=(o?o+" ":"")+e.className),de.createElement("svg",qt({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},n.attr,i,r,{className:o,style:Xt(Xt({color:e.color||n.color},n.style),e.style),height:l,width:l,xmlns:"http://www.w3.org/2000/svg"}),a&&de.createElement("title",null,a),e.children)};return xi!==void 0?de.createElement(xi.Consumer,null,n=>t(n)):t(ji)}function Ul(e){return xt({tag:"svg",attr:{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round"},child:[{tag:"circle",attr:{cx:"12",cy:"12",r:"10"},child:[]},{tag:"line",attr:{x1:"12",x2:"12",y1:"8",y2:"12"},child:[]},{tag:"line",attr:{x1:"12",x2:"12.01",y1:"16",y2:"16"},child:[]}]})(e)}function Il(e){return xt({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M0 0h24v24H0z"},child:[]},{tag:"path",attr:{d:"m18.25 7.6-5.5-3.18a1.49 1.49 0 0 0-1.5 0L5.75 7.6c-.46.27-.75.76-.75 1.3v6.35c0 .54.29 1.03.75 1.3l5.5 3.18c.46.27 1.04.27 1.5 0l5.5-3.18c.46-.27.75-.76.75-1.3V8.9c0-.54-.29-1.03-.75-1.3zM7 14.96v-4.62l4 2.32v4.61l-4-2.31zm5-4.03L8 8.61l4-2.31 4 2.31-4 2.32zm1 6.34v-4.61l4-2.32v4.62l-4 2.31zM7 2H3.5C2.67 2 2 2.67 2 3.5V7h2V4h3V2zm10 0h3.5c.83 0 1.5.67 1.5 1.5V7h-2V4h-3V2zM7 22H3.5c-.83 0-1.5-.67-1.5-1.5V17h2v3h3v2zm10 0h3.5c.83 0 1.5-.67 1.5-1.5V17h-2v3h-3v2z"},child:[]}]})(e)}function Ol(e){return xt({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M0 0h24v24H0V0z"},child:[]},{tag:"path",attr:{d:"m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14l-6-6z"},child:[]}]})(e)}function kl(e){return xt({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M24 24H0V0h24v24z",opacity:".87"},child:[]},{tag:"path",attr:{d:"M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z"},child:[]}]})(e)}function bi(e){return xt({tag:"svg",attr:{viewBox:"0 0 1024 1024"},child:[{tag:"path",attr:{d:"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"},child:[]},{tag:"path",attr:{d:"M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0 1 30.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1 0 80 0 40 40 0 1 0-80 0z"},child:[]}]})(e)}let gt=1,qi=new Array,Xe=new Array;Nn.get("https://sheets.googleapis.com/v4/spreadsheets/18hHq4XYLPYSN1Wc0RjY5zl5vCHoVVrlugpG-O7cULLw/values/Workbook?key=AIzaSyCqcO7MQv4dsj76ps3nNJnMwTT8Cvqv-eM").then(e=>{let t=e.data.values,n=new Array;for(const i of t)gt>2&&i[1]!=""&&(qi.push(n),n=new Array),n.push(i),++gt});function Fl(){const[e,t]=C.useState(),[n,i]=C.useState(),[s,a]=C.useState(),r=Q(p=>p.isNotVisibleToggle),l=Q(p=>p.isVisibleToggle);Q(p=>p.isVisible);let{stepCount:o,howToData:u,setHowToWorkbook:c,setClickedPath:d,path:f}=C.useContext(ce);return C.useEffect(()=>{let p=new Array;Nn.get("https://sheets.googleapis.com/v4/spreadsheets/1grTucZ2sqLgZ4AtJq8EkyO__kLg-pazRVl3sbLNMaIY/values/Blad1?key=AIzaSyCqcO7MQv4dsj76ps3nNJnMwTT8Cvqv-eM").then(S=>{let A=S.data.values,x=new Array,y=[];for(const v of A)gt>0&&v[0]!=""?(x=new Array,x.push(v),p.push(x)):x.push(v),++gt;c(p);for(const v of p)v[0]!=""&&(Xe=new Array,Xe.push(v[0][0],v[0][1]),y.push(Xe));a(y)})},[]),C.useEffect(()=>{let p=new Array;for(const S of qi[o+1])S[12]!=""&&S[12]!=null&&(Xe=new Array,Xe.push(S[12]),p.push(Xe)),++gt;t(p)},[o]),C.useEffect(()=>{let p=[];if(s!=null){for(const S of e)for(const A of s)A.includes(`${S}`)&&p.push(A);i(p),e.length===0?r():l()}},[s,e]),z(Z,{children:z("div",{children:z("ul",{children:n?n.map((p,S)=>V("li",{children:[z(Cs,{to:`/HowTo/${p[0]}`,target:"_blank",rel:"noopener noreferrer",children:V("button",{type:"button",className:"stepNaviBtn",children:[p[0],". ",p[1]]})})," "]},S)):null})})})}function Hl(){const e=C.useRef(),[t,n]=C.useState(!1),{getCollapseProps:i,getToggleProps:s}=Ml({isExpanded:t}),a=Q(r=>r.isVisible);return V(Z,{children:[z("button",{type:"button",...s({onClick:()=>n(r=>!r)}),className:t?"expanded":"btn",style:{position:"absolute",top:"20px",left:"20px",visibility:`${a}`},children:t?V(Z,{children:[z(bi,{})," How To ",z(Ol,{})]}):V(Z,{children:[z(bi,{})," How To ",z(kl,{})]})}),z("div",{ref:e,className:"howToBoxContent",...i(),children:z(Fl,{})})]})}function Vl(){let{visibleObj:e,stepSVG:t}=C.useContext(ce);const n=Q(u=>u.cameraPositionTag),i=Q(u=>u.freeControls),s=Q(u=>u.wiringStep),a=Bi(),[r]=C.useState(()=>new D),[l]=C.useState(()=>new D),o=new D(4,1,8);return Ci((u,c)=>{n==="initial"&&s===!1&&(r.lerp(o,.1),l.lerp([0,0,0],.1),u.camera.position.copy(r),u.camera.lookAt(l),i(),a.refresh(e).fit()),n==="initial"&&s===!0&&(t.reset(),i())}),z(Z,{})}function Ql(){const e=Ze("./Fabulaser_V3_All_In.glb"),t=Ze("./Fabulaser_V3_All_Out.glb"),n=C.useMemo(()=>e.scene.clone(),[e]),i=C.useMemo(()=>e.scene.clone(),[e]),s=C.useMemo(()=>t.scene.clone(),[t]);C.useState(!1),C.useRef(),C.useRef(),Ze.clear("./Fabulaser_V3_All_In.glb"),Ze.clear("./Fabulaser_V3_All_Out.glb");const a=Q(l=>l.resetCamera);function r(){const{active:l,progress:o,errors:u,item:c,loaded:d,total:f}=Bs();return V(Html,{center:!0,children:[o," % loaded"]})}return z(Z,{children:V(C.Fragment,{children:[z("aside",{className:"stepNavi",children:z(ul,{})}),V("section",{id:"currentStepArea",children:[V("nav",{className:"currentStepBar",children:[z("h2",{id:"stepTitleArea",children:z(ll,{})}),V("div",{id:"stepControl",children:[z(Is,{}),"                        "]})]}),V("div",{className:"infoColumn",children:[z("div",{className:"stepPartsArea",children:z(ol,{})}),V("div",{className:"stepRemarksArea",children:[V("div",{style:{margin:"auto",display:"inline",alignContent:"baseline"},children:[V("h3",{children:[" ",z(Ul,{})," Remarks"]})," ",z("br",{})]}),z(dl,{})]})]}),V("article",{className:"viewArea",id:"viewArea",children:[z(C.Suspense,{fallback:z(r,{}),children:V(Ms,{linear:!0,flat:!0,frameloop:"demand",camera:{fov:45,near:1,far:10,position:[4,1,8]},children:[z(Gl,{}),z("color",{args:["#f5f5f5"],attach:"background"}),V(Ps,{clip:!0,observe:!0,damping:2,margin:.85,children:[z(al,{modelIn:e,modelOut:t,modelInCopy:n,modelInCopy2:i,modelOutCopy:s}),z(fl,{})]}),z(Vl,{})]})}),z(Us,{}),V("button",{className:"btn",style:{position:"absolute",bottom:"20px",left:"20px"},onClick:a,children:[z(Il,{})," Reset Camera"]}),z(Os,{}),z(Hl,{})]})]})]})})}Ze.preload("./Fabulaser_V3_All_In.glb");Ze.preload("./Fabulaser_V3_All_Out.glb");function Gl(){const e=C.useRef();return z(Z,{children:z(Rs,{ref:e,makeDefault:!0,enableDamping:!1,enableRotate:!0,minAzimuthAngle:1/0,maxAzimuthAngle:1/0,minPolarAngle:0,maxPolarAngle:1/0})})}export{Ql as default};
//# sourceMappingURL=App-b4f71cfe.js.map
